<!-- 博文的布局-Layout -->
<!DOCTYPE html>
<html>
<head>
<!-- 引入head标签 -->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-sclable=0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="description" content="HELLO HAMBUGGER" />
<meta name="keywords" content="hamburger_text" />
<link rel="stylesheet" href="/assets/css/style.css">
<link rel="stylesheet" href="/assets/css/media.css">
<link rel="stylesheet" href="/assets/css/animate.min.css">
<link rel="stylesheet" href="/assets/css/pygments/pygments_default.css">
<link rel="stylesheet" href="/assets/css/github-markdown.css">
<!-- SNS-icon -->
<script src="//at.alicdn.com/t/font_856428_y9z6nq7zf5.js"></script>
<!-- share.css -->
<link rel="stylesheet" href="/assets/css/share.min.css">
<!-- font -->
<link rel="stylesheet" href="/assets/css/font.css">
<!-- <link href="https://fonts.googleapis.com/css?family=Kaushan+Script|Pacifico|Ubuntu|Roboto+Mono|Source+Sans+Pro" rel="stylesheet"> -->

<!-- Favicon -->
<link href="/assets/profile.jpeg" rel="shortcut icon" />
<link href="/assets/profile.jpeg" rel="apple-touch-icon-precomposed" />
<!-- Android Lolipop Theme Color -->
<!-- <meta name="theme-color" content="#1464FB"> -->
<title>sulnteres的主页</title>
<!-- 百度统计 -->

<!-- 谷歌分析 -->


<!-- Android Lolipop Theme Color -->
<meta name="theme-color" content=" rgb(154,133,255) ">
</head>
<body>

<!-- 顶部锚点 -->
<a id="htmlup" name="htmlup"></a>
<!-- 引入博文顶部选项 -->

<header id="post-header" style="background-color:rgb(154,133,255);">
  <div class="top-center">
      <div class="logo">
          <a href="/" title="my awesome webtitle" style="color: white;">xjosiah_page</a>
      </div>
      <nav class="top-nav">
          <ul>
              
                <li><a href="/" style="color: white;">首页</a></li>
              
                <li><a href="/tags.html" style="color: white;">标签</a></li>
              
                <li><a href="/timeline.html" style="color: white;">时间线</a></li>
              
                <li><a href="/about.html" style="color: white;">关于博主</a></li>
              
                <li><a href="/friendLink.html" style="color: white;">友情链接</a></li>
              
          </ul>
      </nav>
      <div id="top-boot">
        <a href="javascript:;" id="boot1" style="display:block;" onclick="document.getElementById('boot-area').style.display='block';document.getElementById('boot1').style.display='none';document.getElementById('boot2').style.display='block';"><img src="/assets/boot_white.png" alt=""></a>
        <a href="javascript:;" id="boot2" style="display: none;" onclick="document.getElementById('boot-area').style.display='none';document.getElementById('boot1').style.display='block';document.getElementById('boot2').style.display='none';"><img src="/assets/boot_white.png" alt=""></a>
      </div>
  </div>

</header>


<!-- 引入移动下拉选项 -->
<div id="boot-area">
    <ul>
        
          <a href="/"><li>首页</li></a>
        
          <a href="/tags.html"><li>标签</li></a>
        
          <a href="/timeline.html"><li>时间线</li></a>
        
          <a href="/about.html"><li>关于博主</li></a>
        
          <a href="/friendLink.html"><li>友情链接</li></a>
        
    </ul>
</div>

<!-- 引入博文顶部样式 -->
<!-- 版本一 垃圾 -->
<!-- <div class="wow fadeIn top" data-wow-duration="3.5s" >
    <span class="wow fadeInUp" data-wow-delay="0.2s">Linux操作系统原理与应用笔记</span>
    <span class="wow fadeInUp" data-wow-delay="0.4s"></span>
    <span class="wow fadeInUp" data-wow-delay="0.4s"></span>
    <span class="wow fadeInUp" data-wow-delay="0.6s">作者&nbsp;&nbsp;|&nbsp;&nbsp;true</span>
</div> -->

<!-- 版本二 可切换页面 -->

<div class="post-top" style="background-color:rgb(154,133,255);">
  <!-- 页面宽度大于800px -->
  <div class="left-area">
    
      <a href="/2020/11/14/Final_Assignment_for_Software_Engineering.html" class="btn bounceInLeft animated" onmouseover="showLeft();this.style.color='rgb(154,133,255)';" onmouseout="goneLeft();this.style.color='rgba(0,0,0,.2)';"><</a>
      <div id="left-tab" style="display:none;"><span class="left-san"></span><span class="left-main" style="color:rgb(154,133,255);"><sapn class="main">疫情对软件开发的工作模式的影响</sapn></span></div>
    
  </div>
  <div class="post-titlearea">
    <span class="wow fadeInUp" data-wow-delay="0.2s">Linux操作系统原理与应用笔记</span>
    <!-- <span class="wow fadeInUp" data-wow-delay="0.4s"></span> -->
    <!-- <span class="wow fadeInUp" data-wow-delay="0.4s"></span> -->
    <!-- <span class="wow fadeInUp" data-wow-delay="0.6s">作者&nbsp;&nbsp;|&nbsp;&nbsp;true</span> -->
  </div>
  <div class="right-area">
    
      <a href="/2020/07/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html" class="btn bounceInRight self-animated" onmouseover="showRight();this.style.color='rgb(154,133,255)';" onmouseout="goneRight();this.style.color='rgba(0,0,0,.2)';">></a>
      <div id="right-tab" style="display:none;"><span class="right-san"></span><span class="right-main" style="color:rgb(154,133,255);"><sapn class="main">操作系统原理</sapn></span></div>
    
  </div>

  <!-- 页面宽度小于800px -->
  <div class="post-changearea">
    
      <a href="/2020/11/14/Final_Assignment_for_Software_Engineering.html" class="leftchange" style="border-right: 1px solid rgb(154,133,255);border-bottom: 2px solid rgb(154,133,255);"><span>上一篇<br><br>疫情对软件开发的工作模式的影响</span></a>
    
    
      <a href="/2020/07/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html" class="rightchange" style="border-left: 1px solid rgb(154,133,255);border-bottom: 2px solid rgb(154,133,255);"><span>下一篇<br><br>操作系统原理</span></a>
    
  </div>
</div>


<div class="markdown-body fadeInUp animated">

  
    
      <div class="postpage-subtitle" style="border-left: 8px solid rgb(154,133,255); border-right: 8px solid rgb(154,133,255)">
        深入理解Linux内核分析的重难点笔记理解
      </div>
    
  

  <!-- 文章内容 -->
  <h1 id="linux操作系统原理与应用笔记">Linux操作系统原理与应用笔记</h1>

<h2 id="第一章-概述">第一章 概述</h2>

<h3 id="linux内核的技术特点">linux内核的技术特点</h3>

<p>以实用性和效率为出发点，内核设计成==单内核结构==，整体上把内核作为一个大过程来实现，内核其实就函数和数据结构的集合，其与微内核相比可扩展性和可移植性较低，但与微内核不同，在与文件管理、设备驱动、虚拟内存管理、进程管理等其他上层模块之间不需要有较高的通信开销，==模块之间可以直接调用相关的函数==。（整体的概念）</p>

<h3 id="linux内核中链表的实现及应用">linux内核中链表的实现及应用</h3>

<blockquote>
  <p>​	双链表通过前趋和后继两个指针域就可以从两个方向循环双链表，如果打乱前趋后继的依赖关系，就可以构成<strong>“二叉树”</strong>、“循环链表”，设计更多的指针域还可以构成各种复杂的树状数据结构，如果减少一个指针域，还可以进一步设计成<strong>“栈”和“队列”</strong>。</p>
</blockquote>

<ul>
  <li>
    <p>链表的定义</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">list_head</span><span class="p">{</span>
  <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">next</span><span class="p">,</span><span class="o">*</span><span class="n">prev</span><span class="p">;</span>
<span class="p">}</span>
  
<span class="k">struct</span> <span class="n">my_list</span><span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">mydata</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>特点：list域隐藏了链表的指针特性，且一个结构中可以有多个list域</p>
  </li>
  <li>
    <p><strong>链表的操作</strong>
链表头初始化操作为：把前趋后继都指向自己，后续添加操作就是形成一个==循环链表==，内核代码<code class="highlighter-rouge">list.h</code>中定义了两个宏来定义链表头：</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define LIST_HEAD_INIT(name){&amp;(name),&amp;(name)}
#define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)
</span></code></pre></div>    </div>

    <p>添加节点的具体操作</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//	链表的添加节点</span>
  
<span class="cm">/*
*	静态内联函数 inline说明该函数对编译程序是可见的
*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__list_add</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
  <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
  <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">next</span>
<span class="p">){</span>
  <span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">=</span>	<span class="n">new</span><span class="p">;</span>
  <span class="n">new</span><span class="o">-&gt;</span><span class="n">next</span>	<span class="o">=</span>	<span class="n">next</span><span class="p">;</span>
  <span class="n">new</span><span class="o">-&gt;</span><span class="n">prev</span>	<span class="o">=</span>	<span class="n">prev</span><span class="p">;</span>
  <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span>	<span class="n">new</span><span class="p">;</span>
<span class="p">}</span>
  
<span class="c1">//	在链表头尾添加节点</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">list_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">){</span>
  <span class="n">__list_add</span><span class="p">(</span><span class="n">new</span><span class="p">,</span><span class="n">head</span><span class="p">,</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
<span class="p">}</span>
  
<span class="c1">//	在链表头节点后插入new节点</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">list_add_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">){</span>
  <span class="n">__list_add</span><span class="p">(</span><span class="n">new</span><span class="p">,</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span><span class="n">head</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p><code class="highlighter-rouge">__list_add</code>这个内部函数，可以看成是==在两个节点(prev节点和next节点)中插入一个新的节点==，这个设计十分巧妙，只要对其进行相应的封装就可以实现多种功能，如<code class="highlighter-rouge">list_add</code>和<code class="highlighter-rouge">list_add_tail</code> 这两个函数就可看出，一个是在head节点和后继节点间插入新节点，一个是在head节点和前趋节点间插入，可以用来分别实现<strong>一个栈和一个队列</strong>。</p>

    <ul>
      <li><em>关键字inline必须与函数定义体放在一起才能使函数成为内联，inline函数一般放在头文件中使用</em></li>
    </ul>
  </li>
  <li>
    <p><strong>循环链表操作</strong></p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//	每次只找出节点在链表中的偏移位置，还需要list_entry来找出节点的起始地址</span>
<span class="cp">#define list_for_each(pos,head)\
	for(pos=(head)-&gt;next; pos!=(head); pos=pos-&gt;next)
</span>  
<span class="cm">/*
*	(char *)(ptr)-(unsigned long)(&amp;((type *)0)-&gt;member)
*	ptr指向的是某一结构list域的绝对地址，type是某一结构，member是type结构中的某一域
* __返回值__ type *
*/</span>
<span class="cp">#define list_entry(ptr,type,member)\
	((type *)((char *)(ptr)-(unsigned long)(&amp;((type *)0)-&gt;member)))
</span>  
<span class="c1">//	安全的遍历节点，在释放节点前先记录下下一个要释放的节点，因为删除节点后</span>
<span class="c1">//	当前被删除的节点的前趋后继是指向内核中两个固定位置的，如果按list_for_each会出错</span>
<span class="cp">#define list_for_each_safe(pos,n,head)\
	for(pos=(head)-&gt;next,n=pos-&gt;next; pos!=(head); pos=n,n=pos-&gt;next)
</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__list_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">next</span><span class="p">){</span>
  <span class="n">next</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">=</span><span class="n">prev</span><span class="p">;</span>
  <span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">next</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">list_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">){</span>
  <span class="n">__list_del</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
  <span class="n">entry</span><span class="o">-&gt;</span><span class="n">next</span><span class="o">=</span><span class="n">LIST_POSTION1</span><span class="p">;</span>	<span class="c1">//	内核地址中的固定地址</span>
  <span class="n">entry</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">=</span><span class="n">LIST_POSTION2</span><span class="p">;</span>
<span class="p">}</span>
      
<span class="c1">//	具体代码中的应用</span>
<span class="k">struct</span> <span class="n">numlist</span><span class="p">{</span>
  <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
  <span class="k">struct</span> <span class="n">numlist</span> <span class="n">numhead</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">numhead</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
  
  <span class="k">struct</span> <span class="n">numlist</span> <span class="o">*</span><span class="n">listnode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">numlist</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="c1">//	遍历节点的操作</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="o">&amp;</span><span class="n">numhead</span><span class="p">.</span><span class="n">list</span><span class="p">){</span>
    <span class="c1">// 	list(prt,type,member)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="k">struct</span> <span class="n">numlist</span><span class="p">,</span><span class="n">list</span><span class="p">);</span>
    <span class="n">printk</span><span class="p">(...</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">...</span>
  <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> <span class="o">-</span> 
<span class="p">...</span>
  <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="c1">//	删除所有节点的操作</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="n">n</span><span class="p">,</span><span class="o">&amp;</span><span class="n">numhead</span><span class="p">.</span><span class="n">lits</span><span class="p">){</span>
    <span class="n">list_del</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span><span class="k">struct</span> <span class="n">numlist</span><span class="p">,</span><span class="n">list</span><span class="p">);</span>
    <span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
  	<span class="p">...</span>
  <span class="p">}</span>
<span class="p">...</span>
</code></pre></div>    </div>

    <p>具体分析<code class="highlighter-rouge">list_entry</code>:把0地址转换成type类型的指针，获取该结构中member域的指针，也就是为了==得到member在type结构中的偏移量==，而==ptr - member==就得到了type结构的起始地址，也就<strong>获得某一节点的起始地址</strong>，可以进一步读出type结构中的data域和list域</p>

    <p>哈希表也是链表的一种衍生，在<code class="highlighter-rouge">list.h</code>中也有相关实现</p>
  </li>
</ul>

<h2 id="第二章-内存寻找">第二章 内存寻找</h2>
<h3 id="内存寻址">内存寻址</h3>

<blockquote>
  <p>保护模式：这种模式下内存段的范围受到了限制，范围内存时不能直接从段寄存器中获得段的起始地址，而需要经过额外转换和检查（从此不能再随意存取数据段）</p>

  <p>线性地址：指一段连续的、不分段的，范围从0~4GB的地址空间，一个线性地址就是线性空间的一个绝对地址</p>
</blockquote>

<p>80386中地址总线和数据总线都是32位，寻址能力达到了4GB，但其为了兼容，还是保留了16位的段寄存器，并采用了在段寄存器基础上的方式来构筑保护机制，即寻址方式为：==段选择符：偏移地址（虚拟地址）==-&gt;线性地址（使用MMU转换）-&gt;物理地址，<strong>段寄存器中存放的是段选择符</strong>（简单理解为段描述表的索引）。</p>

<p>16位的段寄存器是明显不足以确定一个基地址，因此段寄存器里存放的段选择符就要发挥作用了，同时在保护模式下，系统中存放有三种类型的描述符表：GDT、IDT（中断描述符表）、LDT，为了加快读取速度还设计了三个寄存器，通过段选择符加描述符表的地址，就可以取得段描述符。</p>

<p>Linux为了保持可移植性并不真正地使用分段机制，开发人员巧妙地将所有段的基地址设置成0，因此所有的进程都共享了0~4GB的线性空间，这样“偏移量”就等于了“线性地址”，也就是说<strong>虚拟地址就直接等同于了线性地址</strong>，但这样会让段保护的第一个方法无法发挥作用，且如果线性空间直接映射到物理空间，还会出现进程使用的地址互相覆盖的问题，为此Linux使用了分页机制来解决问题。</p>

<p>页对应的是物理内存的块，大小都是4KB，通常采用两级页表（页目录和页表）的方法来实现线性地址到物理地址的映射，<strong>32位线性地址</strong>转换成<strong>物理地址</strong>的处理方式为：</p>

<ol>
  <li>最高10位为页目录项的索引，其左移两位后与CR3中的页目录基地址相加可以得到对应的页目录项地址</li>
  <li>中间10位为页表项的索引，其左移两位后与从页目录项得到的页表基址相加得到具体的页表项</li>
  <li>最低12位为页面偏移地址，从页表项中映射到页面的物理基址，与偏移地址相加就可得到要找的物理地址</li>
</ol>

<h3 id="linux具体实现内存寻址的方式">Linux具体实现内存寻址的方式</h3>

<p>目前很多平台都开始使用64位的处理器，Linux为了兼容使用了三级页表的机制，但当前讨论还是通过二级页表的模式为主，其三级页表具体设计为：线性地址（总目录：中间目录：页表：偏移量）。仅支持二级页表的处理器上使用三级页表的模式时，Linux把中间目录当成只有一项，并把其“折叠”到总目录之中，从而适应了二级页表的机制。</p>

<p>Linux中每一个进程都有自己的页目录和页表集，当进程发生切换时，<strong>Linux把CR3的内容存放到前一个执行进程的PCB中</strong>，而把下一个要执行的进程的PCB的值装入到CR3中，恢复进程的时候，Linux会先查找PCB中的暂存的内容并恢复到CR3中，从而使分页单元指向正确的页表</p>

<p><strong>linux内核初始化页表的代码实现</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#define NR_PGT 0x4   												//  需要初始化的页面个数
</span>  <span class="cp">#define PGD_BASE (unsigned int *)0x1000     //  页目录表映射到物理内存的地址
</span>  <span class="cp">#define PAGE_OFFSET (unsigned int)0x2000    //	页表的起始地址	
</span>
  <span class="cp">#define PTE_PRE 0x01    // 初始化时 页表会装入内存
</span>  <span class="cp">#define PTE_RW  0x02    // 与U/S位形成硬件保护 
</span>  <span class="cp">#define PTE_USR 0x04    // Page Write-Through 写透方式
</span>
  <span class="kt">void</span> <span class="nf">page_init</span><span class="p">(){</span>
      <span class="kt">int</span> <span class="n">pages</span> <span class="o">=</span> <span class="n">NR_PGT</span><span class="p">;</span> 										<span class="c1">//  系统初始化时创建4个页表</span>
      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">page_offset</span> <span class="o">=</span> <span class="n">PAGE_OFFSET</span><span class="p">;</span>
      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">pgd</span> <span class="o">=</span> <span class="n">PGD_BASE</span><span class="p">;</span>          <span class="c1">//  页目录表存放的物理地址</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">pages</span><span class="o">--</span><span class="p">)</span>
      <span class="p">{</span>
          <span class="o">*</span> <span class="n">pgd</span><span class="o">++</span> <span class="o">=</span> <span class="n">page_offset</span> <span class="o">|</span><span class="n">PTE_USR</span><span class="o">|</span><span class="n">PTE_RW</span><span class="o">|</span><span class="n">PTE_PRE</span><span class="p">;</span>  <span class="c1">//  创建四个页目录表项</span>
          <span class="n">page_offset</span> <span class="o">+=</span> <span class="mh">0x1000</span>   												<span class="c1">//  每个页目录表的大小为2^12=4KB</span>
      <span class="p">}</span>
      <span class="n">pgd</span> <span class="o">=</span> <span class="n">PGD_BASE</span><span class="p">;</span>

      <span class="c1">//  页表从物理内存第三个页框开始</span>
      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pgt_entry</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="mh">0x2000</span><span class="p">;</span>   
      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">phy_add</span> <span class="o">=</span> <span class="mh">0x0000</span><span class="p">;</span>
      <span class="c1">//  0x1000000=16MB 初始化了四个页表，每个页表映射了4MB的物理内存地址</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">phy_add</span> <span class="o">&lt;</span> <span class="mh">0x1000000</span><span class="p">)</span> 
      <span class="p">{</span>
          <span class="o">*</span> <span class="n">pgt_entry</span> <span class="o">=</span> <span class="n">phy_add</span> <span class="o">|</span><span class="n">PTE_USR</span><span class="o">|</span><span class="n">PTE_RW</span><span class="o">|</span><span class="n">PTE_PRE</span><span class="p">;</span>  <span class="c1">//  页面与物理内存真正形成映射</span>
          <span class="n">phy_add</span> <span class="o">+=</span> <span class="mh">0x1000</span><span class="p">;</span>      												<span class="c1">//  物理块大小和页面大小都是4KB</span>
      <span class="p">}</span>

      <span class="c1">//  CR0最高位为控制分页位，linux下分页机制的开启是可选的，则段内嵌汇编的作用就是允许分页</span>
      <span class="n">__asm__</span> <span class="n">__volatile__</span><span class="p">(</span><span class="s">"movl  %0, %%cr3;"</span>
                                  <span class="s">"movl   %%cr0, %%eax;"</span>
                                  <span class="s">"orl    $0x80000000, %%eax;"</span>
                                  <span class="s">"movl   %%eax, %%cr0;"</span><span class="o">::</span><span class="s">"r"</span><span class="p">(</span><span class="n">pgd</span><span class="p">)</span><span class="o">:</span><span class="s">"memory"</span><span class="p">,</span><span class="s">"%eax"</span><span class="p">);</span>

  <span class="p">}</span>
</code></pre></div></div>

<h2 id="第三章-进程">第三章 进程</h2>

<h3 id="linux系统中的进程控制块">linux系统中的进程控制块</h3>

<p>linux中对进程的描述结构叫做PCB（task_struct）其是一个相当庞大的结构体，按功能可以分成以下几类</p>

<ol>
  <li>状态信息-描述进程的动态变化</li>
  <li>链接信息-描述进的亲属关系</li>
  <li>各种标识符</li>
  <li>进程间通信信息</li>
  <li>时间和定时器信息</li>
  <li>调度信息</li>
  <li>文件系统信息</li>
  <li>虚拟内存信息-描述进程编译连接后形成的地址空间</li>
  <li>处理器环境信息-进程的执行环境（处理器的各种寄存器及堆栈信息），==体现进程动态变化最主要的场景==</li>
</ol>

<p>系统创建一个新进程的时候就是在内核中为它建立了一个PCB，进程结束的时候又收回PCB，其是内核中频繁读写的数据结构，因此应当常驻内存。</p>

<p>每当进程从用户态进入内核态后都要使用栈-进程的内核栈，进程一进入内核态，CPU就自动为其设置该进程的内核栈，这个栈位于<strong>内核的数据段</strong>上，其==<em>内核栈和一个<code class="highlighter-rouge">thread_info</code>结构存放在一起，大小为8KB</em>==。实际上内核为PCB分配空间的方式是动态的（<strong>确切地说，内核根本不为PCB分配内存</strong>），而仅仅给内核栈分配8KB的内存，并把一部分让给PCB使用(thread_info)。</p>

<p>段起始于末端，并朝这个内存区开始的方向增长，从用户态转到内核态以后，<u>进程的内核栈总是空的</u>，堆栈寄存器ESP直接指向内存区的顶端，只要把数据写入栈中，ESP的值递减。<code class="highlighter-rouge">thread_info</code>与内核栈存放在一起的最大好处是，内存栈很容易从<code class="highlighter-rouge">ESP</code>的值获取到当前CPU上运行的<code class="highlighter-rouge">thread_info</code>结构的地址，因为<code class="highlighter-rouge">thread_union</code>(内核栈和thread_info)结构的长度是8KB，<strong>则内核屏蔽ESP的低13位就得到thread_info结构的基地址</strong>，通过<code class="highlighter-rouge">*task</code>就可以得到该进程的PCB，<code class="highlighter-rouge">PCB</code>和<code class="highlighter-rouge">thread_info</code>都有一个域是指向对方的，是一种一一对应的关系，而再定义一个<code class="highlighter-rouge">thread_info</code>结构的原因有两种可能：1.该结构是最频繁被调用的 2.随着linux版本的变化，PCB越来越大，为了节省内核栈的空间，需要把一部分的PCB内容移出内核栈，只保留最频繁被使用的<code class="highlighter-rouge">thread_info</code></p>

<h3 id="linux中进程的组织方式">linux中进程的组织方式</h3>

<p>内核建立了几个进程链表，双向循环链表的头尾都是<code class="highlighter-rouge">init_task</code>（0号进程的PCB，是预先由编译器静态分配到内核数据段的，在运行过程中保持不变，永远不会被撤销的），系统使用哈希表和链地址法来加速用PID找到相应PCB的过程，并组织好了一个就绪队列和等待队列</p>

<ul>
  <li>
    <p>就绪队列存放处于就绪态和运行态的进程</p>
  </li>
  <li>
    <p>等待队列存放睡眠进程，对中断处理、进程同步和定时用处很大</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//	等待队列的数据结构</span>
<span class="k">struct</span> <span class="n">__wait_queue</span><span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">init</span> <span class="n">flages</span><span class="p">;</span>	<span class="c1">//	区分互斥进程和非互斥进程，对于互斥进程值为（WQ_FLAG_EXCLUSIVE）</span>
  <span class="cp">#define WQ_FLAG_EXCLUSIVE 	0x01	
</span>  <span class="kt">void</span> <span class="o">*</span> <span class="n">private</span><span class="p">;</span>							<span class="c1">//	传递给func的参数</span>
  <span class="n">wait_queue_func_t</span> <span class="n">func</span><span class="p">;</span>			<span class="c1">//	用于唤醒进程的函数，需要根据等待的原因归类</span>
  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">task_list</span><span class="p">;</span>	<span class="c1">//	用于组成等待队列</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">__wait_queue</span> <span class="n">wait_queue_t</span><span class="p">;</span>
  
<span class="c1">//	等待队列头结构</span>
<span class="cm">/*
*	等待队列是由中断处理程序和主要内核函数修改的,因此必须对其双向链表保护,以免对其进行同时访问
*	所以采用了自旋锁来进行同步
*/</span>
<span class="k">struct</span> <span class="n">__wait_queue_head</span><span class="p">{</span>
  <span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">task_list</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>

    <p>等待队列是由中断处理程序和主要内核函数修改的，因此必须对其双向链表保护，以免对其进行同时访问，所以采用了自旋锁来进行同步</p>

    <p>等待队列的操作<code class="highlighter-rouge">add_wait_queue()</code>把一个非互斥进程插入到等待队列链表的第一个位置，<code class="highlighter-rouge">add_wait_queue_exclusive()</code>把一个互斥进程插入但等待队列的最后一个位置。让某一个进程去睡眠的最基本操作为：先把当前进程的状态设置成<code class="highlighter-rouge">TASK_UNINTERRUPTIBLE</code>并把它插入到特定的等待队列中，然后调用调度程序，当进程被唤醒的时候会接着执行剩余的指令，同时把进程从等待队列中删除</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//	wake_up()函数</span>
<span class="kt">void</span> <span class="nf">wake_up</span><span class="p">(</span><span class="n">wait_queue_head_t</span><span class="p">){</span>
  <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
  <span class="n">wait_queue_t</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>
  <span class="c1">//	扫描链表，找等待队列中的所有进程</span>
  <span class="n">list_for_each</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">task_list</span><span class="p">){</span>
    <span class="c1">//	curr指向每个等待进程的起始地址</span>
    <span class="n">curr</span><span class="o">=</span><span class="n">list_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span><span class="n">wait_queue_t</span><span class="p">,</span><span class="n">task_list</span><span class="p">);</span>
    <span class="cm">/*如果进程已经被唤醒并且进程是互斥的，则循环结束
     *因为所有的非互斥进程都是在链表的开始位置，而所有的互斥进程都在链表的尾部，所以可以先唤醒非互斥			 *进程再唤醒互斥进程
     */</span>
    <span class="k">if</span><span class="p">(</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span><span class="n">TASK_INTERRUPTIBLE</span><span class="o">|</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nb">NULL</span><span class="p">)</span><span class="o">&amp;&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="linux进程调度">linux进程调度</h3>

<p>linux进程调度是时机：</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. 进程状态转换的时刻，使用`sleep_on()`、`exit()`时会主动调用调度函数
 	2. 当前进程的时间片用完
 	3. 设备驱动程序运行时
 	4. 从内核态返回到用户态时，从系统调用返回意味着离开内核态，状态转换需要花费一定的时间，在返回到用户态前，系统把在内核态该处理的事应当全部做完。
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//	schedule() 函数主框架 </span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__sched</span> <span class="n">notrace</span> <span class="nf">__schedule</span><span class="p">(</span><span class="n">bool</span> <span class="n">preempt</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">switch_count</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">rq</span> <span class="o">*</span><span class="n">rq</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>

    <span class="cm">/*  ==1==  
        找到当前cpu上的就绪队列rq
        并将正在运行的进程curr保存到prev中  */</span>
    <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
    <span class="n">rq</span> <span class="o">=</span> <span class="n">cpu_rq</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">;</span>

    <span class="cm">/*
     * do_exit() calls schedule() with preemption disabled as an exception;
     * however we must fix that up, otherwise the next task will see an
     * inconsistent (higher) preempt count.
     *
     * It also avoids the below schedule_debug() test from complaining
     * about this.
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">TASK_DEAD</span><span class="p">))</span>
        <span class="n">preempt_enable_no_resched_notrace</span><span class="p">();</span>

    <span class="cm">/*  如果禁止内核抢占，而又调用了cond_resched就会出错
     *  这里就是用来捕获该错误的  */</span>
    <span class="n">schedule_debug</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">sched_feat</span><span class="p">(</span><span class="n">HRTICK</span><span class="p">))</span>
        <span class="n">hrtick_clear</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>

    <span class="cm">/*  关闭本地中断  */</span>
    <span class="n">local_irq_disable</span><span class="p">();</span>

    <span class="cm">/*  更新全局状态，
     *  标识当前CPU发生上下文的切换  */</span>
    <span class="n">rcu_note_context_switch</span><span class="p">();</span>

    <span class="cm">/*
     * Make sure that signal_pending_state()-&gt;signal_pending() below
     * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)
     * done by the caller to avoid the race with signal_wake_up().
     */</span>
    <span class="n">smp_mb__before_spinlock</span><span class="p">();</span>
    <span class="cm">/*  锁住该队列  */</span>
    <span class="n">raw_spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
    <span class="n">lockdep_pin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

    <span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_skip_update</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* promote REQ to ACT */</span>

    <span class="cm">/*  切换次数记录, 默认认为非主动调度计数(抢占)  */</span>
    <span class="n">switch_count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">nivcsw</span><span class="p">;</span>

    <span class="cm">/*
     *  scheduler检查prev的状态state和内核抢占表示
     *  如果prev是不可运行的, 并且在内核态没有被抢占
     *  
     *  此时当前进程不是处于运行态, 并且不是被抢占
     *  此时不能只检查抢占计数
     *  因为可能某个进程(如网卡轮询)直接调用了schedule
     *  如果不判断prev-&gt;stat就可能误认为task进程为RUNNING状态
     *  到达这里，有两种可能，一种是主动schedule, 另外一种是被抢占
     *  被抢占有两种情况, 一种是时间片到点, 一种是时间片没到点
     *  时间片到点后, 主要是置当前进程的need_resched标志
     *  接下来在时钟中断结束后, 会preempt_schedule_irq抢占调度
     *  
     *  那么我们正常应该做的是应该将进程prev从就绪队列rq中删除, 
     *  但是如果当前进程prev有非阻塞等待信号, 
     *  并且它的状态是TASK_INTERRUPTIBLE
     *  我们就不应该从就绪队列总删除它 
     *  而是配置其状态为TASK_RUNNING, 并且把他留在rq中

    /*  如果内核态没有被抢占, 并且内核抢占有效
        即是否同时满足以下条件：
        1  该进程处于停止状态
        2  该进程没有在内核态被抢占 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">preempt</span> <span class="o">&amp;&amp;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span>
    <span class="p">{</span>

        <span class="cm">/*  如果当前进程有非阻塞等待信号，并且它的状态是TASK_INTERRUPTIBLE  */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">signal_pending_state</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">prev</span><span class="p">)))</span>
        <span class="p">{</span>
            <span class="cm">/*  将当前进程的状态设为：TASK_RUNNING  */</span>
            <span class="n">prev</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">TASK_RUNNING</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>   <span class="cm">/*  否则需要将prev进程从就绪队列中删除*/</span>
        <span class="p">{</span>
            <span class="cm">/*  将当前进程从runqueue(运行队列)中删除  */</span>
            <span class="n">deactivate_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">DEQUEUE_SLEEP</span><span class="p">);</span>

            <span class="cm">/*  标识当前进程不在runqueue中  */</span>
            <span class="n">prev</span><span class="o">-&gt;</span><span class="n">on_rq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

            <span class="cm">/*
             * If a worker went to sleep, notify and ask workqueue
             * whether it wants to wake up a task to maintain
             * concurrency.
             */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_WQ_WORKER</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">to_wakeup</span><span class="p">;</span>

                <span class="n">to_wakeup</span> <span class="o">=</span> <span class="n">wq_worker_sleeping</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">to_wakeup</span><span class="p">)</span>
                    <span class="n">try_to_wake_up_local</span><span class="p">(</span><span class="n">to_wakeup</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="cm">/*  如果不是被抢占的，就累加主动切换次数  */</span>
        <span class="n">switch_count</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">nvcsw</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/*  如果prev进程仍然在就绪队列上没有被删除  */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">task_on_rq_queued</span><span class="p">(</span><span class="n">prev</span><span class="p">))</span>
        <span class="n">update_rq_clock</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>  <span class="cm">/*  跟新就绪队列的时钟  */</span>

    <span class="cm">/*  挑选一个优先级最高的任务将其排进队列  */</span>
    <span class="n">next</span> <span class="o">=</span> <span class="n">pick_next_task</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
    <span class="cm">/*  清除pre的TIF_NEED_RESCHED标志  */</span>
    <span class="n">clear_tsk_need_resched</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
    <span class="cm">/*  清楚内核抢占标识  */</span>
    <span class="n">clear_preempt_need_resched</span><span class="p">();</span>

    <span class="n">rq</span><span class="o">-&gt;</span><span class="n">clock_skip_update</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/*  如果prev和next非同一个进程  */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">prev</span> <span class="o">!=</span> <span class="n">next</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">rq</span><span class="o">-&gt;</span><span class="n">nr_switches</span><span class="o">++</span><span class="p">;</span>  <span class="cm">/*  队列切换次数更新  */</span>
        <span class="n">rq</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>    <span class="cm">/*  将next标记为队列的curr进程  */</span>
        <span class="o">++*</span><span class="n">switch_count</span><span class="p">;</span>    <span class="cm">/* 进程切换次数更新  */</span>

        <span class="n">trace_sched_switch</span><span class="p">(</span><span class="n">preempt</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
        <span class="cm">/*  进程之间上下文切换    */</span>
        <span class="n">rq</span> <span class="o">=</span> <span class="n">context_switch</span><span class="p">(</span><span class="n">rq</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span> <span class="cm">/* unlocks the rq */</span>
    <span class="p">}</span>
    <span class="k">else</span>    <span class="cm">/*  如果prev和next为同一进程，则不进行进程切换  */</span>
    <span class="p">{</span>
        <span class="n">lockdep_unpin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
        <span class="n">raw_spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rq</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">balance_callback</span><span class="p">(</span><span class="n">rq</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">STACK_FRAME_NON_STANDARD</span><span class="p">(</span><span class="n">__schedule</span><span class="p">);</span> <span class="cm">/* switch_to() */</span>

<span class="cm">/*转载自： http://blog.csdn.net/gatieme*/</span>

<span class="cm">/* 进程地址空间切换详解 */</span>
<span class="n">kstat</span><span class="p">.</span><span class="n">context_swtch</span><span class="o">++</span><span class="p">;</span>	<span class="c1">//	统计上下文切换的次数</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span> <span class="o">=</span> <span class="n">next</span> <span class="o">-&gt;</span> <span class="n">mm</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">oldmm</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">-&gt;</span> <span class="n">active_mm</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">mm</span><span class="p">){</span>		<span class="c1">//	没有用户空间，表明这为内核线程</span>
    <span class="k">if</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="o">==</span><span class="nb">NULL</span><span class="p">)</span><span class="n">BUG</span><span class="p">();</span>
    <span class="n">nexit</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="o">=</span><span class="n">oldmm</span><span class="p">;</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>			<span class="c1">//	一般进程则切换到这段用户空间</span>
    <span class="k">if</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="o">!=</span><span class="n">mm</span><span class="p">)</span><span class="n">BUG</span><span class="p">();</span>
    <span class="n">switch_mm</span><span class="p">(</span><span class="n">oldmm</span><span class="p">,</span><span class="n">mm</span><span class="p">,</span><span class="n">next</span><span class="p">,</span><span class="n">this_cpu</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">){</span>		<span class="c1">//	切换出去的是内核线程的处理方式</span>
    <span class="n">prev</span><span class="o">-&gt;</span><span class="n">active_mm</span><span class="o">=</span><span class="nb">NULL</span><span class="p">;</span>
    <span class="n">mmdrop</span><span class="p">(</span><span class="n">oldmm</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>Linux schedule()分析：</p>

<ol>
  <li>进程需要有自己的地址空间，或者和其他进程借用，如果都没有则出错，且如果<code class="highlighter-rouge">schedule()</code>在中断服务程序内部执行也出错</li>
  <li>对当前进程要做相关的处理，应当进入调度程序是，其状态不一定还是<code class="highlighter-rouge">TASK_RUNNNING</code></li>
  <li>进程地址空间切换，如果新进程有自己的用户空间，则<code class="highlighter-rouge">switch_mm()</code>函数会把该进程从内核空间转换到用户空间（加载下一个要执行的进程的页目录）；如果新进程是一个内核线程，无用户空间而在内核空间中运行，则要借用前一个进程的地址空间，因为所有的进程的内核空间都是共享的。如果切换出去的如果是内核线程，则要归还所借用的地址空间，并把mm_struct 中的共享计数减1</li>
</ol>

<h3 id="linux进程创建线程及其创建">Linux进程创建、线程及其创建</h3>

<p>Linux创建进程的方式是通过<code class="highlighter-rouge">fork()</code>或者<code class="highlighter-rouge">clone()</code>，然后再调用<code class="highlighter-rouge">exec()</code>，其使用的是写时复制技术（把父子进程的全部资源都设为只读，在父子进程尝试对其进行修改时才将被修改前的全部资源复制给子进程），创建进程的实际花销是为其创建PCB并把父进程的页表拷贝一份，如果进程中包含线程，则所有线程共享这些资源，无须拷贝。子进程一开始处于深度睡眠态，以确保它不会立刻运行，在把进程PCB插入到进程链表和哈希表后才将其设成就绪态，并让其平分父进程剩余的时间片，内核有意让子进程先执行，是为了让子进程使用<code class="highlighter-rouge">exec()</code>去执行其自己的代码，避免父进程操作引起写时复制，提高系统运行速度</p>

<p>Linux把线程看成一个使用某些共享资源的进程，每个线程有唯一的PCB，一般情况下内核线程会在创建时永远地执行下去，在需要的时候就会被唤醒和执行。</p>

<ol>
  <li>进程0：内核初始化工作的<code class="highlighter-rouge">start_kernel()</code>创建一个内核线程也就是进程0，其PCB就是<code class="highlighter-rouge">init_task</code></li>
  <li>进程1：也就是init进程，其一开始是一个内核线程，其调用了<code class="highlighter-rouge">execve()</code>装入了用户态下可执行程序init(/sbin/init)，因此init是内核线程启动起来的一个普通进程，也就是用户态下的第一个进程</li>
</ol>

<h2 id="第四章-内存管理">第四章 内存管理</h2>

<p>32位平台线性空间固定大小为4GB，其中高地址1GB（0xC000 0000~0xffff ffff）是内核空间，被内核使用并且由所有进程共享，每个用户进程的用户空间为3GB大小，通过分页机制实现各个进程的用户空间私有。</p>

<p>进程页目录PGB就位于内核空间中，在切换进程的时候需要将CR3指向新进程的PGB，CR3需要物理地址，而PGB在内核中的起始地址是虚地址，这时候需要转换，Linux的内核空间有一个独特设计，即==内核空间连续地占据了每个虚拟空间中最高的1GB，映射到物理内存却总是从最低地址开始的==，因此内核地址到物理地址只需要减去<code class="highlighter-rouge">PAGE_OFFSET</code>就可以了。</p>

<p>内核地址空间的结构：内核的代码和数据叫做内核映像，Linux内核映像存放于0x0010 0000开始的地方</p>

<ol>
  <li>这前1M的空间用于存放于系统硬件相关的代码和数据</li>
  <li>内核映像占用0x10 0000到start_mem的空间</li>
  <li>Start_mem到end_mem这段区域叫做动态内存，是用户程序和数据使用的内存区</li>
</ol>

<h3 id="进程的用户空间管理">进程的用户空间管理</h3>

<p>用户地址空间的结构：用户程序经过编译和链接后形成二进制映像文件，数据段、代码段、堆栈使用的空间都是在建立进程的时候就分配好，都属于必需的基本要求</p>

<ol>
  <li>堆栈段：在用户空间顶部，由顶向下延伸</li>
  <li>BSS：动态分配的空间</li>
  <li>数据段：静态分配的数据空间，</li>
  <li>代码段：程序的相关代码</li>
</ol>

<p>每个进程只有一个<code class="highlighter-rouge">mm_struct</code>，其是对整个用户空间的描述，而一个进程的虚拟空间中可能有多个虚拟区间，用<code class="highlighter-rouge">vm_area_struct</code>描述，如堆栈段、数据段……</p>

<ul>
  <li>
    <p><code class="highlighter-rouge">mm_struct</code>	在 <code class="highlighter-rouge">task_struct</code> 可以找到指向该结构的指针，虽然每个进程只有一个虚拟地址空间，但是该空间可以被其他进程所共享，因此需要使用原子类型的操作 <code class="highlighter-rouge">atomic_t</code>(该结构中包含了一个计数器)，<strong>描述了代码段、数据段、参数段已经环境段的起始地址和结束地址</strong>，==还有指针pgt指向该进程的页目录==</p>

    <blockquote>
      <p><strong><em>进程页表和内核页表的区别</em></strong> - <a href="https://blog.csdn.net/chuba6693/article/details/100612637">Linux 内核页表和进程页表</a></p>

      <ul>
        <li>在保护模式下，<strong>从硬件角度看，其运行的基本对象为“进程”(或线程)，而寻址则依赖于“进程页表”</strong>，在进程调度而进行上下文切换时，会进行页表的切换：即将新进程的pgd(页目录)加载到CR3寄存器中。</li>
        <li><strong>进程页表中的线性地址包括两个部分：用户态和内核态</strong>，内核态地址对应的相关页表项，对于所有进程来说都是相同的(因为<strong>内核空间对所有进程来说都是共享的</strong>)，而这部分页表内容其实就来源于“内核页表”，即每个进程的“进程页表”中内核态地址相关的页表项都是“内核页表”的一个拷贝。</li>
        <li><strong>内核页表也包括两个部分：线性映射区和vmalloc区</strong>，“内核页表”由内核自己维护并更新，在<code class="highlighter-rouge">vmalloc区</code>发生<code class="highlighter-rouge">page fault</code>时，将“内核页表”同步到“进程页表”中。</li>
        <li>以<code class="highlighter-rouge">vmalloc</code>为例(最常使用)，这部分区域对应的线性地址在内核使用<code class="highlighter-rouge">vmalloc</code>分配内存时，其实就已经分配了相应的物理内存，并做了相应的映射，建立了相应的页表项，但<strong>相关页表项仅写入了“内核页表”，并没有实时更新到“进程页表中”，内核在这里使用了“延迟更新”的策略</strong>，将“进程页表”真正更新推迟到第一次访问相关线性地址，发生<code class="highlighter-rouge">page fault</code>时，此时在<code class="highlighter-rouge">page fault</code>的处理流程中进行“进程页表”的更新。</li>
      </ul>
    </blockquote>
  </li>
  <li>
    <p><code class="highlighter-rouge">vm_area_struct</code> Linux把虚存区看成是对象，把用户空间划分成一段一段是因为每个虚存区的来源可能不同，有的来自可执行映像，有的来自共享库、动态分配的内存区，不同的区有不同的操作权限和操作方法；<code class="highlighter-rouge">vm_area_struct</code> 可用双向链表和红黑树来组织，有利于快速定位虚存区</p>
  </li>
</ul>

<p>创建进程的时候，进程用户空间的创建依赖于父进程，所做的工作仅仅是<code class="highlighter-rouge">mm_struct</code>和<code class="highlighter-rouge">vm_area_struct</code>的创建以及页目录和页表的建立，采用<strong>写时复制</strong>的方法。Linux并不把进程的可执行映像装入物理内存，只是把它们链接到进程的用户空间，被引用的程序部分会由操作系统装入物理内存，也就是需要使用请页机制</p>

<h3 id="请页机制">请页机制</h3>

<p>给进程分配新物理页面的确定方式：</p>

<ol>
  <li>如果页面不在内存中，页没有被调入，则内核分配一个新页面并初始化，“请求调页”</li>
  <li>如果页面在内存但是只读，则内核分配一个新页面并复制旧页面的内容，“写时复制”</li>
</ol>

<ul>
  <li><em>请求调页：写处理，获取新页面，把页面填为0，把页表置为新页面的物理地址，并设页面为可写和脏；读处理，分配一个零页，零页在内核初始化期间被静态分配并标记为不可写，当进程写该页面的时候才使用写时复制</em></li>
</ul>

<h3 id="物理内存">物理内存</h3>

<p>内核用<code class="highlighter-rouge">struct page</code>结构表示系统中的每一个物理页面，也叫页描述符，这种结构目的在于描述物理内存本身，内核仅用这个数据结构来描述当前时刻在相关物理页中存放的东西。</p>

<p><strong>伙伴算法</strong>：Linux把空闲页面分为10块链表，每个链表中的一个块为2的幂次个页面，</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">struct</span> <span class="n">free_area_struct</span><span class="p">{</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>		<span class="c1">//	用于将page链接成一个双向链表</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>		
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>		<span class="c1">//	map指向一个位图</span>
  <span class="p">}</span><span class="n">free_area</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</code></pre></div></div>

<p>算法过程：如果要求分配的块大小为128个页面，则去块大小为128的链表中找，如果没有则往上找，如果256大小的链表中有空间，则把256个页面平分，高地址的被使用，低地址的加入128的链表中，回收过程则相反，同时要注意相邻的物理页面要进行合并</p>

<p>Linux中有<code class="highlighter-rouge">freepages</code>结构，来使用内核交换守护进程(<code class="highlighter-rouge">kswapd</code>)保证系统有足够的物理内存，结构中有<code class="highlighter-rouge">min|low|high</code>三条线，各个界限值是通过实际的物理内存大小计算出来的，少于low会开启强交换；少于high会启动后台交换；高于high则什么都不做。</p>

<p><strong>Slab分配机制</strong>：用于解决内碎片，减少对伙伴算法的调用次数。对于预期频繁使用的内存区可以创建特定大小的专业缓冲区来处理，使用较少的内存区创建通用缓冲区来处理。</p>

<ul>
  <li>slab缓冲区由一连串的大块slab构成，每个大块中包含了若干个同类型的对象，实际上缓冲区是内存中的一片区域，这片区域划分为多个slab块，每个slab由一个或者多个页面组成，存放的都是同一类型的对象</li>
  <li>通用缓冲区，通用缓冲区最小的为32B、64B…..128KB，对通用缓冲区的管理依旧是slab方式</li>
</ul>

<blockquote>
  <table>
    <tbody>
      <tr>
        <td><code class="highlighter-rouge">kmalloc()</code>用于分配内核中的连续内存</td>
        <td><code class="highlighter-rouge">vmalloc()</code>用于分配非连续的内核内存</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<h3 id="回收机制">回收机制</h3>

<p>把页面换出推迟到无法推迟为止，换出页面的时候不需要先将内容写入到磁盘中，如果一个页面从最近一次换入后并没有被写过则它是干净的，可以一直缓冲到必要时才加以回收；写过的脏页面放到磁盘交换区中，但不立即释放，一直推迟到必要时才进行，如果一个页面在释放后又被访问，则重新从磁盘缓冲区读入即可</p>

<p>内核守护线程<code class="highlighter-rouge">kswapd</code>是有自己的PCB，一样受到内核的调度，由内核设计时规定多久运行一次，</p>

<h2 id="第五章-中断和异常">第五章 中断和异常</h2>

<blockquote>
  <p>异常：1. 故障   2. 陷阱 
		  中断：1.可屏蔽中断（外部，IRQ） 2.非屏蔽中断（计算机内部的硬件故障-缺页）</p>

  <p>通常我们指的<strong>异常</strong>是指<em>异常和非屏蔽中断</em>，<strong>中断</strong>特指<em>可屏蔽的中断</em></p>
</blockquote>

<p><strong>Linux中有256个中断向量：</strong>0-31号对应为异常（异常和非屏蔽中断）向量；32-47号对应中断向量，可屏蔽中断可以通过对中断控制器的编程来改变；48-255号对应软中断，Linux只使用了128号中断（int 0x80）来实现系统调用</p>

<p>外设可屏蔽中断，<strong>x86通过两片8259A中断控制器来响应15个外中断源</strong>，每个8259A可管理8个中断源，第二个芯片通过第一个芯片（主片）的2号中断线连接，与中断控制器相连的线称为中断线，<strong>申请一条中断线就是申请一个IRQ或者申请一个中断号</strong>，IRQ从0开始编号，IRQn的默认中断向量就是n+32。</p>

<p>对于外部I/O请求的屏蔽可以分成两种</p>

<ol>
  <li>CPU内部关中断，则屏蔽所有外部中断</li>
  <li>中断控制器内部的中断控制寄存器，其对应芯片的各条中断线，可以屏蔽特定中断线上的中断</li>
</ol>

<p><strong>中断线是可共享的由一个中断处理程序统一处理，而一个中断处理程序又拥有多个对应设备的中断服务例程</strong></p>

<ul>
  <li><u>*异常与外部接口没有任何关系，CPU执行一个异常处理程序的时候需要关中断，即屏蔽其他异常和中断，**CPU具有异常锁存的功能**，可以避免异常处理的嵌套，Linux内核必须针对不同的处理器发布的所有异常提供专门的异常处理程序*</u></li>
</ul>

<h3 id="中断描述符表">中断描述符表</h3>

<p>实模式下，0-1KB的内存空间用来存放中断向量表，表项为段地址和偏移量组成；在保护模式下，4字节的表项不足以满足需求，此时表项为：2字节的段地址、4字节的偏移量和2字节反映模式切换的信息，中断向量表也该交为中断描述符表(IDT)，其表项被称为门描述符，中断发生的时候必须先通过这个门再找到相应处理程序。中断描述符表可以存放在内存中任意位置，CPU中有一个IDTR寄存器来找到其位置（48个字节大小，高32位为基地址，低16位为IDT大小）。</p>

<p>门描述符的类型：</p>

<ol>
  <li>中断门，请求特权级DPL为0，用户不能访问，且访问时需要关中断，避免中断嵌套，所有中断处理程序都由中断门激活，并全部限制在内核态中</li>
  <li>陷阱门，用户不能访问，但访问时不需要关中断</li>
  <li>系统门，用户态进程可以通过系统门进入内核态，从而访问陷阱门</li>
</ol>

<p><strong>IDT表项的设置：</strong>中断描述符表开头的19个陷阱门和系统门，这些中断向量都是被CPU保留用来处理异常的，从32号开始有224个中断门（必须跳过128号向量用于系统调用的向量）</p>

<h3 id="中断处理">中断处理</h3>

<p>在CPU执行下一条指令前需要进行中断检查，看看是否发生了中断或者异常，如果发生了则</p>

<ol>
  <li>确定发生的中断或者异常的向量i</li>
  <li>通过IDTR找到IDT，读取第i项</li>
  <li>进行有效性检查：
    <ul>
      <li>“段”级检查，CPU当前特权级是否比第i项段选择符中描述的特权级大，不允许低特权的进程引起高特权级的中断处理程序</li>
      <li>“门”级检查，CPU当前特权级是否比第i个门的特权级相比，如果小于则CPU不能通过，只针对用户程序，而不包括IO产生的中断或者CPU内部的异常</li>
    </ul>
  </li>
  <li>是否发生了特权级的变化，如果变化了则说明要进行用户态到内核态的堆栈转换</li>
</ol>

<p>实现共享中断线，需要建立<strong>中断请求队列</strong>，在Linux中15条中断线对应15个中断处理程序，此时CPU虽然通过中断门能找到对应的中断处理程序，但是具体的中断服务例程还未进入中断请求队列，因此中断不会被处理</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*中断线共享的数据结构*/</span>
<span class="k">struct</span> <span class="n">irqaction</span><span class="p">{</span>
  <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">;</span>	<span class="c1">//	指向一个具体的中断服务程序</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>		<span class="c1">//	中断线与IO设备的管理，IRQF_SHARED 允许其他设备共享此中断线</span>
  <span class="n">cpumask_t</span> <span class="n">mask</span><span class="p">;</span>					
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>				<span class="c1">//	IO设备名</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">;</span>						<span class="c1">//	主次设备号</span>
  <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>	<span class="c1">//	共享同一中断线的每个硬件对应的中断服务例程</span>
  <span class="kt">int</span> <span class="n">irq</span><span class="p">;</span>
<span class="p">....</span>
<span class="p">}</span>

<span class="cm">/*注册中断服务程序*/</span>
<span class="kt">int</span> <span class="n">request_irq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq</span><span class="p">,</span>
               <span class="n">irq_handler_t</span> <span class="n">handler</span><span class="p">,</span>
               <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">irqflags</span><span class="p">,</span>
               <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">devname</span><span class="p">,</span>
               <span class="kt">void</span> <span class="o">*</span><span class="n">dev_id</span><span class="p">)</span>
  <span class="c1">//	irq				表示要分配的中断号，可以预先设定或者动态探测</span>
  <span class="c1">//	handler		指向处理中断的实际中断服务程序</span>
  <span class="c1">//	irqflags	设置中断线可否共享等信息</span>
  <span class="c1">//	devname		与中断相关的设备的名字</span>
  <span class="c1">//	dev_id		提供唯一的标志信息，以便在删除时能从共享中断线中找到指定的中断服务例程</span>
</code></pre></div></div>

<p>中断服务程序执行时需要关闭中断，因此必须在用来处理最紧迫的事情后就立刻开中断，避免丢失重要的中断，把剩下的事情交由另一部分处理，也就分成了中断服务程序的上下部：</p>

<ul>
  <li>
    <p>中断的上半部处理与设备相关的操作：响应中断请求，读取或发送相关数据，这一部分工作很少</p>
  </li>
  <li>
    <p>中断的下半部处理与程序相关的操作</p>
  </li>
</ul>

<p>中断下半部有两种机制：</p>

<ol>
  <li>小任务机制，把要推迟执行的函数进行组织，<code class="highlighter-rouge">tasklet_struct</code>结构表示一个独立的小任务，小任务不能睡眠，但在运行时能响应中断，推迟要处理的事情由结构中的<code class="highlighter-rouge">tasklet_handler</code>实现，由小任务封装后交给内核处理，在被调度后尽可能尽早执行</li>
  <li>工作队列机制，我们把推后执行的任务称为工作，这些工作以队列结构组成工作队列，而工作者线程（内核线程）就负责执行工作队列中的工作，工作队列机制是允许调度和睡眠的</li>
</ol>

<h3 id="时钟中断">时钟中断</h3>

<blockquote>
  <table>
    <tbody>
      <tr>
        <td>时间硬件分为RTC和OS时钟，RTC为实时时钟，又称CMOS时钟，是PC主板上的一块芯片；OS时钟是操作系统控制的PC主板上的定时</td>
        <td>计数芯片产生的，在开机时，操作系统取得RTC中的时间数据来初始化OS时钟，该定时芯片会不断的发送输出脉冲，并连接到中断控制器上，从而不断触发时钟中断，通过时钟中断来维持OS时钟的正常工作，即加1和细微的修正工作。</td>
      </tr>
    </tbody>
  </table>
</blockquote>

<p>OS时钟和RTC时钟通过BIOS链接，RTC是OS时钟的基准，Linux在内核初始化完成后就会抛弃BIOS</p>

<p>Linux中为了简化RTC时钟到OS时钟的运算，将时间基准设为1970年1月1号凌晨0点，OS时间其实就是一个计数器，记录RTC时间-时间基准的节拍数，系统实际时间Xtime是通过读取RTC来初始化的，jiffies记录从系统启动至今的节拍数</p>

<p>时间中断处理程序</p>

<ol>
  <li>给节拍数jiffies加1</li>
  <li>更新资源消耗的时间，如当前进程所消耗的系统时间和用户时间</li>
  <li>执行到期定时器</li>
  <li>执行调度函数</li>
  <li>根据xtime时间更新墙上时间</li>
  <li>计算平均负载值</li>
</ol>

<h2 id="第六章-系统调用">第六章 系统调用</h2>

<p>系统调用是用户进程进入内核的接口层，它本身并非内核函数，但它是由内核函数实现的，进入内核后，不同的系统调用会找到各自对应的内核函数，这些内核函数被称为系统调用的“服务例程”。</p>

<p>用户在调用系统调用的时候回向内核传递一个系统调用号<code class="highlighter-rouge">__NR_XXX N</code>，然后系统调用处理程序通过这个号从系统调用表中找到相应的内核函数执行。系统调用号是linux系统分配的，分配完成后不能有任何改变。</p>

<p>内核建立一个系统调用表，这个表保存在<code class="highlighter-rouge">sys_call_table</code>数组中，其是一个函数指针数组，每一个函数指针都指向其系统调用的封装例程，有<code class="highlighter-rouge">NR_syscalls</code>个表现，第n个表项包含系统调用号为n的服务例程的地址，但<code class="highlighter-rouge">NR_syscalls</code>只是对可实现的系统调用最大个数进行了限定，并不表示实际已实现的系统调用数。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ENRTY</span><span class="p">(</span><span class="n">sys_call_table</span><span class="p">)</span>
  <span class="p">.</span><span class="kt">long</span> <span class="n">sys_restart_syscall</span>
  <span class="p">.</span><span class="kt">long</span> <span class="n">sys_exit</span>
  <span class="p">.</span><span class="kt">long</span> <span class="n">sys_fork</span>
  <span class="p">.</span><span class="kt">long</span> <span class="n">sys_read</span>
  <span class="p">.</span><span class="kt">long</span> <span class="n">sys_write</span>
  <span class="p">.</span><span class="kt">long</span> <span class="n">sys_open</span>
<span class="p">...</span>
</code></pre></div></div>

<p>应用程序是通过软中断的方式来通知系统的，引发一个异常来促使系统切换到内核态去执行异常处理程序，此时的异常处理程序就是系统调用处理程序。</p>

<p><strong><code class="highlighter-rouge">System_call()</code>函数</strong></p>

<ol>
  <li>首先把系统调用号和异常处理程序可以用到的CPU寄存器都保存到相应的栈中，通过获得内核栈指针的值并把它取整到8KB的倍数而获得当前进程的PCB地址</li>
  <li>对传进来的系统调用号进行检查，如果不小于<code class="highlighter-rouge">NR_syscalls</code>则系统调用处理程序终止</li>
  <li>如果系统调用号无效，则返回用户态，并在EAX中存放一个负的返回值</li>
  <li>最终，根据EAX中包含的系统调用号找到对应的服务例程，因为系统调用表中每一项占4字节，故EAX中的系统调用号左移两位再加上<code class="highlighter-rouge">sys_call_table</code>的基址就可以获取到相对应的服务例程</li>
</ol>

<p>与普通函数的参数通过活动的程序栈传递不同，<strong>系统调用的参数通常是通过寄存器传递给系统调用处理程序的，然后再拷贝到内核堆栈中</strong>，所以参数个数不能超过6个且长度不长于32位，但通常也确实存在超过6个参数的调用，这种情况下，需要用一个单独的寄存器指向进程地址空间中这些参数所在的一个内存区即可</p>

<p>存放系统调用参数所用的6个寄存器分别为<code class="highlighter-rouge">EAX、EBX、ECX、EDX、ESI和EDI</code> <code class="highlighter-rouge">system_call()</code>通过<code class="highlighter-rouge">SAVE_ALL</code>宏将其保存到内核态堆栈中。</p>

<p><strong>封装服务例程</strong></p>

<p>Linux定义了<code class="highlighter-rouge">__syscall0</code>到<code class="highlighter-rouge">__syscall5</code>这六个宏，0~5分别对应参数的个数，严格来说每个宏需要2+2xN个参数，n是系统调用所需的参数（类型和名字）2是系统调用的名字和返回值类型</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">write</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">__NR_write</span> <span class="o">-&gt;</span> <span class="mi">4</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="n">sys_write</span><span class="p">()</span> <span class="o">-&gt;</span>
<span class="n">__syscall3</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="n">write</span><span class="p">,</span><span class="kt">int</span><span class="p">,</span><span class="n">fd</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span><span class="n">buf</span><span class="p">,</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span><span class="n">count</span><span class="p">)</span>
</code></pre></div></div>

<pre><code class="language-assembly">write(write的__syscall3宏展开):
	pushl	%ebx						;	传参
	movl	8(%esp)	,	%ebx
	movl	12(%esp),	%ecx
	movl	16(%esp),	%edx
	movl	$4,	%eax				;	系统调用号
	int		$0x80						;	系统调用中断
	cmpl	$-126,	%eax
	jbe		.L1
	negl	%eax
	movl	%eax,	errno
	movl	$-1,	%eax
.L1:	popl %ebx
	ret
</code></pre>

<h2 id="第七章-内核中的同步">第七章 内核中的同步</h2>

<blockquote>
  <p>​	内核中很多数据都是共享资源，对这些共享资源的访问必须遵循一定的访问规则</p>
</blockquote>

<p>内核中造成并发并发执行的原因简单来说有以下几种：</p>

<ol>
  <li>中断，中断几乎在任何时刻都可异步发生，也就随时打断当前正在执行的代码</li>
  <li>内核抢占</li>
  <li>睡眠</li>
  <li>对称多处理——两个及以上的处理器可以同时执行代码</li>
</ol>

<p>如果在一段内核代码访问某资源的时候产生了一个中断，且该中断也要访问同一资源，这就存在一个“潜在的错误”；如果在一段内核代码访问一个共享资源时可以被抢占，也一样存在一个“潜在的错误”，<strong>辨认出真正需要共享的数据和相应的临界区（操作共享资源的代码段）才很有挑战性。</strong></p>

<h3 id="内核同步措施">内核同步措施</h3>

<p><strong>原子操作：</strong>保证指令以原子的方式执行，如加法指令把读取和增加放在一个执行指令完成，这样并发任务就不会同时访问同一个变量，绝不会引发竞争。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*linux内核提供的atomic_t类型*/</span>
<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
  <span class="kt">int</span> <span class="n">counter</span><span class="p">;</span>
<span class="p">}</span><span class="n">atomic_t</span><span class="p">;</span>
</code></pre></div></div>

<p>相关的专门函数和宏:
| 函数            | 说明                            |
| ————— | ——————————- |
| ATOMIC_INIT(i)  | 声明一个atomic_t变量并初始化为i |
| atomic_read(v)  | 返回 <em>v                         |
| atomic_set(v,i) | 把</em>v置成i                       |
| atomic_add(i,v) | 从<em>v加i                         |
| atomic_sub(i,v) | 从</em>v减i                         |
| ………..     |                                 |</p>

<p><strong>自旋锁：</strong>单处理器可以简单的关中断实现，自旋锁只能被一个内核任务持有，如果一个任务请求已被持有的锁则会一直忙循环，等待锁重新可用，可以有效避免多处理器并发执行的内核任务竞争共享资源，但自旋锁不应被持有过长，要长时间持有最好使用信号量</p>

<p><strong>信号量：</strong>即等待队列和睡眠机制，Linux中有<code class="highlighter-rouge">down()</code>和<code class="highlighter-rouge">up()</code>操作，如果信号量不小于0则获得信号锁，任务就进入临界区了，如果信号量小于0则任务挂入等待队列，信号量会睡眠所以不能再中断上下文中使用，且信号量的数据结构中也用有自旋锁，用于避免多处理器并行的错误</p>

<h2 id="第八章-文件系统">第八章 文件系统</h2>

<p>Linux主要的目录结构(树状结构)</p>

<ul>
  <li>/bin		二进制可执行命令</li>
  <li>/dev     设备特殊文件</li>
  <li>/etc      系统管理和配置文件</li>
  <li>/home  用户主目录基点</li>
  <li>/lib      动态链接共享库</li>
  <li>/sbin   系统管理命令</li>
  <li>/tmp   公用的临时文件</li>
  <li>/root   系统管理员的主目录</li>
  <li>/mnt   临时安装其他文件系统的目录</li>
  <li>/proc  <strong>虚拟目录，是系统内存的映射，可以直接获取系统信息</strong></li>
  <li>/var     某些大文件的溢出区</li>
  <li>/usr     应用程序和文件</li>
</ul>

<h3 id="linux文件系统">linux文件系统</h3>

<ol>
  <li>索引结点：记录文件信息，描述某文件的大小、权限、位置等关键信息，每个文件或者目录都对应一个索引结点，文件系统把所有索引结点形成一个数组，每一个结点的分配的号码就是数组中的索引号</li>
  <li>软连接和硬链接
    <ul>
      <li>硬链接是一个物理位置，多个文件名，<strong>不能是目录，必须同一个文件系统</strong>；</li>
      <li>软连接，即符号链接，存放的内容的指向另一个文件的地址，系统自动把对符号链接的操作变成对源文件的操作</li>
    </ul>
  </li>
  <li>文件系统：Linux 的标准文件系统是Ext2和Ext3，因此==Linux把Ext2文件系统的磁盘分区作为系统的根文件系统==，其他的文件系统都是安装在根文件系统之下</li>
</ol>

<h3 id="虚拟文件系统">虚拟文件系统</h3>

<blockquote>
  <p>虚拟文件系统即VFS（virtual filesystem switch），一种统一的框架用于虚拟文件系统转换</p>
</blockquote>

<p>VFS提供一组标准的、抽象的操作以系统调用的方式给用户使用，如用户使用<code class="highlighter-rouge">read()</code>读取文件时，会调用<code class="highlighter-rouge">sys_read()</code>接着又调用<code class="highlighter-rouge">vfs_read()</code>，文件在内核是由一个<code class="highlighter-rouge">file</code>结构表示的，里面有一个<code class="highlighter-rouge">file_opration</code>结构包含指向各种函数的指针，其是由具体的文件系统自己实现的，从而实现封装操作。</p>

<p>VFS的四个主要对象为:</p>

<ol>
  <li><strong>超级块对象</strong>，是一块包含文件系统信息的数据结构，描述已安装的文件系统</li>
  <li>索引结点对象，文件系统对文件属性的描述，索引号可以唯一的标识文件</li>
  <li><strong>目录项对象</strong>，目录可以层层嵌套形成文件路径，路径中的每一部分都被称为目录项，如有一个路径为<code class="highlighter-rouge">/home/xj/myfile</code>，其中/为根目录，home,xj,myfile都是目录项，是路径的组成部分</li>
  <li><strong>文件对象</strong>，目录属于普通文件，对目录和文件可以实施同样的操作</li>
</ol>

<p>一个超级块对应一个文件系统，系统中可能一类文件系统有多个超级块，所有的超级块对象都以双向循环链表的形式链接在一起，其一起开始是存放于磁盘上，<strong>内核对文件系统进行初始化和注册时会在内存中分配超级块，</strong>而<code class="highlighter-rouge">s_fs_info</code>就指向具体文件系统的超级块，因为经常被操作会放入内存中。</p>

<p>文件名是可以随意修改的，但索引结点对文件是唯一的，随着文件的存在而存在，具体文件系统的索引结点是静态地存放于磁盘上的，要使用前必须先调入内存，填写VFS的索引结点，索引结点中存有指向<code class="highlighter-rouge">file_opration</code>的指针。</p>

<p><strong>目录项对象代表的是逻辑意义上的文件</strong>，在磁盘上没有对应的映像，一个索引结点可能对应多个目录项对象，一个文件系统中所有目录项结构会被组成哈希表或者一棵树、一个链表，从<strong>为文件访问和文件路径搜索提供可能</strong></p>

<h3 id="与进程相关的文件结构">与进程相关的文件结构</h3>

<p>系统通过文件描述符（即==用户打开文件表中构建的文件对象指针的数组索引==）来抽象被进程打开的文件，一个进程可以打开多个文件，一个文件可以被多个进程共享，因此<strong>进程通过用户打开文件表来描述所有打开的文件</strong>，而进程和文件系统的关系通过<code class="highlighter-rouge">fs_struct</code>来描述</p>

<ul>
  <li>
    <p>文件对象，<code class="highlighter-rouge">file</code>结构主要保存了文件位置，通过其<code class="highlighter-rouge">dentry</code>指针间接地<strong>找到该文件的索引结点</strong>，其会形成一个双向链表，称为系统打开文件表，因此每个文件对象会存放在下列的一个双向链表中：</p>

    <ol>
      <li>“未使用”文件对象链表，可以用做文件对面的内存缓冲区</li>
      <li>“正在使用”文件对象链表</li>
    </ol>
  </li>
  <li>
    <p>用户打开文件表<code class="highlighter-rouge">files_struct</code>：是进程的私有数据，其表项指向的是file结构即文件对象</p>
  </li>
  <li>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">fs_struct</span><span class="p">{</span>
  <span class="n">atomic_t</span> <span class="n">count</span><span class="p">;</span>
  <span class="n">rwlock_t</span> <span class="n">lock</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">umask</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span><span class="o">*</span><span class="n">pwd</span><span class="p">,</span><span class="o">*</span><span class="n">alroot</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">rootmnt</span><span class="p">,</span><span class="o">*</span><span class="n">pwdmnt</span><span class="p">,</span><span class="o">*</span><span class="n">alrootmnt</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>打开文件要在进程和文件之间建立一种连接，<strong>“文件描述符”就唯一标识着这种连接</strong>，而文件描述符就指向一个文件的上下文即<code class="highlighter-rouge">file</code>结构，通过目录项找到索引结点，同时要把<strong>索引结点从磁盘中读入到内存</strong>。对文件操作时，就必须<strong>通过索引结点去调用具体文件系统提供的函数</strong>，而基于磁盘的文件系统只需要调用Linux提供的通用函数<code class="highlighter-rouge">generic_file_read()</code>和<code class="highlighter-rouge">generic_file_write()</code>就可以实现相关操作</p>

<h2 id="第九章-设备驱动">第九章 设备驱动</h2>


  <!-- 引入share模块 -->
  
  <div class="social-share-wrapper">
    <div class="social-share"></div>
  </div>


<!-- share.js -->
<script src="/assets/js/social-share.min.js"></script>
<script>
  socialShare('.social-share', {
    sites: [
      
        'qq'
        ,
        
      
        'wechat'
        ,
        
      
        'weibo'
        ,
        
      
        'twitter'
        ,
        
      
        'facebook'
        
      
    ],
    wechatQrcodeTitle: "分享到微信朋友圈",
    wechatQrcodeHelper: '期待在朋友圈见到这篇文章'
  });
</script>

</div>

<!-- 底部锚点 -->
<a id="htmldown" name="htmldown"></a>
<!-- 引入评论模块 -->







  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <section class="post-footer-item comment valine">
    <div id="vcomments"></div>
  </section>
  <script>
      new Valine({
          el: '#vcomments',
          appId: 'nyuCPTrEVDOEOSIzIx3vqxsD-9Nh9j0Va',
          appKey: '25yxQJLkrDqdbicf3FBXtgqE',
          avatar: 'retro',
          emojiCDN: 'https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/'
      })
  </script>


<!-- 引入goto模块 -->
<div class="bounceInRight animated go">
  <a title="顶部切换页面" class="gototop" href="#htmlup" target="_self">
    <div class="box" style="font-family:'ffad_matroregular';">
        Top
    </div>
  </a>
  <a title="底部有评论哦" class="gotobottom" href="#htmldown" target="_self">
    <div class="box" style="font-family:'ffad_matroregular';">
        Foot
    </div>
  </a>
</div>

<!-- 引入页面底部模块 -->
<footer id="bottom">
  <br>
  <span>Hamburger-burgerham :D ©
  
  
  2020
  <br>
  Powered by <a href="https://www.jekyll.com.cn/">Jekyll</a> | <a href="https://github.com/xukimseven/HardCandy-Jekyll">HardCandy-Jekyll</a></span>
</footer>


<!-- 引用wow.js的动画效果 -->
<script src="/assets/js/wow.js"></script>
<script>
    var wow = new WOW({
        boxClass: 'wow',
        animateClass: 'animated',
        // offset: 600,
        mobile: true,
        live: true
    });
    wow.init();
</script>
<!-- 页面刷新回到顶部 -->
<script>
    window.onbeforeunload = function(){
        //刷新后页面自动回到顶部
        document.documentElement.scrollTop = 0;  //ie下
        document.body.scrollTop = 0;  //非ie
    }
</script>
<script src="/assets/js/main.js"></script>
</body>
</html>
