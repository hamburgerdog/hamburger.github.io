<!-- 博文的布局-Layout -->
<!DOCTYPE html>
<html>
<head>
<!-- 引入head标签 -->
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-sclable=0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="description" content="HELLO HAMBUGGER" />
<meta name="keywords" content="hamburger_text" />
<link rel="stylesheet" href="/assets/css/style.css">
<link rel="stylesheet" href="/assets/css/media.css">
<link rel="stylesheet" href="/assets/css/animate.min.css">
<link rel="stylesheet" href="/assets/css/pygments/pygments_default.css">
<link rel="stylesheet" href="/assets/css/github-markdown.css">
<!-- SNS-icon -->
<script src="//at.alicdn.com/t/font_856428_y9z6nq7zf5.js"></script>
<!-- share.css -->
<link rel="stylesheet" href="/assets/css/share.min.css">
<!-- font -->
<link rel="stylesheet" href="/assets/css/font.css">
<!-- <link href="https://fonts.googleapis.com/css?family=Kaushan+Script|Pacifico|Ubuntu|Roboto+Mono|Source+Sans+Pro" rel="stylesheet"> -->

<!-- Favicon -->
<link href="/assets/profile.jpeg" rel="shortcut icon" />
<link href="/assets/profile.jpeg" rel="apple-touch-icon-precomposed" />
<!-- Android Lolipop Theme Color -->
<!-- <meta name="theme-color" content="#1464FB"> -->
<title>sulnteres的主页</title>
<!-- 百度统计 -->

<!-- 谷歌分析 -->


<!-- Android Lolipop Theme Color -->
<meta name="theme-color" content=" rgb(98,170,255) ">
</head>
<body>

<!-- 顶部锚点 -->
<a id="htmlup" name="htmlup"></a>
<!-- 引入博文顶部选项 -->

<header id="post-header" style="background-color:rgb(98,170,255);">
  <div class="top-center">
      <div class="logo">
          <a href="/" title="my awesome webtitle" style="color: white;">xjosiah_page</a>
      </div>
      <nav class="top-nav">
          <ul>
              
                <li><a href="/" style="color: white;">首页</a></li>
              
                <li><a href="/tags.html" style="color: white;">标签</a></li>
              
                <li><a href="/timeline.html" style="color: white;">时间线</a></li>
              
                <li><a href="/about.html" style="color: white;">关于博主</a></li>
              
                <li><a href="/friendLink.html" style="color: white;">友情链接</a></li>
              
          </ul>
      </nav>
      <div id="top-boot">
        <a href="javascript:;" id="boot1" style="display:block;" onclick="document.getElementById('boot-area').style.display='block';document.getElementById('boot1').style.display='none';document.getElementById('boot2').style.display='block';"><img src="/assets/boot_white.png" alt=""></a>
        <a href="javascript:;" id="boot2" style="display: none;" onclick="document.getElementById('boot-area').style.display='none';document.getElementById('boot1').style.display='block';document.getElementById('boot2').style.display='none';"><img src="/assets/boot_white.png" alt=""></a>
      </div>
  </div>

</header>


<!-- 引入移动下拉选项 -->
<div id="boot-area">
    <ul>
        
          <a href="/"><li>首页</li></a>
        
          <a href="/tags.html"><li>标签</li></a>
        
          <a href="/timeline.html"><li>时间线</li></a>
        
          <a href="/about.html"><li>关于博主</li></a>
        
          <a href="/friendLink.html"><li>友情链接</li></a>
        
    </ul>
</div>

<!-- 引入博文顶部样式 -->
<!-- 版本一 垃圾 -->
<!-- <div class="wow fadeIn top" data-wow-duration="3.5s" >
    <span class="wow fadeInUp" data-wow-delay="0.2s">技术栈总结</span>
    <span class="wow fadeInUp" data-wow-delay="0.4s"></span>
    <span class="wow fadeInUp" data-wow-delay="0.4s"></span>
    <span class="wow fadeInUp" data-wow-delay="0.6s">作者&nbsp;&nbsp;|&nbsp;&nbsp;true</span>
</div> -->

<!-- 版本二 可切换页面 -->

<div class="post-top" style="background-color:rgb(98,170,255);">
  <!-- 页面宽度大于800px -->
  <div class="left-area">
    
      <a href="/2020/07/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html" class="btn bounceInLeft animated" onmouseover="showLeft();this.style.color='rgb(98,170,255)';" onmouseout="goneLeft();this.style.color='rgba(0,0,0,.2)';"><</a>
      <div id="left-tab" style="display:none;"><span class="left-san"></span><span class="left-main" style="color:rgb(98,170,255);"><sapn class="main">操作系统原理</sapn></span></div>
    
  </div>
  <div class="post-titlearea">
    <span class="wow fadeInUp" data-wow-delay="0.2s">技术栈总结</span>
    <!-- <span class="wow fadeInUp" data-wow-delay="0.4s"></span> -->
    <!-- <span class="wow fadeInUp" data-wow-delay="0.4s"></span> -->
    <!-- <span class="wow fadeInUp" data-wow-delay="0.6s">作者&nbsp;&nbsp;|&nbsp;&nbsp;true</span> -->
  </div>
  <div class="right-area">
    
      <a href="javascript:;" class="btn bounceInRight self-animated" onmouseover="showRight();this.style.color='rgb(98,170,255)';" onmouseout="goneRight();this.style.color='rgba(0,0,0,.2)';">></a>
      <div id="right-tab" style="display:none;"><span class="right-san"></span><span class="right-main" style="color:rgb(98,170,255);"><sapn class="main">没有下一页咯</sapn></span></div>
    
  </div>

  <!-- 页面宽度小于800px -->
  <div class="post-changearea">
    
      <a href="/2020/07/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html" class="leftchange" style="border-right: 1px solid rgb(98,170,255);border-bottom: 2px solid rgb(98,170,255);"><span>上一篇<br><br>操作系统原理</span></a>
    
    
      <a href="javascript:;" class="rightchange" style="border-left: 1px solid rgb(98,170,255);border-bottom: 2px solid rgb(98,170,255);"><span><br>没有下一篇咯</span></a>
    
  </div>
</div>


<div class="markdown-body fadeInUp animated">

  
    
      <div class="postpage-subtitle" style="border-left: 8px solid rgb(98,170,255); border-right: 8px solid rgb(98,170,255)">
        一个拖拖拉拉的菜鸡总结-希望能经常加更
      </div>
    
  

  <!-- 文章内容 -->
  <h1 id="技术栈">技术栈</h1>

<h2 id="待完善">待完善</h2>

<h3 id="底层">底层</h3>

<ol>
  <li>操作系统：了解内核、了进程和文件管理等重要的概念和实现方式</li>
  <li>编译原理：粗略搞懂编译器的执行过程（汇编√-机器码×）</li>
  <li>计算机网络：彻底搞懂连网原理和TCP/IP的具体意义，打通网络黑箱</li>
  <li>JVM：这个底层其实还挺好奇的，目前处于黑箱状态</li>
  <li>Tomcat：热部署怎么使用的，大概了解原理</li>
  <li>数据库高级：索引概念、视图概念、底层逻辑都不清楚其实。</li>
</ol>

<h3 id="应用类">应用类</h3>

<ol>
  <li>
    <p>Vue.js：其实很好奇怎么用MVVM模式来进一步优化界面层啊？！借此完善自己的第一个项目，</p>
  </li>
  <li>
    <p>SpringBoot框架：如何实现前后端数据传输啊？？？</p>

    <p><strong>现在已知的是三层架构模式:</strong></p>

    <p><strong>界面层 JSP(EL+JSTL) + JQuery + Ajax</strong></p>

    <p><strong>业务逻辑层Web (Servlet+Filter)</strong></p>

    <p><strong>数据访问层（Druied链接池+ JDBCUtils）DAO模式</strong></p>
  </li>
  <li>
    <p>Javaweb注解配置（及时补充）</p>
  </li>
</ol>

<h2 id="深入">深入</h2>

<h3 id="底层---汇编王爽汇编语言第三版">底层 - 汇编：（王爽《汇编语言第三版》）</h3>

<h5 id="37-cpu提供的栈机制">3.7 CPU提供的栈机制</h5>

<p>入栈和出栈都是以字为单位，通过 <strong>SS段寄存器：SP寄存器 来指向栈顶元素</strong></p>

<p>栈是从高地址往低地址增长的，这同时解决了“<strong>CPU如何知道此段内存空间是栈</strong>“的问题，当SP寄存器 负增长的底线是0000h，故定义起始地址后栈大小也随之确定。但CPU是不会保证我们对栈的操作不会越界的，POP和PUSH的过程中有可能会产生溢出</p>

<p>当栈为空时 <strong>SS：SP 指向栈空间最高地址单元的下一个单元</strong></p>

<blockquote>
  <p>​	我们当然希望CPU可以帮我们解决这个问题，比如说在CPU中有记录栈顶上限和栈
底的寄存器，我们可以通过填写这些寄存器来指定栈空间的范围，然后，CPU在执行
push指令的时候靠检测栈顶上限寄存器、在执行pop指令的时候靠检测栈底寄存器保证不
会超界。
​	不过，对于8086CPU,这只是我们的一个设想(我们当然可以这样设想，如果CPU是
我们设计的话，这也就不仅仅是一个设想)。实际的情况是，8086CPU 中并没有这样的寄
存器。
​	8086CPU不保证我们对栈的操作不会超界。这也就是说，8086CPU 只知道栈顶在何
处(由SS:SP指示)，而不知道我们安排的栈空间有多大。这点就好像CPU只知道当前要执
行的指令在何处(由CS:IP指示),而不知道要执行的指令有多少。从这两点上我们可以看
出8086CPU的工作机理，它只考虑当前的情况:当前的栈顶在何处、当前要执行的指令
是哪一条。
​	我们在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安
排栈的大小，防止入栈的数据太多而导致的超界;执行出栈操作的时候也要注意，以防栈
空的时候继续出栈而导致的超界。</p>
</blockquote>

<h3 id="应用层---javaweb_filter--ajax--json">应用层 - JavaWeb_Filter &amp; Ajax &amp; JSON</h3>

<ul>
  <li>
    <p><strong>Json 一种轻量化的通用数据传输格式，轻量化是与XML对比，JSON更小、更快、更易解析。</strong></p>

    <p>有两种表示方法 JSON对象 和 JSON字符串 用parse() stringify() 互相转化</p>

    <p>采用键值对方式存放 可以放 number、String、数组、JSON对象</p>

    <p>语法是花括号 {} 加 key:values 用 逗号，分隔</p>

    <p>在 Java 调用时可以选择导 GSON（谷歌） 或者 阿里（推荐阿里 没有太多依赖） 的jar包</p>
  </li>
  <li>
    <p><strong>Ajax ：Asynchronous JavaScript and XML. （异步的js和xml）是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</strong></p>

    <p>同步：在提交表单后必须等待服务器返回才可以继续处理数据（造成页面卡死待响应的现象，体验差）</p>

    <p>异步：在提交表单后无须等待，服务器处理完成后会自动返回</p>

    <p>Ajax在JQuery中有封装完成的使用方法，JSP页面中应用较多</p>
  </li>
  <li>
    <p><strong>Filter：JavaWeb的三大组件之一 用于过滤请求</strong> 可以用于用户权限的管理</p>

    <p>FilterChain 过滤器链（多个过滤器一起工作）如果通过XML配置，则先配置的先调用</p>

    <p>FilterChain.doFilter() - 执行过滤操作 如果有下一个过滤器则进入 否则执行后置代码</p>

    <p>FilterConfig类 可以获取在XML文件中的配置信息</p>

    <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;init-param&gt;</span>
<span class="nt">&lt;param-name&gt;&lt;/param-name&gt;</span>
<span class="nt">&lt;param-value&gt;&lt;/param-value&gt;</span>
<span class="nt">&lt;/init-param&gt;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h1 id="时间线">时间线</h1>

<h2 id="五月">五月</h2>

<h3 id="12---json--ajax---javaweb_filter">12 - JSON &amp; Ajax &amp;  Javaweb_Filter</h3>

<ul>
  <li>
    <p><strong>Json 一种轻量化的通用数据传输格式，轻量化是与XML对比，JSON更小、更快、更易解析。</strong></p>

    <p>有两种表示方法 JSON对象 和 JSON字符串 用parse() stringify() 互相转化</p>

    <p>采用键值对方式存放 可以放 number、String、数组、JSON对象</p>

    <p>语法是花括号 {} 加 key:values 用 逗号，分隔</p>

    <p>在 Java 调用时可以选择导 GSON（谷歌） 或者 阿里（推荐阿里 没有太多依赖） 的jar包</p>
  </li>
  <li>
    <p><strong>Ajax ：Asynchronous JavaScript and XML. （异步的js和xml）是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。</strong></p>

    <p>同步：在提交表单后必须等待服务器返回才可以继续处理数据（造成页面卡死待响应的现象，体验差）</p>

    <p>异步：在提交表单后无须等待，服务器处理完成后会自动返回</p>

    <p>Ajax在JQuery中有封装完成的使用方法，JSP页面中应用较多</p>
  </li>
  <li>
    <p><strong>Filter：JavaWeb的三大组件之一 用于过滤请求</strong> 可以用于用户权限的管理</p>

    <p>FilterChain 过滤器链（多个过滤器一起工作）如果通过XML配置，则先配置的先调用</p>

    <p>FilterChain.doFilter() - 执行过滤操作 如果有下一个过滤器则进入 否则执行后置代码</p>

    <p>FilterConfig类 可以获取在XML文件中的配置信息</p>

    <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;init-param&gt;</span>
<span class="nt">&lt;param-name&gt;&lt;/param-name&gt;</span>
<span class="nt">&lt;param-value&gt;&lt;/param-value&gt;</span>
<span class="nt">&lt;/init-param&gt;</span>
</code></pre></div>    </div>
  </li>
</ul>

<h3 id="13---汇编语言--操作系统">13 - 汇编语言 &amp;&amp; 操作系统</h3>

<p>​	重温了汇编的寄存器部分，预计两天内看完</p>

<p>​	操作系统看了Linux 0.11内核的系统启动过程，bochs真难用</p>

<p>### 14 - 汇编语言</p>

<p>loop指令：两步操作 1.（cx）=（cx）-1   2.判断 cx 是否为零。在debug中用 g + [偏移地址]可以一次性执行所有loop</p>

<blockquote>
  <p>Debug 将它解释为“[idata]” 是-一个内存单元，idata是内存单元的偏移地址;
而编译器将“[idata]” 解释为 idata 。</p>
</blockquote>

<p>在汇编源程序中，数据不能以字母开头，所以要在前面加 0
直接写内存的话应当<strong>使用0:200~0:2ff 这段空间</strong> dos和其他合法程序通常不会使用这段空间。</p>

<blockquote>
  <p>程序中的指令就要对这8个数据进行累加，这8个数据在代码段中，程序在运行的时候CS中存放代码段的段地址，所以可以从CS中得到它们的段地址。它们的偏移地址是多少呢?因为用dw定义的数据处于代码段的最开始，所以偏移地址为0，<strong>这8个数据就在代码段的偏移0、2、4、6、8、A、C、E处。</strong>程序运行时，它<strong>们的地址就是CS:0、CS:2、 CS:4、CS:6、CS:8、CS:A、 CS:C、 CS:E。</strong>
…………
dw段的数据的值是多少，对于程序来说没有意义。我们定义这些数据的最终目的是，通过它们获取一定容量的内存空间，所以我们在描述dw的作用时，可以说用它定义数据，也可以说用它开辟内存空间。</p>
</blockquote>

<p><strong>一般在需要暂存数据的时候，我们都应该使用栈</strong></p>

<p>在8086CPU中只有bx si di bp 这4个寄存器可以用于内存单元寻址，这4个寄存器可以单个出现，或者以4种组合出现： bx+si , bx+di , bp+si , bp+di (ds:bx  ss:bp)
CPU提供的如[bx+si+idata]的寻址方式为结构化处理提供了方便，用 bx 定位整个结构体，idata定位结构体中的某一个数据项，si 定位数组项中的每个元素。可以写成bx.idata[si]。</p>

<h3 id="15---汇编语言">15 - 汇编语言</h3>

<p>jmp指令经典例题：
<img src="https://s1.ax1x.com/2020/05/15/Yrs7Y6.png" alt="Yrs7Y6.png" /></p>

<p>flag 寄存器：
<img src="https://s1.ax1x.com/2020/05/15/YsSYSP.png" alt="YsSYSP.png" /></p>

<blockquote>
  <p>CPU提供了cmp 指令，也提供了je等条件转移指令，如果将它们配合使用，可以实
现根据比较结果进行转移的功能。但这只是“如果”，只是一种合理的建议，和事实上常
用的方法。但究竟是否配合使用它们，完全是你自己的事情。这就好像call 和ret 指令的
关系一样。
<img src="https://s1.ax1x.com/2020/05/15/YsAvWQ.png" alt="YsAvWQ.png" /></p>
</blockquote>

<p>8086在内存 0000:0000 到 0000:03FF 的1024个单元中存放着中断向量表</p>

<h3 id="18---操作系统----系统调用">18 - 操作系统  - 系统调用</h3>

<p><strong>内核态和用户态：</strong>一种处理器 “硬件设计”， DPL目标段的特权级、CPL当前段的特权级
当前程序执行在什么态用CS的最低两位来表示：0是内核态，3是用户态 数字越小级别越高
计算机对CPU是一段一段地使用，故我们可以用段寄存器来判断特权级 
而GDT表中的表项用来描述一段内存，<strong>在操作系统段中所有的DPL在GDT中都对应内核态</strong>
当前用户使用时，根据PC（内存段）中的CS段我们可以知道当前用户的CPL，故可以判断权限</p>

<blockquote>
  <p>GDT/LDT表中的描述符，描述的是一段内存。其中的DPL代表着GDT/LDT中的描述符描述的内存段的特权级别。比如，当前正在执行的代码，它的特权级别就是当前的CS段选择子指向的段描述符中的DPL所决定的。即DPL是描述<strong>一段内存</strong>的特权级别。</p>
</blockquote>

<p><strong>系统调用的核心：</strong></p>

<ul>
  <li>用户程序中包含一段有中断指令（必须是 <code class="highlighter-rouge">INT 0x80</code>）和系统调用号（<code class="highlighter-rouge">INT system_call</code>）的代码</li>
  <li>操作系统写中断处理，获取调取程序的编号</li>
  <li>操作系统根据编号执行相应的代码</li>
</ul>

<p><strong>中断处理-用户态转化成内核态最终调用内核方法</strong>
硬件提供了 INT 0x80 中断能让我们主动进入内核，最重要的就是 set_system_gate 设置中断陷阱门
set_system_gate 的参数为 <code class="highlighter-rouge">INT 0x80</code>80中断和<code class="highlighter-rouge">INT system_call</code>表示要调用是方法，此时的DPL为3；
通过转化后进入到内核态，设置PC，其中CS为8（100）故可得CPL为0内核态，而IP为 <code class="highlighter-rouge">system_call</code>
通过查system_call_table 得到 _NR_XXX 最终调用 sys_XXX</p>

<p><strong>调用的具体过程：</strong>
用户调用XXX方法 :point_right: 通过库函数展开成宏，调用中断 :point_right: 中断处理system_call  :point_right: 查sys_call_table  	  						:point_right: 得到</p>

<h3 id="19---操作系统---进程管理cpu部分">19 - 操作系统 - 进程管理（CPU部分）</h3>

<p><strong>CPU使用的关键是：取值执行</strong> 设置完PC后便自动开始工作，但这样顺序执行有很多缺点：但程序需要调用IO设备或者磁盘时，会等待很久从而造成时间上的浪费，于是我们需要让CPU交替执行多个程序</p>

<p>一个CPU上交替执行多个程序称为：<strong>并发</strong>，在交替执行的时候为了完成切换需要保存寄存器等程序信息，从而引入<strong>进程</strong>（进行中的程序）的概念，CPU在运行多个程序时跑多个进程，因此CPU运行的效率得到大大提升</p>

<p><strong>多进程图像：</strong>
CPU用 PCB（Process Control Block 记录进程信息的数据结构）
进程带动内存的使用需要用映射表（MMU）进行内存封存 - 同一地址指向不同物理地址 - 为了共存；</p>

<p><strong>多线程：</strong>- TCB 线程控制表
<strong>线程有自己的TCB，thread control block, 只负责这条流程的信息</strong>，包括PC程序计数器，SP堆栈，State状态，和寄存器。有不同的控制流，需要不同的寄存器来表示控制流的执行状态，每个线程有独立的这些信息，但共享一个资源。</p>

<p><strong>多核：线程-用户栈和内核栈-进程切换</strong>
每个线程对应一套栈，用户栈和内核栈
用户栈进入内核栈：系统调用（fork()）会引起中断并且创建一个进程，有两个重点：
<strong>1.一个线程是怎么通过进程切换的 2.创建一个进程需要做哪些准备</strong>
线程切换五段论：中断入口，建立用户栈和内核栈的联系:point_right: 进入内核态执行，执行完毕过程中或者执行完毕后，系统会判断事件有可能引发切换（中间三段）:point_right: 中断返回 ret_from_sys_call</p>

<ul>
  <li><strong>在A处</strong>调用 fork() 时会产生 INT 0x80中断和 _NR_fork 同时CPU立刻把用户态的相关信息压入内核栈</li>
  <li>call sys_fork 根据PCB中的state判断进程状态是<strong>就绪</strong>还是<strong>阻塞</strong>，<strong>非0则阻塞</strong>，阻塞需要调度切换  <code class="highlighter-rouge">reschedule{ jmp _schedule } </code>；然后需要判断进程时间片再一次<code class="highlighter-rouge">reschedule</code>；最后返回中断。</li>
  <li><code class="highlighter-rouge">_schedule{ switch_to(next) } </code>中具体实现调度和切换 ：next=XXX 下一个进程XXX（用调度算法找到下一个已经就绪的进程），switch_to（切换将PC跳到下一个进程XXX中执行）</li>
  <li><strong><code class="highlighter-rouge">switch_to</code></strong>通过TSS（task state segment 任务段）进行段跳转切换，首先用<strong>TR寄存器</strong>作为选择子在GDT表中找到TSS描述符，从而找到TSS的段地址，把CPU中的EAX、EBX等寄存器的相关信息保存在原TSS段中（相当于存档）；同理找到下一个进程的TSS段地址赋给TR，将该TSS中的信息拷贝到CPU中（相当于读档），完成跳转。此时下一个进程是我们创建的子进程</li>
  <li>中断返回 <code class="highlighter-rouge">ret_from_sys_call</code>：先popl 用户态中的信息 最后 iret</li>
</ul>

<p><strong>创建进程的任务就开始了 ThreadCreate：</strong></p>

<ul>
  <li>
    <p>要创建下一个进程中的TSS需要用到 <code class="highlighter-rouge">sys_fork { call _copy_process }</code> 此时内核栈中的信息全部作为 _copy_process 的参数从而创建出差不多完全一样的子进程</p>
  </li>
  <li>
    <p>copy_process 细节：创建栈</p>

    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">)</span><span class="n">get_free_page</span><span class="p">();</span><span class="c1">//申请内存空间</span>
<span class="c1">//创建内核栈</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">esp0</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">+</span> <span class="p">(</span><span class="kt">long</span><span class="p">)</span> <span class="n">p</span> <span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">ss0</span> <span class="o">=</span> <span class="mh">0x10</span><span class="p">;</span> 
<span class="c1">//创建用户栈(和父进程共用的栈 ss和esp 是由父进程中用户栈中传入的)</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">ss</span> <span class="o">=</span> <span class="n">ss</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
<span class="n">p</span><span class="o">-&gt;</span><span class="n">tss</span><span class="p">.</span><span class="n">esp</span> <span class="o">=</span> <span class="n">esp</span><span class="p">;</span> 
</code></pre></div>    </div>
  </li>
  <li>
    <p>具体过程是：switch_to(next=子进程) 创建子进程同时设置好TSS并且和TCB相连，上面是创建子进程的具体过程</p>
  </li>
</ul>

<p><strong>执行我们想要的代码：</strong></p>

<ul>
  <li>我们创建的子进程随着中断返回到A处，而此时不会和父进程一样的执行fork() 而是 call sys_execve 从而执行我们所要执行的操作</li>
  <li>要找到真正的PC，我们需要在中断返回前将当前得到的IP 压入到 用户栈中的 EIP 从而真正的赋值给IP寄存器，得到PC从而执行</li>
  <li>获取当前 IP 要根据 <code class="highlighter-rouge">ls -&gt; entry (call do_entry ) </code>获得</li>
  <li><code class="highlighter-rouge">do_entry { eip[0] = ex. a_entry }; </code>a_entry 代表的就是编译器在编译链接产生ls.exe时编译器提供的入口： unsigned a_entry，而 ls文件实际存在于磁盘之中</li>
</ul>

<h3 id="20---操作系统---调度算法---进程合作">20 - 操作系统 - 调度算法 - 进程合作</h3>

<h4 id="调度算法----io约束型和cpu约束型"><strong>调度算法</strong> -  IO约束型和CPU约束型</h4>
<p><strong>IO约束型：</strong>通常优先级会比较高，提前调用IO可以让设备先处理，CPU可以并发执行，等待设备处理完后CPU读数据就行 此时是 read 中断，对应的通常是前台进程（用户进程）
<strong>CPU约束型：</strong>用的 TimeOut 中断，对应的通常是后台进程</p>

<p>一个好的调度算法（<code class="highlighter-rouge">Schedule（）</code>）应该折中、会自适应、能自动分辨前后台进程、以RR（轮转调度算法）为核心、有优先级。具体实现方式是：</p>
<ul>
  <li>首先找到就绪队列中<strong>优先级最大</strong>的一个进程（用COUNT时间片表示，越大优先级越高）</li>
  <li>然后当该进程的时间片为0时，<strong>重新设置所有进程的COUNT</strong>（右移一位+初始时间片长度），让处于拥塞状态的进程的优先级比当前进程优先级高，等待就绪后可以被CPU调用</li>
  <li>动态调整COUNT同时也意味着此时调度会从CPU约束转成IO约束，而IO约束对应的是前台进程的特征，于是分辨出前后台进程。原理是拥塞状态下的进程大部分都是前台进程（需要调用IO）在调整后优先级高，阻塞越久优先级越高，但<strong>COUNT不会无限增长破坏RR算法</strong></li>
  <li>这和COUNT的重置算法有关：$c(n)=c(n-1)/2+P$ 其中 $ c(0)= P$  于<strong>最终收敛于2P</strong> 不会无限大符合时间片的规则</li>
  <li>后台进程一直循环可以近似看出是SJF调度，符合CPU约束型</li>
</ul>

<h4 id="进程合作---多个进程共同完成一个任务---信号量"><strong>进程合作</strong> - 多个进程共同完成一个任务 - 信号量</h4>

<p>COUNT信号已经无法简单处理了多个进程等待和资源生产复杂情况了，需要一个信号量来实现“走走停停”，信号量里有value（资源的个数）和PCB阻塞队列（等待在该信号量上的进程），信号量中P操作是消费资源，V操作是生产资源。</p>

<p>信号量解生产者-消费者问题：
生产者第一步P(empty)需要判断资源是否满了，满了则不能再生产了，empty= 0 表示缓冲区满了，消费者的第一步P(full)则是判断当前已经生产的个数，为零则无法消费，full 表示已经生产的个数；第二步两者都是上锁P(mutex)，然后分别执行读入写出，最后解锁V(mutex)；生产者第三步是V(full) 代表生产了一些资源，而消费者是V(empty) 消耗了一些资源</p>

<p>信号量需要临界区来保护，因为信号量是所以进程共享的。
临界区保护原则：</p>

<ul>
  <li>基本原则：互斥进入，进程间的互斥关系保证了是临界区</li>
  <li>好的保护原则：有空让进和有限等待</li>
</ul>

<p>信号量的具体实现过程：面包算法、关中断方法、原子指令上锁法
在内核中为用于一个数组存放信号量，再建立队列用于存放PCB，因为是全局数据所以要写在内核中，用的时候必须使用系统调用队列中对应的信号量</p>

<p>死锁处理：PC机通常使用死锁忽略</p>

<h3 id="21---操作系统---内存管理">21 - 操作系统 - 内存管理</h3>

<h4 id="内存使用和分段">内存使用和分段：</h4>
<p>要从逻辑地址转化成物理地址用<strong>运行时重定位</strong>最合适，利用的基址放在PCB中，执行指令时第一步就是从PCB(特殊数据结构，其中包含了<strong>GDT</strong>和<strong>LDT</strong>)中取出基地址</p>

<p>由于程序是分段的code segment | data segment …. 方便管理而且在载入时节约资源，所以在存放基地址时还需要按段号分段存放到DS中，形成进程段表。
操作系统的段表就是<strong>GDT</strong>，子进程的段表是<strong>LDT</strong>（LDT可以看成是GDT分配的）</p>

<p>地址翻译的具体实现过程是：首先找到本段的程序段号，然后在LDT表中的找到对应的基地址，完成重定位过程，段号存放在 ldtr 中</p>

<h4 id="内存分页"><strong>内存分页</strong>：</h4>

<p>分区是为了能找到空闲的内存区并管理内存，这样在进程载入的时候才找得到空闲内存区，分段分区都是针对的虚拟内存。但分区会产生很多碎片，因此我们<strong>采用分页</strong>。</p>

<p>一个程序有很多段，一个段又对应很多页
用页表实现分页，页表起始地址放在 cr3 通过 MMU 得到页号，页号找到页框号，最后将页框号和逻辑地址相连，页框规定了页的大小，页表存放在PCB中，每个进程都有自己的页表</p>

<h4 id="段页内存同时存在">段页内存同时存在：</h4>
<p>程序用段-虚拟内存-虚拟内存分页-映射到物理内存
段页同时存在时的重定位（地址翻译）：
段依旧按段表找出基地址加上段偏移得到虚拟地址-再从虚拟地址映射到页表找到页号，利用页号和偏移地址得到物理地址，两层地址翻译：段号到虚拟地址、页号到物理地址</p>

<h1 id="备忘录">备忘录</h1>

<h1 id="随记">随记</h1>

<h2 id="5142020-解题的思考">5/14/2020 解题的思考</h2>

<p>在解题之前先思考题目考察的内容，不要盲目地做题。先想一想、写一下文档理清思路。
<img src="https://s1.ax1x.com/2020/05/14/YDcluQ.png" alt="YDcluQ.png" /></p>

<p>如这一道题目要求将指令复制到另一个地方，解题时首先就应该想到在哪个内存地址可以找到要复制的数据，在8086中CS.dreg 指向的就是程序地址，而 di 中存放着 s 标号的地址，此时 CS:DI 就可以找到 S标号对应的程序地址了，同理便可得目的地址。有了地址就可以考虑如何复制数据，很明显通过 mov指令和寄存器就轻松完成了复制。</p>

<p>思考的关键就在于如何能快速地利用已经学过的知识来解析问题，<strong>用什么方法，需要找到什么数据（或者地址）</strong></p>

<h2 id="5152020-合理计划学习任务">5/15/2020 合理计划学习任务</h2>

<p>今天学习进度没有赶得很紧，大学课程的实验让我十分的烦恼。最近只想赶快把汇编看完然后去学OS，自知学知识不能太赶，要一步一个脚印地来，但今天还是跳了很多个实验，寄希望于学完OS后再回头把实验写了，只看重理论很不好，打不下基础，我决定分批次完成实验的内容，明天把理论知识学完，然后分批完成汇编的实验和课程的实验（又把学习当任务了！！其实应该把<strong>学习时间拉长，每天只学一点但一定要完全领悟通透</strong>，只怪我脑子太笨，如今只能争取理论尽快地领悟，实验只能后补了。）唉，如果大学的课程能不那么赶而且还不要考试就好了。</p>

<p>有个妹妹自杀了，她的遗书写得十分平静，她所有牵挂的人和事都已经放下了，信中看不出她的绝望和痛苦，好像死亡对她来说只是一件很平常的事，她说她已经去了自己想要的很美好的地方， 突然间我开始相信我们都拥有灵魂了，相信她只是选择了另一种方式存在，愿超脱了肉体的你能永远徜徉在极乐天堂 R.I,P</p>


  <!-- 引入share模块 -->
  
  <div class="social-share-wrapper">
    <div class="social-share"></div>
  </div>


<!-- share.js -->
<script src="/assets/js/social-share.min.js"></script>
<script>
  socialShare('.social-share', {
    sites: [
      
        'qq'
        ,
        
      
        'wechat'
        ,
        
      
        'weibo'
        ,
        
      
        'twitter'
        ,
        
      
        'facebook'
        
      
    ],
    wechatQrcodeTitle: "分享到微信朋友圈",
    wechatQrcodeHelper: '期待在朋友圈见到这篇文章'
  });
</script>

</div>

<!-- 底部锚点 -->
<a id="htmldown" name="htmldown"></a>
<!-- 引入评论模块 -->







  <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
  <section class="post-footer-item comment valine">
    <div id="vcomments"></div>
  </section>
  <script>
      new Valine({
          el: '#vcomments',
          appId: 'nyuCPTrEVDOEOSIzIx3vqxsD-9Nh9j0Va',
          appKey: '25yxQJLkrDqdbicf3FBXtgqE',
          avatar: 'retro',
          emojiCDN: 'https://img.t.sinajs.cn/t4/appstyle/expression/ext/normal/'
      })
  </script>


<!-- 引入goto模块 -->
<div class="bounceInRight animated go">
  <a title="顶部切换页面" class="gototop" href="#htmlup" target="_self">
    <div class="box" style="font-family:'ffad_matroregular';">
        Top
    </div>
  </a>
  <a title="底部有评论哦" class="gotobottom" href="#htmldown" target="_self">
    <div class="box" style="font-family:'ffad_matroregular';">
        Foot
    </div>
  </a>
</div>

<!-- 引入页面底部模块 -->
<footer id="bottom">
  <br>
  <span>Hamburger-burgerham :D ©
  
  
  2020
  <br>
  Powered by <a href="https://www.jekyll.com.cn/">Jekyll</a> | <a href="https://github.com/xukimseven/HardCandy-Jekyll">HardCandy-Jekyll</a></span>
</footer>


<!-- 引用wow.js的动画效果 -->
<script src="/assets/js/wow.js"></script>
<script>
    var wow = new WOW({
        boxClass: 'wow',
        animateClass: 'animated',
        // offset: 600,
        mobile: true,
        live: true
    });
    wow.init();
</script>
<!-- 页面刷新回到顶部 -->
<script>
    window.onbeforeunload = function(){
        //刷新后页面自动回到顶部
        document.documentElement.scrollTop = 0;  //ie下
        document.body.scrollTop = 0;  //非ie
    }
</script>
<script src="/assets/js/main.js"></script>
</body>
</html>
