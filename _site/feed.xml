<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.7">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-11-15T11:14:50+08:00</updated><id>http://localhost:4000/</id><title type="html">Hamburger-burgerham :D</title><subtitle>HELLO HAMBUGGER</subtitle><author><name>true</name></author><entry><title type="html">疫情对软件开发的工作模式的影响</title><link href="http://localhost:4000/2020/11/14/Final_Assignment_for_Software_Engineering.html" rel="alternate" type="text/html" title="疫情对软件开发的工作模式的影响" /><published>2020-11-14T12:00:00+08:00</published><updated>2020-11-14T12:00:00+08:00</updated><id>http://localhost:4000/2020/11/14/Final_Assignment_for_Software_Engineering</id><content type="html" xml:base="http://localhost:4000/2020/11/14/Final_Assignment_for_Software_Engineering.html">&lt;h1 id=&quot;浅析-疫情对软件开发的工作模式的影响&quot;&gt;浅析-疫情对软件开发的工作模式的影响&lt;/h1&gt;

&lt;h2 id=&quot;作者&quot;&gt;作者&lt;/h2&gt;

&lt;p&gt;网络工程	xjosiah&lt;/p&gt;

&lt;h2 id=&quot;摘要&quot;&gt;摘要&lt;/h2&gt;

&lt;p&gt;本篇文章通过对两个互联网软件公司Twitter和Gitlab在疫情期间的远程开发模型进行浅析，讨论了远程开发模型的前景，以及疫情对软件开发的工作模式产生了何种影响，并为如何减轻新冠疫情对公司运营的冲击和如何使软件开发人员能尽快适应远程办公模式提供了一些资料参考。&lt;/p&gt;

&lt;h3 id=&quot;关键词&quot;&gt;关键词&lt;/h3&gt;

&lt;p&gt;新冠疫情下	软件开发	异地办公	家庭工作模型	远程工作模式	地理分离式公司	互联网行业&lt;/p&gt;

&lt;h2 id=&quot;引言&quot;&gt;引言&lt;/h2&gt;

&lt;p&gt;新冠病毒是一场全人类的战役，它的肆虐给我们人类带来了的一场重大健康危机，同时也深刻地影响了我们人类的生活，特别是在还看不到疫情平息曙光的当下，我们更应该做好打持久战的准备，这意味着我们的生产方式、生活习惯和观念要都要因此做出相应的改变。本篇文章将通过浅析著名社交网站Twitter在疫情横行的当下实现让员工“居家办公”的例子，并结合疫情下其他的一些流行的开源项目如Gitlab的远程开发经验来简明分析疫情对软件开发方式产生了哪些的影响，从这些改变中积累一些能为我们所用的知识，如怎样更好地利用互联网来协作开发、如何更有效地进行团队沟通等，使得我们能尽可能平稳地度过疫情给我们带来的冲击。&lt;/p&gt;

&lt;h2 id=&quot;正文&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;新冠疫情来势汹汹，而预防疫情最好的方式之一是带口罩和尽量避免人群聚集，但在传统的工作模式下，办公室就俨然变成了一个孕育疫情的温床：人群密集、流通性不好、人和人之间面对面地沟通十分频繁。因此一种被称为家庭工作（work from home model）的模式也就应运而生了，而著名的互联网社交软件公司Twitter就是在疫情发生后最早应用这种工作模式的公司之一，并且其宣布他们不会成为最早重新返回传统办公室工作模式的公司之一。&lt;/p&gt;

&lt;p&gt;家庭工作模式，顾名思义其最大的特点就是在一定的安全控制下，利用互联网技术提供一个虚拟的工作场所，允许员工在远程接受管理并进行相关项目的工作，在疫情下，这种工作方式可以能最大程度地保障员工的生命健康，并且能继续维持公司的正常运转，这将为员工和企业带来巨大的优势，家庭工作模式在防疫的同时还给我们带来了一些额外的惊喜，让我们的比以往多了更多的选择。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;现在的我们可以多一些考虑如何无国界地进行工作了。在不受地域限制的情况下，企业可以扩大范围来招纳最优秀的员工。摆脱地域限制在很多行业都很有价值，一些大公司在地理位置上往往都会聚集在一起，从而耗尽本来就已经很紧张的资源，这样会造成房价虚高、员工生活压力大等问题，此外，员工工作环境可以进一步地得到提高，间接地提升产品开发的质量，在疫情下，这些因素要比以往任何时候都显得更为重要。家庭工作模式也为成千上万无法参加传统工作环境的人带来了机会，从而为企业提供了更多的积极进取且合格的人才，在之前，他们可能会因为住在农村或偏远地区而丧失了工作的机会。传统的办公模式其实是不适合特殊人群的，对于必须经常搬家的军人配偶、行动不便或者拥有健康问题的人群采用家庭工作可能是一种理想的工作方案，在帮助这些特殊人群来建立稳固的职业生涯的时候，企业往往还能收获到很多渴望学习和成长的优秀员工所带来的额外收益。&lt;/li&gt;
  &lt;li&gt;家庭工作模式往往可以提高公司产品的质量。根据Global Workplace Analytics 的研究发现，实现采用居家工作的企业会享受到很多由员工高满意度和高忠诚度所带来的好处，95％的雇主表示远程办公对员工保留率有很大影响，在采用了家庭办公模式的公司中有46％的公司职员的流失数量下降了。此外Global Workplace Analytics 引用了一些大公司的研究表明，居家办公的员工生产率比办公室员工高15％至45％。简而言之，经验丰富的员工对他们的工作的满意程度会转化为更高的产品质量，在当今的客户体验优先的服务行业中，这尤其重要，在这类行业中，不断增长的客户期望和不断增加的技术复杂性要求企业员工具有更多的技能和适应不断变化的需求的能力，通过这些研究我们可以发现居家办公的员工更加自由，比以往有了更高的自觉性，这将有助于员工为其负责的客户解决更多困难和复杂问题。&lt;/li&gt;
  &lt;li&gt;家庭工作模式可以减少员工的适应时间，加快员工投入正式生产的速度。公司可以将入职培训从教室的转移到员工家中的电脑桌面上，虚拟教室不受空间限制的限制，培训人员可以在任何地方进行演示，从而可以更贴近工作环境的来随时培训新员工。甚至我们可以通过高度参与的多媒体课程使培训更加互动，让员工实践和指导学习的结合，在进行许多动手实践活动时，管理员、教练、项目团队负责人和技术人员的培训团队还能进一步地提供持续的培训和帮助，在培训时就进一步做到了模拟正式工作时的状态。&lt;/li&gt;
  &lt;li&gt;在需求激增的同时，迅速提高服务响应速度而又不影响质量的能力是在家工作模型最有价值的优势之一。在一些大型活动引起公司销量波动的时候，这种工作模式可以短期的制定一个高质量的客户服务计划，这对于我们是否能在当今瞬息万变、竞争激烈的市场中取胜而言是至关重要的，由于培训时间短，公司还可以进一步考虑招收一些临时应急员工来缓解需求激增的压力&lt;/li&gt;
  &lt;li&gt;在家办公的模式还可以实现全天候覆盖的产品服务体验。由于客户在任何时间、白天或晚上都希望获得产品附带的服务，因此，公司需要为客户服务中心配备值班员工，以满足 24/7/365 服务的需求，这在需求激增的旺季等高峰时段尤为重要。在家工作的员工可以轻松满足这一需求，员工无需担心在值班时间如何兼顾好照顾孩子、老人等日常琐事，也不必担忧深夜通勤到办公室的安全问题。实际上，许多员工更喜欢晚班和周末班，这完全取决于他们自己如何制定工作/生活平衡的个人计划，从公司运营的角度来看，这也节省了因全天候值班而带来的用于维护物理办公设施的成本。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-11-14-Final_Assignment_for_Software_Engineerin.assets/image-20201114111411455.png&quot; alt=&quot;image-20201114111411455&quot; /&gt;&lt;/p&gt;

&lt;p&gt;了解完家庭工作模式的详情后，我们结合Twitter的相关经验来进一步讨论如何实现员工能平顺地从传统工作模式过渡到远程办公模式。Twitter在2020年3月1号就暂停了所有非关键性的商务旅行和活动，并搭建了一个网站来专门为大众提供关于新型冠状病毒的最新情况，致力于在新冠病毒全球疫情爆发的时候帮助人们找到公开的与防疫相关的权威信息。3月2号，Twitter开始鼓励员工选择居家工作的方式来减少大规模传播新冠病毒的可能性，这标志着Twitter开始了对家庭工作模式的进一步探索，就如他们在网站中所写的一样：“尽管这对我们来说是一个巨大的改变，但我们已经朝着越来越分散的、越来越远程的工作方向发展。Twitter是一家全球服务公司，我们致力于使任何地方的任何人都可以在Twitter上工作。” 到了3月11号，也就是鼓励员工居家办公的九天之后，Twitter开始在全球范围内强制要求员工采用家庭工作模式，这是一个极具意义的改变，也是自疫情以来这家公司迈出的前所未有的一步，这项措施不仅可以很好地保证员工的安全，还是对当地社区、弱势群体和一直奋战在防疫第一线的医护人员的一种无条件的支持。&lt;/p&gt;

&lt;p&gt;在强制要求员工居家办公后，Twitter做出了很多努力来减少采用这种工作模式所带来的影响：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;向部分员工、承包商和供应商支付一定的补助和赔偿，很有人文情怀地照顾到了那些无法在家庭里开展工作的员工，使他们不至于失去生活的资金来源。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;为所有员工提供了额外的福利，减少他们因临时切换到居家工作而导致生活困难的可能性。所有员工（包括小时工）都将获得其家庭办公室设置费用的报销，并且通过与供应商的合作，还可以确保公司的承包商也能满足其在家工作的需求。在听取了员工的反馈后，Twitter又扩大了政策范围，使报销包括了各类家庭办公设备，例如书桌，课桌椅和符合人体工学的椅子等，还允许员工报销在家里工作时产生的流量费用。&lt;/li&gt;
  &lt;li&gt;引入了一个名叫#FlockTalk的程序，这个程序会在员工陷入困难时期急需他人的帮助的时候被激活，员工通过这个程序可以在社区里分享他们正在面对的事情，程序背后是Twitter的专业团队来负责管理的，他们认为工作场所的健康状况和员工的心理健康状况之间存在直接的关联，借此来减轻疫情对员工心理的不良影响。&lt;/li&gt;
  &lt;li&gt;提供各种居家办公的指南说明来帮助员工继续完成日常工作，同时又积极地向公众公开这些资料，因为在这种特殊的时期，分享见解和学习非常重要，Twitter希望其不仅能帮助到自己的员工，还能让公司员工之外的其他人能更轻松地过渡到远程工作的模式。这里列举指南中几条有比较重要且实用的建议：
    &lt;ul&gt;
      &lt;li&gt;家庭工作模式不会改变日常的工作，而只是意味着你将在不同的环境中进行工作，还要继续保证拥有一个舒服的工作环境、坚持记录好每天的工作内容和及时地和项目伙伴进行沟通以确保项目开发的进程顺畅。&lt;/li&gt;
      &lt;li&gt;跟进项目伙伴，管理好分布式团队，项目经理应当为团队中的每个人（无论身在何处）提供一致且舒适的员工体验。要把握好管理的三个主要支柱：战略、成长和关怀，在团队完全处于分布式状态时，具体的改变其实并不多，这三个重要支柱依旧适用。&lt;/li&gt;
      &lt;li&gt;Twitter上的所有会议和面试都将通过网络视频进行。完全虚拟的对话有其好处，这是将员工融入远程工作文化的理想之举，而对于那些将在远程工作的候选人来说，这也是一个很好的机会来积累与其他团队伙伴进行远程交互的经验。&lt;/li&gt;
      &lt;li&gt;Twitter还共享了跨时区工作的指南，利用协作工具（各类社交通话软件，版本控制软件和分布式开发服务框架等）保持联系，并提供了人机工程学技巧，使得员工无论在家还是在旅途中都可以进行日常工作。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;根据Twitter的首席人力资源官 Jennifer Christie 的在2020年5月12号的报告，经过几个月的尝试，Twitter已经证明了其可以对分布在任何地方进行工作的员工提供很好的支持，在管理的权限下放后依旧不会影响公司的正常运作，当前他们可以迅速地对疫情下的各种情况作出响应，这已经变成了他们所具有的一种独特优势了。同时，如果员工很好地适应了居家工作的角色和状态，并希望能一直采用家庭办公的工作模式的话，那Twitter将允许员工永久地居家工作，当然，在他们想重回办公室的时候也是不会被阻止的。在接下来的几个月里，公司会在确保安全的情况下做好预防措施再重启办公室，但员工何时重回办公室完全取决于自己的抉择，重启办公室后也不会立刻回归到之前的模式，而是谨慎的、有意的、逐步进行改变的。除了极少数的情况外，各种商务旅行和面对面交流的公司活动都将不再被允许。&lt;/p&gt;

&lt;p&gt;在 Jennifer Christie 提出的这些措施中，我们可以看到Twitter对员工和社区的健康是考虑得十分的周到，一家有责任感的公司会时刻把员工的生命健康放在第一顺位，这无论是在何种情况下都是进行任何工作的必要前提。特别是在科技蓬勃发展的当下，采用家庭办公这类远程开发的工作模式已经不再是一件技术难题，在公司层面更应该关心的是如何让员工融入到居家工作的环境中去，这也就要求了一家具有责任感的公司必须做到以员工为本，在制定政策的时候要深切地考虑到每一位员工在转变工作模式后需要面临的各种问题并及时给予员工帮助，就如同Twitter所做的一般，为员工提供一些额外的经济补贴、适当的人文关怀、各种技术上的帮助和详尽的办公指南，这些措施的最终目的都是让员工在采用家庭工作模式后尽可能地不受到额外的困扰，真正地体现“家庭工作模式只是意味着你将在不同的环境中进行工作”这一原则，根据Global Workplace Analytics数据显示，2017年中国远程办公规模达60亿元，2012-2017年的年均复合增速达到95.52%，相关智库基于此数据预测2020年全年我国的远程办公市场规模有望达到448.5亿元，约为2017年市场规模的7.5倍，这表明居家办公的工作模式在疫情的刺激下会逐渐的成为一种新趋势，可以预见的是越来越多的公司会在全球疫情形势不明朗的情况下，开始考虑采用家庭工作模式来很好地规避健康风险，避免由疫情传播造成公司运转失效瘫痪。&lt;/p&gt;

&lt;p&gt;除了Twitter之外，还有一个著名的开源项目Gitlab也完全采用了家庭工作这种模式，而且比Twitter更特殊的是，这家公司在创立之初就一直沿用了这种模式来进行工作。从2011年只有2个人的初创组合开始，到2020年发展成世界上最大的采用远程开发的公司，GitLab在65个国家拥有超过1200名团队成员，每一个团队成员都是远程的，在世界任何地方都没有中央总部和公司所属的办公室，GitLab在最近4年内经历了50倍的增长，在2020年达到了1亿美元ARR收入的大关，目前，GitLab的估值为27.5亿美元，迄今已融资4.26亿美元。Gitlab是自新冠疫情爆发以来为数不多还能取得如此卓越成果的团队之一，而这家公司依靠的就是一套完善的家庭工作制度来取得这些令人瞩目的成就的。
&lt;img src=&quot;/assets/2020-11-14-Final_Assignment_for_Software_Engineerin.assets/image-20201114110727364.png&quot; alt=&quot;image-20201114110727364&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Gitlab始终认为有效的沟通是一个公司稳定的地基，于是他们将员工手册开源后公布在了网上，任何人都能看到这家公司的办事准则，GitLab的员工手册涵盖了公司价值观、内部沟通指南、开发流程、写作风格指南，以及如何请假、如何报销等工作的方方面面，这份文档已经变成如何实现远程开发办公的范本资料了。就如同Gitlab工作手册中描述的一般，GitLab需要始终确保沟通方式适用于一个成长型团队，并且能够简化不同国家中新员工的入职程序。同时由于Gitlab是一家地理分离式公司，显而易见员工们不能转个头就询问同事一些事情，因此需要有一个针对各类问题的共识，让大家随时随地都能访问。另外，结果导向、公开透明、效率和协作是Gitlab非常重要的行为方式，因此一份开源公司手册对于Gitlab来说非常适合，实际上这份手册就是一个知识共享许可。这意味着大家都可以随意复制和使用这份手册，没有必要重复造轮子。尽管将员工手册开源出来并不是一个常规的方式，但Gitlab也希望有更多的人能接受这个理念，大家既能很方便地学习到Gitlab掌握的知识，也能看到手册的历史版本和编辑日志，看到Gitlab是如何实现当前的想法的，实际上公司是处在一个变化的状态中，人员流动、流程变更等等事项都意味着Gitlab需要经常更新工作指南来反应团队当前的状态。员工手册的更新同步于公司状态的变化，而通过与之关联的合并请求就能轻易地了解这个变化是如何产生的，如果员工手册不开放而且难以访问时（比如需要使用内网 VPN 登录查看），这份手册往往会变得陈旧且形同虚设。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/2020-11-14-Final_Assignment_for_Software_Engineerin.assets/image-20201114115850753.png&quot; alt=&quot;image-20201114115850753&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在疫情期间，Gitlab还发起了一个针对远程工作的调查，其研究的方法是对3,000名21岁及以上的专业人员进行了采访，这些受访者在2020年1月30日至2020年2月10日期间都进行了远程办公或者有机会选择远程办公，并且其工作的内容主要以数字产品为主，目的是为了探索远程工作的未来，为完善一个更实用的家庭工作模式做出贡献。根据这份调查报告我们可以了解到很多要点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;采用所有人都采用家庭工作模式是最纯粹的远程工作形式，这可以让每个团队成员都处于公平竞争的环境中。有43%的远程工作者认为，在一个所有员工都是远程工作的公司中工作是很重要的。目前，超过1/4的受访者属于全远程组织，他们没有固定的办公室，同一接受异步工作流程，每个员工都在自己的本土时区工作。另外有12%的受访者属于全远程工作，但还是处在公司规定的时区同步进行工作。&lt;/li&gt;
  &lt;li&gt;在远程工作的模式下每个人都能做出一定贡献。当每个人都有能力推动组织前进时，远程团队的真正力量就会被释放出来。56%的远程工作者表示，公司里的每个人都可以对流程、价值观和公司方向做出贡献，50%的远程工作者还默认共享文件，仅在万不得已的情况下才会依赖会议。&lt;/li&gt;
  &lt;li&gt;远程工作者并不都是新时代下长期进行旅行的游牧民族。调查结果显示，38%的人认为没有通勤时间是远程工作中最重要的好处，他们可以把这些时间用来陪伴家人（43%）、工作（35%）、休息（36%）和锻炼（34%）。远程工作的员工们发现自己整体上更有生产力（52%）和效率（48%），74%的远程工作者认为他们的公司是可以让员工依照自己的价值观来生活的。此外，与传统观念不同的是，52%的远程工作者实际上减少了旅行。调查表明远程工作的另一个好处使员工能够专注于家庭的同时而不必放弃自己的事业，34%的人认为能够照顾家庭是远程工作的首要好处，调查还发现，为了代替通勤，43%的人能够花更多的时间与家人相处，而55%的受访者有18岁以下的孩子。&lt;/li&gt;
  &lt;li&gt;47%的人表示，在家工作时如何提高专注力是首要挑战，现在的“家庭工作模式”这个词已经不在局限于居家了，团队成员可以在任何他们能达到最佳工作效率的地方工作。&lt;/li&gt;
  &lt;li&gt;近半数受访者认为自己很幸运能够在远程工作，他们对在这种工作模式下的体验评价前四名分别是很实用、受到了重视、觉得自己很聪明和感到自豪，只有不到10%的受访者联想到 “孤独”、”疲惫 “和 “被误解”。&lt;/li&gt;
  &lt;li&gt;远程≠孤独，人与人之间的互动是有温度的，这在远程环境中也是一样重要的。82%的远程工作者表示，他们的公司支持通过活动、峰会、见面会等方式进行在网络上举行面对面的聚会，同时，66%的受访者表示其已经与远程工作的社区建立了联系。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这些要点为我们展示一个新的蓝图，远程办公是对于员工而言也是有很多好处的。在新冠疫情的威胁下，人群聚集引起的潜在健康危机已经远远大于转变工作模式带来的阵痛，尤其是在互联网企业，面对面的传统工作模式显得愈发不重要了，远程工作模式已经越来越融入到我们的世界之中了。员工在这种工作模式下可以体验到比以往更多的人文关怀，生命健康也得到了更多的保障，还能拥有更多时间来陪伴家人和自我学习进步，从而获得更多由工作带来的成就感和实现自己的人生价值，对于公司而言也是双赢的，在远程工作模式下，既避免了健康危机，又增强了员工的归宿感。&lt;/p&gt;

&lt;p&gt;在疫情期间，家庭工作这种远程工作模型已经率先在互联网行业得到了推广使用，从小众非主流开始走入到大众的视野之中，潜移默化地改变了软件开发的工作方式，各类异步开发工具、版本控制软件和网络社区都在这个特殊的时期发挥起了积极的影响。如Twitter这种受疫情影响临时从传统工作模式转化到家庭工作模式的公司也成功做到了双赢的情况，这证明了家庭工作模式在软件开发行业的推广使用其实是轻便的，不需要进行太多重构，是可以在短时间内就得到实现的，而Gitlab这种完全远程办公的公司，也从侧面证明了远程办公模式和传统工作模式都是可以正常应付日常工作的，相比与传统的工作模式，远程办公模式还能让员工有了更多自主选择的空间并节省了很多用于通勤的时间成本花销。从长期来看，这种工作模式会逐步地推广到越来越多的互联网公司，在减轻疫情影响的同时保证了公司还能照常运转，这都是值得我们这些即将从事软件开发或者已经是资深开发的人认真学习理解的。&lt;/p&gt;

&lt;h2 id=&quot;结束语&quot;&gt;结束语&lt;/h2&gt;

&lt;p&gt;在短短11周的课程之后，在课堂上我通过老师学习到了很多关于软件工程的知识，写这篇结课小论文时，又通过查找和整理资料更深入地了解到远程开发模型的概念和实现方法，我很开心能有这些的收获，同时我必须要真诚地感谢老师对我们的细心教导和照顾，这一学期能过和老师共同度过这一门课我感到十分的愉快！&lt;/p&gt;

&lt;h2 id=&quot;参考文献&quot;&gt;参考文献&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.twitter.com/en_us/topics/company/2020/covid-19.html&quot;&gt;Coronavirus: Staying safe and informed on Twitter By Twitter Inc. Friday, 3 April 2020&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.twitter.com/en_us/topics/company/2020/keeping-our-employees-and-partners-safe-during-coronavirus.html&quot;&gt;Keeping our employees and partners safe during #coronavirus By Jennifer Christie&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://globalworkplaceanalytics.com.statscrop.com/&quot;&gt;Global Workplace Analytics Web&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.iyiou.com/intelligence/report698.html&quot;&gt;亿欧智库《2020远程办公研究报告》&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://about.gitlab.com/remote-work-report/&quot;&gt;The Remote Work Report by GitLab: The Future of Work is Remote&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.inc.com/cameron-albert-deitch/2018-inc5000-gitlab.html&quot;&gt;How This Startup Made $10.5 Million in Revenue With Every Single Employee Working From Home&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://link.jianshu.com/?t=http://link.zhihu.com/?target=https%3A//about.gitlab.com/handbook/&quot;&gt;Gitlab Team Handbook&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>true</name></author><category term="软件工程" /><category term="小论文" /><category term="学习" /><summary type="html">浅析-疫情对软件开发的工作模式的影响</summary></entry><entry><title type="html">Linux操作系统原理与应用笔记</title><link href="http://localhost:4000/2020/11/08/linux_note.html" rel="alternate" type="text/html" title="Linux操作系统原理与应用笔记" /><published>2020-11-08T08:00:00+08:00</published><updated>2020-11-08T08:00:00+08:00</updated><id>http://localhost:4000/2020/11/08/linux_note</id><content type="html" xml:base="http://localhost:4000/2020/11/08/linux_note.html">&lt;h1 id=&quot;linux操作系统原理与应用笔记&quot;&gt;Linux操作系统原理与应用笔记&lt;/h1&gt;

&lt;h2 id=&quot;第一章-概述&quot;&gt;第一章 概述&lt;/h2&gt;

&lt;h3 id=&quot;linux内核的技术特点&quot;&gt;linux内核的技术特点&lt;/h3&gt;

&lt;p&gt;以实用性和效率为出发点，内核设计成==单内核结构==，整体上把内核作为一个大过程来实现，内核其实就函数和数据结构的集合，其与微内核相比可扩展性和可移植性较低，但与微内核不同，在与文件管理、设备驱动、虚拟内存管理、进程管理等其他上层模块之间不需要有较高的通信开销，==模块之间可以直接调用相关的函数==。（整体的概念）&lt;/p&gt;

&lt;h3 id=&quot;linux内核中链表的实现及应用&quot;&gt;linux内核中链表的实现及应用&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;​	双链表通过前趋和后继两个指针域就可以从两个方向循环双链表，如果打乱前趋后继的依赖关系，就可以构成&lt;strong&gt;“二叉树”&lt;/strong&gt;、“循环链表”，设计更多的指针域还可以构成各种复杂的树状数据结构，如果减少一个指针域，还可以进一步设计成&lt;strong&gt;“栈”和“队列”&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;链表的定义&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;my_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mydata&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;特点：list域隐藏了链表的指针特性，且一个结构中可以有多个list域&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;链表的操作&lt;/strong&gt;
链表头初始化操作为：把前趋后继都指向自己，后续添加操作就是形成一个==循环链表==，内核代码&lt;code class=&quot;highlighter-rouge&quot;&gt;list.h&lt;/code&gt;中定义了两个宏来定义链表头：&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#define LIST_HEAD_INIT(name){&amp;amp;(name),&amp;amp;(name)}
#define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;添加节点的具体操作&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//	链表的添加节点&lt;/span&gt;
  
&lt;span class=&quot;cm&quot;&gt;/*
*	静态内联函数 inline说明该函数对编译程序是可见的
*/&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__list_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;	&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;	&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;//	在链表头尾添加节点&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;list_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;__list_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;//	在链表头节点后插入new节点&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;list_add_tail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;__list_add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;__list_add&lt;/code&gt;这个内部函数，可以看成是==在两个节点(prev节点和next节点)中插入一个新的节点==，这个设计十分巧妙，只要对其进行相应的封装就可以实现多种功能，如&lt;code class=&quot;highlighter-rouge&quot;&gt;list_add&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;list_add_tail&lt;/code&gt; 这两个函数就可看出，一个是在head节点和后继节点间插入新节点，一个是在head节点和前趋节点间插入，可以用来分别实现&lt;strong&gt;一个栈和一个队列&lt;/strong&gt;。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;关键字inline必须与函数定义体放在一起才能使函数成为内联，inline函数一般放在头文件中使用&lt;/em&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;循环链表操作&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//	每次只找出节点在链表中的偏移位置，还需要list_entry来找出节点的起始地址&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define list_for_each(pos,head)\
	for(pos=(head)-&amp;gt;next; pos!=(head); pos=pos-&amp;gt;next)
&lt;/span&gt;  
&lt;span class=&quot;cm&quot;&gt;/*
*	(char *)(ptr)-(unsigned long)(&amp;amp;((type *)0)-&amp;gt;member)
*	ptr指向的是某一结构list域的绝对地址，type是某一结构，member是type结构中的某一域
* __返回值__ type *
*/&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define list_entry(ptr,type,member)\
	((type *)((char *)(ptr)-(unsigned long)(&amp;amp;((type *)0)-&amp;gt;member)))
&lt;/span&gt;  
&lt;span class=&quot;c1&quot;&gt;//	安全的遍历节点，在释放节点前先记录下下一个要释放的节点，因为删除节点后&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//	当前被删除的节点的前趋后继是指向内核中两个固定位置的，如果按list_for_each会出错&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#define list_for_each_safe(pos,n,head)\
	for(pos=(head)-&amp;gt;next,n=pos-&amp;gt;next; pos!=(head); pos=n,n=pos-&amp;gt;next)
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__list_del&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;list_del&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;__list_del&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LIST_POSTION1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//	内核地址中的固定地址&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;entry&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;LIST_POSTION2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      
&lt;span class=&quot;c1&quot;&gt;//	具体代码中的应用&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numlist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numlist&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numhead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;INIT_LIST_HEAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numhead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numlist&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;listnode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numlist&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//	遍历节点的操作&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;list_for_each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numhead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// 	list(prt,type,member)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numlist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printk&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(...&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;c1&quot;&gt;//	删除所有节点的操作&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;list_for_each_safe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numhead&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lits&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;list_del&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numlist&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;kfree&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  	&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;具体分析&lt;code class=&quot;highlighter-rouge&quot;&gt;list_entry&lt;/code&gt;:把0地址转换成type类型的指针，获取该结构中member域的指针，也就是为了==得到member在type结构中的偏移量==，而==ptr - member==就得到了type结构的起始地址，也就&lt;strong&gt;获得某一节点的起始地址&lt;/strong&gt;，可以进一步读出type结构中的data域和list域&lt;/p&gt;

    &lt;p&gt;哈希表也是链表的一种衍生，在&lt;code class=&quot;highlighter-rouge&quot;&gt;list.h&lt;/code&gt;中也有相关实现&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;第二章-内存寻找&quot;&gt;第二章 内存寻找&lt;/h2&gt;
&lt;h3 id=&quot;内存寻址&quot;&gt;内存寻址&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;保护模式：这种模式下内存段的范围受到了限制，范围内存时不能直接从段寄存器中获得段的起始地址，而需要经过额外转换和检查（从此不能再随意存取数据段）&lt;/p&gt;

  &lt;p&gt;线性地址：指一段连续的、不分段的，范围从0~4GB的地址空间，一个线性地址就是线性空间的一个绝对地址&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;80386中地址总线和数据总线都是32位，寻址能力达到了4GB，但其为了兼容，还是保留了16位的段寄存器，并采用了在段寄存器基础上的方式来构筑保护机制，即寻址方式为：==段选择符：偏移地址（虚拟地址）==-&amp;gt;线性地址（使用MMU转换）-&amp;gt;物理地址，&lt;strong&gt;段寄存器中存放的是段选择符&lt;/strong&gt;（简单理解为段描述表的索引）。&lt;/p&gt;

&lt;p&gt;16位的段寄存器是明显不足以确定一个基地址，因此段寄存器里存放的段选择符就要发挥作用了，同时在保护模式下，系统中存放有三种类型的描述符表：GDT、IDT（中断描述符表）、LDT，为了加快读取速度还设计了三个寄存器，通过段选择符加描述符表的地址，就可以取得段描述符。&lt;/p&gt;

&lt;p&gt;Linux为了保持可移植性并不真正地使用分段机制，开发人员巧妙地将所有段的基地址设置成0，因此所有的进程都共享了0~4GB的线性空间，这样“偏移量”就等于了“线性地址”，也就是说&lt;strong&gt;虚拟地址就直接等同于了线性地址&lt;/strong&gt;，但这样会让段保护的第一个方法无法发挥作用，且如果线性空间直接映射到物理空间，还会出现进程使用的地址互相覆盖的问题，为此Linux使用了分页机制来解决问题。&lt;/p&gt;

&lt;p&gt;页对应的是物理内存的块，大小都是4KB，通常采用两级页表（页目录和页表）的方法来实现线性地址到物理地址的映射，&lt;strong&gt;32位线性地址&lt;/strong&gt;转换成&lt;strong&gt;物理地址&lt;/strong&gt;的处理方式为：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;最高10位为页目录项的索引，其左移两位后与CR3中的页目录基地址相加可以得到对应的页目录项地址&lt;/li&gt;
  &lt;li&gt;中间10位为页表项的索引，其左移两位后与从页目录项得到的页表基址相加得到具体的页表项&lt;/li&gt;
  &lt;li&gt;最低12位为页面偏移地址，从页表项中映射到页面的物理基址，与偏移地址相加就可得到要找的物理地址&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;linux具体实现内存寻址的方式&quot;&gt;Linux具体实现内存寻址的方式&lt;/h3&gt;

&lt;p&gt;目前很多平台都开始使用64位的处理器，Linux为了兼容使用了三级页表的机制，但当前讨论还是通过二级页表的模式为主，其三级页表具体设计为：线性地址（总目录：中间目录：页表：偏移量）。仅支持二级页表的处理器上使用三级页表的模式时，Linux把中间目录当成只有一项，并把其“折叠”到总目录之中，从而适应了二级页表的机制。&lt;/p&gt;

&lt;p&gt;Linux中每一个进程都有自己的页目录和页表集，当进程发生切换时，&lt;strong&gt;Linux把CR3的内容存放到前一个执行进程的PCB中&lt;/strong&gt;，而把下一个要执行的进程的PCB的值装入到CR3中，恢复进程的时候，Linux会先查找PCB中的暂存的内容并恢复到CR3中，从而使分页单元指向正确的页表&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;linux内核初始化页表的代码实现&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;cp&quot;&gt;#define NR_PGT 0x4   												//  需要初始化的页面个数
&lt;/span&gt;  &lt;span class=&quot;cp&quot;&gt;#define PGD_BASE (unsigned int *)0x1000     //  页目录表映射到物理内存的地址
&lt;/span&gt;  &lt;span class=&quot;cp&quot;&gt;#define PAGE_OFFSET (unsigned int)0x2000    //	页表的起始地址	
&lt;/span&gt;
  &lt;span class=&quot;cp&quot;&gt;#define PTE_PRE 0x01    // 初始化时 页表会装入内存
&lt;/span&gt;  &lt;span class=&quot;cp&quot;&gt;#define PTE_RW  0x02    // 与U/S位形成硬件保护 
&lt;/span&gt;  &lt;span class=&quot;cp&quot;&gt;#define PTE_USR 0x04    // Page Write-Through 写透方式
&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;page_init&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pages&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;NR_PGT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 										&lt;span class=&quot;c1&quot;&gt;//  系统初始化时创建4个页表&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;page_offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PAGE_OFFSET&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pgd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PGD_BASE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;//  页目录表存放的物理地址&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pages&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;--&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pgd&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;page_offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PTE_USR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PTE_RW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PTE_PRE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//  创建四个页目录表项&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;page_offset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1000&lt;/span&gt;   												&lt;span class=&quot;c1&quot;&gt;//  每个页目录表的大小为2^12=4KB&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;pgd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PGD_BASE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

      &lt;span class=&quot;c1&quot;&gt;//  页表从物理内存第三个页框开始&lt;/span&gt;
      &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgt_entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x2000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   
      &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phy_add&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x0000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;//  0x1000000=16MB 初始化了四个页表，每个页表映射了4MB的物理内存地址&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;phy_add&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1000000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
      &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pgt_entry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;phy_add&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PTE_USR&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PTE_RW&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PTE_PRE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;//  页面与物理内存真正形成映射&lt;/span&gt;
          &lt;span class=&quot;n&quot;&gt;phy_add&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x1000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      												&lt;span class=&quot;c1&quot;&gt;//  物理块大小和页面大小都是4KB&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;c1&quot;&gt;//  CR0最高位为控制分页位，linux下分页机制的开启是可选的，则段内嵌汇编的作用就是允许分页&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;__asm__&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__volatile__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;movl  %0, %%cr3;&quot;&lt;/span&gt;
                                  &lt;span class=&quot;s&quot;&gt;&quot;movl   %%cr0, %%eax;&quot;&lt;/span&gt;
                                  &lt;span class=&quot;s&quot;&gt;&quot;orl    $0x80000000, %%eax;&quot;&lt;/span&gt;
                                  &lt;span class=&quot;s&quot;&gt;&quot;movl   %%eax, %%cr0;&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;r&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pgd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;memory&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%eax&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;第三章-进程&quot;&gt;第三章 进程&lt;/h2&gt;

&lt;h3 id=&quot;linux系统中的进程控制块&quot;&gt;linux系统中的进程控制块&lt;/h3&gt;

&lt;p&gt;linux中对进程的描述结构叫做PCB（task_struct）其是一个相当庞大的结构体，按功能可以分成以下几类&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;状态信息-描述进程的动态变化&lt;/li&gt;
  &lt;li&gt;链接信息-描述进的亲属关系&lt;/li&gt;
  &lt;li&gt;各种标识符&lt;/li&gt;
  &lt;li&gt;进程间通信信息&lt;/li&gt;
  &lt;li&gt;时间和定时器信息&lt;/li&gt;
  &lt;li&gt;调度信息&lt;/li&gt;
  &lt;li&gt;文件系统信息&lt;/li&gt;
  &lt;li&gt;虚拟内存信息-描述进程编译连接后形成的地址空间&lt;/li&gt;
  &lt;li&gt;处理器环境信息-进程的执行环境（处理器的各种寄存器及堆栈信息），==体现进程动态变化最主要的场景==&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;系统创建一个新进程的时候就是在内核中为它建立了一个PCB，进程结束的时候又收回PCB，其是内核中频繁读写的数据结构，因此应当常驻内存。&lt;/p&gt;

&lt;p&gt;每当进程从用户态进入内核态后都要使用栈-进程的内核栈，进程一进入内核态，CPU就自动为其设置该进程的内核栈，这个栈位于&lt;strong&gt;内核的数据段&lt;/strong&gt;上，其==&lt;em&gt;内核栈和一个&lt;code class=&quot;highlighter-rouge&quot;&gt;thread_info&lt;/code&gt;结构存放在一起，大小为8KB&lt;/em&gt;==。实际上内核为PCB分配空间的方式是动态的（&lt;strong&gt;确切地说，内核根本不为PCB分配内存&lt;/strong&gt;），而仅仅给内核栈分配8KB的内存，并把一部分让给PCB使用(thread_info)。&lt;/p&gt;

&lt;p&gt;段起始于末端，并朝这个内存区开始的方向增长，从用户态转到内核态以后，&lt;u&gt;进程的内核栈总是空的&lt;/u&gt;，堆栈寄存器ESP直接指向内存区的顶端，只要把数据写入栈中，ESP的值递减。&lt;code class=&quot;highlighter-rouge&quot;&gt;thread_info&lt;/code&gt;与内核栈存放在一起的最大好处是，内存栈很容易从&lt;code class=&quot;highlighter-rouge&quot;&gt;ESP&lt;/code&gt;的值获取到当前CPU上运行的&lt;code class=&quot;highlighter-rouge&quot;&gt;thread_info&lt;/code&gt;结构的地址，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;thread_union&lt;/code&gt;(内核栈和thread_info)结构的长度是8KB，&lt;strong&gt;则内核屏蔽ESP的低13位就得到thread_info结构的基地址&lt;/strong&gt;，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;*task&lt;/code&gt;就可以得到该进程的PCB，&lt;code class=&quot;highlighter-rouge&quot;&gt;PCB&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;thread_info&lt;/code&gt;都有一个域是指向对方的，是一种一一对应的关系，而再定义一个&lt;code class=&quot;highlighter-rouge&quot;&gt;thread_info&lt;/code&gt;结构的原因有两种可能：1.该结构是最频繁被调用的 2.随着linux版本的变化，PCB越来越大，为了节省内核栈的空间，需要把一部分的PCB内容移出内核栈，只保留最频繁被使用的&lt;code class=&quot;highlighter-rouge&quot;&gt;thread_info&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&quot;linux中进程的组织方式&quot;&gt;linux中进程的组织方式&lt;/h3&gt;

&lt;p&gt;内核建立了几个进程链表，双向循环链表的头尾都是&lt;code class=&quot;highlighter-rouge&quot;&gt;init_task&lt;/code&gt;（0号进程的PCB，是预先由编译器静态分配到内核数据段的，在运行过程中保持不变，永远不会被撤销的），系统使用哈希表和链地址法来加速用PID找到相应PCB的过程，并组织好了一个就绪队列和等待队列&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;就绪队列存放处于就绪态和运行态的进程&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;等待队列存放睡眠进程，对中断处理、进程同步和定时用处很大&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//	等待队列的数据结构&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__wait_queue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;init&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//	区分互斥进程和非互斥进程，对于互斥进程值为（WQ_FLAG_EXCLUSIVE）&lt;/span&gt;
  &lt;span class=&quot;cp&quot;&gt;#define WQ_FLAG_EXCLUSIVE 	0x01	
&lt;/span&gt;  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;private&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;							&lt;span class=&quot;c1&quot;&gt;//	传递给func的参数&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;wait_queue_func_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;//	用于唤醒进程的函数，需要根据等待的原因归类&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//	用于组成等待队列&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__wait_queue&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wait_queue_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  
&lt;span class=&quot;c1&quot;&gt;//	等待队列头结构&lt;/span&gt;
&lt;span class=&quot;cm&quot;&gt;/*
*	等待队列是由中断处理程序和主要内核函数修改的,因此必须对其双向链表保护,以免对其进行同时访问
*	所以采用了自旋锁来进行同步
*/&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__wait_queue_head&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;spinlock_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;等待队列是由中断处理程序和主要内核函数修改的，因此必须对其双向链表保护，以免对其进行同时访问，所以采用了自旋锁来进行同步&lt;/p&gt;

    &lt;p&gt;等待队列的操作&lt;code class=&quot;highlighter-rouge&quot;&gt;add_wait_queue()&lt;/code&gt;把一个非互斥进程插入到等待队列链表的第一个位置，&lt;code class=&quot;highlighter-rouge&quot;&gt;add_wait_queue_exclusive()&lt;/code&gt;把一个互斥进程插入但等待队列的最后一个位置。让某一个进程去睡眠的最基本操作为：先把当前进程的状态设置成&lt;code class=&quot;highlighter-rouge&quot;&gt;TASK_UNINTERRUPTIBLE&lt;/code&gt;并把它插入到特定的等待队列中，然后调用调度程序，当进程被唤醒的时候会接着执行剩余的指令，同时把进程从等待队列中删除&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//	wake_up()函数&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;wake_up&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait_queue_head_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list_head&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;wait_queue_t&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//	扫描链表，找等待队列中的所有进程&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;list_for_each&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;q&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//	curr指向每个等待进程的起始地址&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list_entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait_queue_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/*如果进程已经被唤醒并且进程是互斥的，则循环结束
     *因为所有的非互斥进程都是在链表的开始位置，而所有的互斥进程都在链表的尾部，所以可以先唤醒非互斥			 *进程再唤醒互斥进程
     */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TASK_INTERRUPTIBLE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TASK_UNINTERRUPTIBLE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;linux进程调度&quot;&gt;linux进程调度&lt;/h3&gt;

&lt;p&gt;linux进程调度是时机：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1. 进程状态转换的时刻，使用`sleep_on()`、`exit()`时会主动调用调度函数
 	2. 当前进程的时间片用完
 	3. 设备驱动程序运行时
 	4. 从内核态返回到用户态时，从系统调用返回意味着离开内核态，状态转换需要花费一定的时间，在返回到用户态前，系统把在内核态该处理的事应当全部做完。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;//	schedule() 函数主框架 &lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__sched&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;notrace&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__schedule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;preempt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switch_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/*  ==1==  
        找到当前cpu上的就绪队列rq
        并将正在运行的进程curr保存到prev中  */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cpu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;smp_processor_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpu_rq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/*
     * do_exit() calls schedule() with preemption disabled as an exception;
     * however we must fix that up, otherwise the next task will see an
     * inconsistent (higher) preempt count.
     *
     * It also avoids the below schedule_debug() test from complaining
     * about this.
     */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlikely&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TASK_DEAD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;preempt_enable_no_resched_notrace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/*  如果禁止内核抢占，而又调用了cond_resched就会出错
     *  这里就是用来捕获该错误的  */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;schedule_debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sched_feat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;HRTICK&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;hrtick_clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/*  关闭本地中断  */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;local_irq_disable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/*  更新全局状态，
     *  标识当前CPU发生上下文的切换  */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;rcu_note_context_switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/*
     * Make sure that signal_pending_state()-&amp;gt;signal_pending() below
     * can't be reordered with __set_current_state(TASK_INTERRUPTIBLE)
     * done by the caller to avoid the race with signal_wake_up().
     */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;smp_mb__before_spinlock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/*  锁住该队列  */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;raw_spin_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;lockdep_pin_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;rq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clock_skip_update&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* promote REQ to ACT */&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/*  切换次数记录, 默认认为非主动调度计数(抢占)  */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;switch_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nivcsw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/*
     *  scheduler检查prev的状态state和内核抢占表示
     *  如果prev是不可运行的, 并且在内核态没有被抢占
     *  
     *  此时当前进程不是处于运行态, 并且不是被抢占
     *  此时不能只检查抢占计数
     *  因为可能某个进程(如网卡轮询)直接调用了schedule
     *  如果不判断prev-&amp;gt;stat就可能误认为task进程为RUNNING状态
     *  到达这里，有两种可能，一种是主动schedule, 另外一种是被抢占
     *  被抢占有两种情况, 一种是时间片到点, 一种是时间片没到点
     *  时间片到点后, 主要是置当前进程的need_resched标志
     *  接下来在时钟中断结束后, 会preempt_schedule_irq抢占调度
     *  
     *  那么我们正常应该做的是应该将进程prev从就绪队列rq中删除, 
     *  但是如果当前进程prev有非阻塞等待信号, 
     *  并且它的状态是TASK_INTERRUPTIBLE
     *  我们就不应该从就绪队列总删除它 
     *  而是配置其状态为TASK_RUNNING, 并且把他留在rq中

    /*  如果内核态没有被抢占, 并且内核抢占有效
        即是否同时满足以下条件：
        1  该进程处于停止状态
        2  该进程没有在内核态被抢占 */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;preempt&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;cm&quot;&gt;/*  如果当前进程有非阻塞等待信号，并且它的状态是TASK_INTERRUPTIBLE  */&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unlikely&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;signal_pending_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cm&quot;&gt;/*  将当前进程的状态设为：TASK_RUNNING  */&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;TASK_RUNNING&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;   &lt;span class=&quot;cm&quot;&gt;/*  否则需要将prev进程从就绪队列中删除*/&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;cm&quot;&gt;/*  将当前进程从runqueue(运行队列)中删除  */&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;deactivate_task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;DEQUEUE_SLEEP&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

            &lt;span class=&quot;cm&quot;&gt;/*  标识当前进程不在runqueue中  */&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;on_rq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;cm&quot;&gt;/*
             * If a worker went to sleep, notify and ask workqueue
             * whether it wants to wake up a task to maintain
             * concurrency.
             */&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PF_WQ_WORKER&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_wakeup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

                &lt;span class=&quot;n&quot;&gt;to_wakeup&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wq_worker_sleeping&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_wakeup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;try_to_wake_up_local&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_wakeup&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;cm&quot;&gt;/*  如果不是被抢占的，就累加主动切换次数  */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;switch_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nvcsw&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/*  如果prev进程仍然在就绪队列上没有被删除  */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task_on_rq_queued&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;update_rq_clock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/*  跟新就绪队列的时钟  */&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/*  挑选一个优先级最高的任务将其排进队列  */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pick_next_task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/*  清除pre的TIF_NEED_RESCHED标志  */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;clear_tsk_need_resched&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/*  清楚内核抢占标识  */&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;clear_preempt_need_resched&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;rq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;clock_skip_update&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;cm&quot;&gt;/*  如果prev和next非同一个进程  */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;likely&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nr_switches&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;cm&quot;&gt;/*  队列切换次数更新  */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;curr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/*  将next标记为队列的curr进程  */&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;++*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;switch_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/* 进程切换次数更新  */&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;trace_sched_switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;preempt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;cm&quot;&gt;/*  进程之间上下文切换    */&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;rq&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;context_switch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* unlocks the rq */&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;    &lt;span class=&quot;cm&quot;&gt;/*  如果prev和next为同一进程，则不进行进程切换  */&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;lockdep_unpin_lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;raw_spin_unlock_irq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rq&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;balance_callback&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;STACK_FRAME_NON_STANDARD&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__schedule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* switch_to() */&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*转载自： http://blog.csdn.net/gatieme*/&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/* 进程地址空间切换详解 */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;kstat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;context_swtch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//	统计上下文切换的次数&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mm_struct&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;next&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mm_struct&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldmm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;active_mm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//	没有用户空间，表明这为内核线程&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;active_mm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BUG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;nexit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;active_mm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldmm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;			&lt;span class=&quot;c1&quot;&gt;//	一般进程则切换到这段用户空间&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;active_mm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;BUG&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;switch_mm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldmm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;this_cpu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//	切换出去的是内核线程的处理方式&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;active_mm&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mmdrop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;oldmm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Linux schedule()分析：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;进程需要有自己的地址空间，或者和其他进程借用，如果都没有则出错，且如果&lt;code class=&quot;highlighter-rouge&quot;&gt;schedule()&lt;/code&gt;在中断服务程序内部执行也出错&lt;/li&gt;
  &lt;li&gt;对当前进程要做相关的处理，应当进入调度程序是，其状态不一定还是&lt;code class=&quot;highlighter-rouge&quot;&gt;TASK_RUNNNING&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;进程地址空间切换，如果新进程有自己的用户空间，则&lt;code class=&quot;highlighter-rouge&quot;&gt;switch_mm()&lt;/code&gt;函数会把该进程从内核空间转换到用户空间（加载下一个要执行的进程的页目录）；如果新进程是一个内核线程，无用户空间而在内核空间中运行，则要借用前一个进程的地址空间，因为所有的进程的内核空间都是共享的。如果切换出去的如果是内核线程，则要归还所借用的地址空间，并把mm_struct 中的共享计数减1&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;linux进程创建线程及其创建&quot;&gt;Linux进程创建、线程及其创建&lt;/h3&gt;

&lt;p&gt;Linux创建进程的方式是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;fork()&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;clone()&lt;/code&gt;，然后再调用&lt;code class=&quot;highlighter-rouge&quot;&gt;exec()&lt;/code&gt;，其使用的是写时复制技术（把父子进程的全部资源都设为只读，在父子进程尝试对其进行修改时才将被修改前的全部资源复制给子进程），创建进程的实际花销是为其创建PCB并把父进程的页表拷贝一份，如果进程中包含线程，则所有线程共享这些资源，无须拷贝。子进程一开始处于深度睡眠态，以确保它不会立刻运行，在把进程PCB插入到进程链表和哈希表后才将其设成就绪态，并让其平分父进程剩余的时间片，内核有意让子进程先执行，是为了让子进程使用&lt;code class=&quot;highlighter-rouge&quot;&gt;exec()&lt;/code&gt;去执行其自己的代码，避免父进程操作引起写时复制，提高系统运行速度&lt;/p&gt;

&lt;p&gt;Linux把线程看成一个使用某些共享资源的进程，每个线程有唯一的PCB，一般情况下内核线程会在创建时永远地执行下去，在需要的时候就会被唤醒和执行。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;进程0：内核初始化工作的&lt;code class=&quot;highlighter-rouge&quot;&gt;start_kernel()&lt;/code&gt;创建一个内核线程也就是进程0，其PCB就是&lt;code class=&quot;highlighter-rouge&quot;&gt;init_task&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;进程1：也就是init进程，其一开始是一个内核线程，其调用了&lt;code class=&quot;highlighter-rouge&quot;&gt;execve()&lt;/code&gt;装入了用户态下可执行程序init(/sbin/init)，因此init是内核线程启动起来的一个普通进程，也就是用户态下的第一个进程&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;第四章-内存管理&quot;&gt;第四章 内存管理&lt;/h2&gt;

&lt;p&gt;32位平台线性空间固定大小为4GB，其中高地址1GB（0xC000 0000~0xffff ffff）是内核空间，被内核使用并且由所有进程共享，每个用户进程的用户空间为3GB大小，通过分页机制实现各个进程的用户空间私有。&lt;/p&gt;

&lt;p&gt;进程页目录PGB就位于内核空间中，在切换进程的时候需要将CR3指向新进程的PGB，CR3需要物理地址，而PGB在内核中的起始地址是虚地址，这时候需要转换，Linux的内核空间有一个独特设计，即==内核空间连续地占据了每个虚拟空间中最高的1GB，映射到物理内存却总是从最低地址开始的==，因此内核地址到物理地址只需要减去&lt;code class=&quot;highlighter-rouge&quot;&gt;PAGE_OFFSET&lt;/code&gt;就可以了。&lt;/p&gt;

&lt;p&gt;内核地址空间的结构：内核的代码和数据叫做内核映像，Linux内核映像存放于0x0010 0000开始的地方&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;这前1M的空间用于存放于系统硬件相关的代码和数据&lt;/li&gt;
  &lt;li&gt;内核映像占用0x10 0000到start_mem的空间&lt;/li&gt;
  &lt;li&gt;Start_mem到end_mem这段区域叫做动态内存，是用户程序和数据使用的内存区&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;进程的用户空间管理&quot;&gt;进程的用户空间管理&lt;/h3&gt;

&lt;p&gt;用户地址空间的结构：用户程序经过编译和链接后形成二进制映像文件，数据段、代码段、堆栈使用的空间都是在建立进程的时候就分配好，都属于必需的基本要求&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;堆栈段：在用户空间顶部，由顶向下延伸&lt;/li&gt;
  &lt;li&gt;BSS：动态分配的空间&lt;/li&gt;
  &lt;li&gt;数据段：静态分配的数据空间，&lt;/li&gt;
  &lt;li&gt;代码段：程序的相关代码&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;每个进程只有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_struct&lt;/code&gt;，其是对整个用户空间的描述，而一个进程的虚拟空间中可能有多个虚拟区间，用&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_area_struct&lt;/code&gt;描述，如堆栈段、数据段……&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_struct&lt;/code&gt;	在 &lt;code class=&quot;highlighter-rouge&quot;&gt;task_struct&lt;/code&gt; 可以找到指向该结构的指针，虽然每个进程只有一个虚拟地址空间，但是该空间可以被其他进程所共享，因此需要使用原子类型的操作 &lt;code class=&quot;highlighter-rouge&quot;&gt;atomic_t&lt;/code&gt;(该结构中包含了一个计数器)，&lt;strong&gt;描述了代码段、数据段、参数段已经环境段的起始地址和结束地址&lt;/strong&gt;，==还有指针pgt指向该进程的页目录==&lt;/p&gt;

    &lt;blockquote&gt;
      &lt;p&gt;&lt;strong&gt;&lt;em&gt;进程页表和内核页表的区别&lt;/em&gt;&lt;/strong&gt; - &lt;a href=&quot;https://blog.csdn.net/chuba6693/article/details/100612637&quot;&gt;Linux 内核页表和进程页表&lt;/a&gt;&lt;/p&gt;

      &lt;ul&gt;
        &lt;li&gt;在保护模式下，&lt;strong&gt;从硬件角度看，其运行的基本对象为“进程”(或线程)，而寻址则依赖于“进程页表”&lt;/strong&gt;，在进程调度而进行上下文切换时，会进行页表的切换：即将新进程的pgd(页目录)加载到CR3寄存器中。&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;进程页表中的线性地址包括两个部分：用户态和内核态&lt;/strong&gt;，内核态地址对应的相关页表项，对于所有进程来说都是相同的(因为&lt;strong&gt;内核空间对所有进程来说都是共享的&lt;/strong&gt;)，而这部分页表内容其实就来源于“内核页表”，即每个进程的“进程页表”中内核态地址相关的页表项都是“内核页表”的一个拷贝。&lt;/li&gt;
        &lt;li&gt;&lt;strong&gt;内核页表也包括两个部分：线性映射区和vmalloc区&lt;/strong&gt;，“内核页表”由内核自己维护并更新，在&lt;code class=&quot;highlighter-rouge&quot;&gt;vmalloc区&lt;/code&gt;发生&lt;code class=&quot;highlighter-rouge&quot;&gt;page fault&lt;/code&gt;时，将“内核页表”同步到“进程页表”中。&lt;/li&gt;
        &lt;li&gt;以&lt;code class=&quot;highlighter-rouge&quot;&gt;vmalloc&lt;/code&gt;为例(最常使用)，这部分区域对应的线性地址在内核使用&lt;code class=&quot;highlighter-rouge&quot;&gt;vmalloc&lt;/code&gt;分配内存时，其实就已经分配了相应的物理内存，并做了相应的映射，建立了相应的页表项，但&lt;strong&gt;相关页表项仅写入了“内核页表”，并没有实时更新到“进程页表中”，内核在这里使用了“延迟更新”的策略&lt;/strong&gt;，将“进程页表”真正更新推迟到第一次访问相关线性地址，发生&lt;code class=&quot;highlighter-rouge&quot;&gt;page fault&lt;/code&gt;时，此时在&lt;code class=&quot;highlighter-rouge&quot;&gt;page fault&lt;/code&gt;的处理流程中进行“进程页表”的更新。&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_area_struct&lt;/code&gt; Linux把虚存区看成是对象，把用户空间划分成一段一段是因为每个虚存区的来源可能不同，有的来自可执行映像，有的来自共享库、动态分配的内存区，不同的区有不同的操作权限和操作方法；&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_area_struct&lt;/code&gt; 可用双向链表和红黑树来组织，有利于快速定位虚存区&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;创建进程的时候，进程用户空间的创建依赖于父进程，所做的工作仅仅是&lt;code class=&quot;highlighter-rouge&quot;&gt;mm_struct&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;vm_area_struct&lt;/code&gt;的创建以及页目录和页表的建立，采用&lt;strong&gt;写时复制&lt;/strong&gt;的方法。Linux并不把进程的可执行映像装入物理内存，只是把它们链接到进程的用户空间，被引用的程序部分会由操作系统装入物理内存，也就是需要使用请页机制&lt;/p&gt;

&lt;h3 id=&quot;请页机制&quot;&gt;请页机制&lt;/h3&gt;

&lt;p&gt;给进程分配新物理页面的确定方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如果页面不在内存中，页没有被调入，则内核分配一个新页面并初始化，“请求调页”&lt;/li&gt;
  &lt;li&gt;如果页面在内存但是只读，则内核分配一个新页面并复制旧页面的内容，“写时复制”&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;em&gt;请求调页：写处理，获取新页面，把页面填为0，把页表置为新页面的物理地址，并设页面为可写和脏；读处理，分配一个零页，零页在内核初始化期间被静态分配并标记为不可写，当进程写该页面的时候才使用写时复制&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;物理内存&quot;&gt;物理内存&lt;/h3&gt;

&lt;p&gt;内核用&lt;code class=&quot;highlighter-rouge&quot;&gt;struct page&lt;/code&gt;结构表示系统中的每一个物理页面，也叫页描述符，这种结构目的在于描述物理内存本身，内核仅用这个数据结构来描述当前时刻在相关物理页中存放的东西。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;伙伴算法&lt;/strong&gt;：Linux把空闲页面分为10块链表，每个链表中的一个块为2的幂次个页面，&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;free_area_struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;page&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//	用于将page链接成一个双向链表&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;page&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//	map指向一个位图&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;free_area&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;算法过程：如果要求分配的块大小为128个页面，则去块大小为128的链表中找，如果没有则往上找，如果256大小的链表中有空间，则把256个页面平分，高地址的被使用，低地址的加入128的链表中，回收过程则相反，同时要注意相邻的物理页面要进行合并&lt;/p&gt;

&lt;p&gt;Linux中有&lt;code class=&quot;highlighter-rouge&quot;&gt;freepages&lt;/code&gt;结构，来使用内核交换守护进程(&lt;code class=&quot;highlighter-rouge&quot;&gt;kswapd&lt;/code&gt;)保证系统有足够的物理内存，结构中有&lt;code class=&quot;highlighter-rouge&quot;&gt;min|low|high&lt;/code&gt;三条线，各个界限值是通过实际的物理内存大小计算出来的，少于low会开启强交换；少于high会启动后台交换；高于high则什么都不做。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Slab分配机制&lt;/strong&gt;：用于解决内碎片，减少对伙伴算法的调用次数。对于预期频繁使用的内存区可以创建特定大小的专业缓冲区来处理，使用较少的内存区创建通用缓冲区来处理。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;slab缓冲区由一连串的大块slab构成，每个大块中包含了若干个同类型的对象，实际上缓冲区是内存中的一片区域，这片区域划分为多个slab块，每个slab由一个或者多个页面组成，存放的都是同一类型的对象&lt;/li&gt;
  &lt;li&gt;通用缓冲区，通用缓冲区最小的为32B、64B…..128KB，对通用缓冲区的管理依旧是slab方式&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;kmalloc()&lt;/code&gt;用于分配内核中的连续内存&lt;/td&gt;
        &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;vmalloc()&lt;/code&gt;用于分配非连续的内核内存&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;回收机制&quot;&gt;回收机制&lt;/h3&gt;

&lt;p&gt;把页面换出推迟到无法推迟为止，换出页面的时候不需要先将内容写入到磁盘中，如果一个页面从最近一次换入后并没有被写过则它是干净的，可以一直缓冲到必要时才加以回收；写过的脏页面放到磁盘交换区中，但不立即释放，一直推迟到必要时才进行，如果一个页面在释放后又被访问，则重新从磁盘缓冲区读入即可&lt;/p&gt;

&lt;p&gt;内核守护线程&lt;code class=&quot;highlighter-rouge&quot;&gt;kswapd&lt;/code&gt;是有自己的PCB，一样受到内核的调度，由内核设计时规定多久运行一次，&lt;/p&gt;

&lt;h2 id=&quot;第五章-中断和异常&quot;&gt;第五章 中断和异常&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;异常：1. 故障   2. 陷阱 
		  中断：1.可屏蔽中断（外部，IRQ） 2.非屏蔽中断（计算机内部的硬件故障-缺页）&lt;/p&gt;

  &lt;p&gt;通常我们指的&lt;strong&gt;异常&lt;/strong&gt;是指&lt;em&gt;异常和非屏蔽中断&lt;/em&gt;，&lt;strong&gt;中断&lt;/strong&gt;特指&lt;em&gt;可屏蔽的中断&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Linux中有256个中断向量：&lt;/strong&gt;0-31号对应为异常（异常和非屏蔽中断）向量；32-47号对应中断向量，可屏蔽中断可以通过对中断控制器的编程来改变；48-255号对应软中断，Linux只使用了128号中断（int 0x80）来实现系统调用&lt;/p&gt;

&lt;p&gt;外设可屏蔽中断，&lt;strong&gt;x86通过两片8259A中断控制器来响应15个外中断源&lt;/strong&gt;，每个8259A可管理8个中断源，第二个芯片通过第一个芯片（主片）的2号中断线连接，与中断控制器相连的线称为中断线，&lt;strong&gt;申请一条中断线就是申请一个IRQ或者申请一个中断号&lt;/strong&gt;，IRQ从0开始编号，IRQn的默认中断向量就是n+32。&lt;/p&gt;

&lt;p&gt;对于外部I/O请求的屏蔽可以分成两种&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;CPU内部关中断，则屏蔽所有外部中断&lt;/li&gt;
  &lt;li&gt;中断控制器内部的中断控制寄存器，其对应芯片的各条中断线，可以屏蔽特定中断线上的中断&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;中断线是可共享的由一个中断处理程序统一处理，而一个中断处理程序又拥有多个对应设备的中断服务例程&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;u&gt;*异常与外部接口没有任何关系，CPU执行一个异常处理程序的时候需要关中断，即屏蔽其他异常和中断，**CPU具有异常锁存的功能**，可以避免异常处理的嵌套，Linux内核必须针对不同的处理器发布的所有异常提供专门的异常处理程序*&lt;/u&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;中断描述符表&quot;&gt;中断描述符表&lt;/h3&gt;

&lt;p&gt;实模式下，0-1KB的内存空间用来存放中断向量表，表项为段地址和偏移量组成；在保护模式下，4字节的表项不足以满足需求，此时表项为：2字节的段地址、4字节的偏移量和2字节反映模式切换的信息，中断向量表也该交为中断描述符表(IDT)，其表项被称为门描述符，中断发生的时候必须先通过这个门再找到相应处理程序。中断描述符表可以存放在内存中任意位置，CPU中有一个IDTR寄存器来找到其位置（48个字节大小，高32位为基地址，低16位为IDT大小）。&lt;/p&gt;

&lt;p&gt;门描述符的类型：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;中断门，请求特权级DPL为0，用户不能访问，且访问时需要关中断，避免中断嵌套，所有中断处理程序都由中断门激活，并全部限制在内核态中&lt;/li&gt;
  &lt;li&gt;陷阱门，用户不能访问，但访问时不需要关中断&lt;/li&gt;
  &lt;li&gt;系统门，用户态进程可以通过系统门进入内核态，从而访问陷阱门&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;IDT表项的设置：&lt;/strong&gt;中断描述符表开头的19个陷阱门和系统门，这些中断向量都是被CPU保留用来处理异常的，从32号开始有224个中断门（必须跳过128号向量用于系统调用的向量）&lt;/p&gt;

&lt;h3 id=&quot;中断处理&quot;&gt;中断处理&lt;/h3&gt;

&lt;p&gt;在CPU执行下一条指令前需要进行中断检查，看看是否发生了中断或者异常，如果发生了则&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;确定发生的中断或者异常的向量i&lt;/li&gt;
  &lt;li&gt;通过IDTR找到IDT，读取第i项&lt;/li&gt;
  &lt;li&gt;进行有效性检查：
    &lt;ul&gt;
      &lt;li&gt;“段”级检查，CPU当前特权级是否比第i项段选择符中描述的特权级大，不允许低特权的进程引起高特权级的中断处理程序&lt;/li&gt;
      &lt;li&gt;“门”级检查，CPU当前特权级是否比第i个门的特权级相比，如果小于则CPU不能通过，只针对用户程序，而不包括IO产生的中断或者CPU内部的异常&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;是否发生了特权级的变化，如果变化了则说明要进行用户态到内核态的堆栈转换&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实现共享中断线，需要建立&lt;strong&gt;中断请求队列&lt;/strong&gt;，在Linux中15条中断线对应15个中断处理程序，此时CPU虽然通过中断门能找到对应的中断处理程序，但是具体的中断服务例程还未进入中断请求队列，因此中断不会被处理&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*中断线共享的数据结构*/&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;irqaction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;irq_handler_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//	指向一个具体的中断服务程序&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;		&lt;span class=&quot;c1&quot;&gt;//	中断线与IO设备的管理，IRQF_SHARED 允许其他设备共享此中断线&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cpumask_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;					
  &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;				&lt;span class=&quot;c1&quot;&gt;//	IO设备名&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;						&lt;span class=&quot;c1&quot;&gt;//	主次设备号&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;irqaction&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;next&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;	&lt;span class=&quot;c1&quot;&gt;//	共享同一中断线的每个硬件对应的中断服务例程&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;irq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;....&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;cm&quot;&gt;/*注册中断服务程序*/&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;request_irq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;irq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
               &lt;span class=&quot;n&quot;&gt;irq_handler_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;handler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
               &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;irqflags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
               &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;devname&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
               &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dev_id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//	irq				表示要分配的中断号，可以预先设定或者动态探测&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//	handler		指向处理中断的实际中断服务程序&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//	irqflags	设置中断线可否共享等信息&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//	devname		与中断相关的设备的名字&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//	dev_id		提供唯一的标志信息，以便在删除时能从共享中断线中找到指定的中断服务例程&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;中断服务程序执行时需要关闭中断，因此必须在用来处理最紧迫的事情后就立刻开中断，避免丢失重要的中断，把剩下的事情交由另一部分处理，也就分成了中断服务程序的上下部：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;中断的上半部处理与设备相关的操作：响应中断请求，读取或发送相关数据，这一部分工作很少&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;中断的下半部处理与程序相关的操作&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;中断下半部有两种机制：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;小任务机制，把要推迟执行的函数进行组织，&lt;code class=&quot;highlighter-rouge&quot;&gt;tasklet_struct&lt;/code&gt;结构表示一个独立的小任务，小任务不能睡眠，但在运行时能响应中断，推迟要处理的事情由结构中的&lt;code class=&quot;highlighter-rouge&quot;&gt;tasklet_handler&lt;/code&gt;实现，由小任务封装后交给内核处理，在被调度后尽可能尽早执行&lt;/li&gt;
  &lt;li&gt;工作队列机制，我们把推后执行的任务称为工作，这些工作以队列结构组成工作队列，而工作者线程（内核线程）就负责执行工作队列中的工作，工作队列机制是允许调度和睡眠的&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;时钟中断&quot;&gt;时钟中断&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;table&gt;
    &lt;tbody&gt;
      &lt;tr&gt;
        &lt;td&gt;时间硬件分为RTC和OS时钟，RTC为实时时钟，又称CMOS时钟，是PC主板上的一块芯片；OS时钟是操作系统控制的PC主板上的定时&lt;/td&gt;
        &lt;td&gt;计数芯片产生的，在开机时，操作系统取得RTC中的时间数据来初始化OS时钟，该定时芯片会不断的发送输出脉冲，并连接到中断控制器上，从而不断触发时钟中断，通过时钟中断来维持OS时钟的正常工作，即加1和细微的修正工作。&lt;/td&gt;
      &lt;/tr&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/blockquote&gt;

&lt;p&gt;OS时钟和RTC时钟通过BIOS链接，RTC是OS时钟的基准，Linux在内核初始化完成后就会抛弃BIOS&lt;/p&gt;

&lt;p&gt;Linux中为了简化RTC时钟到OS时钟的运算，将时间基准设为1970年1月1号凌晨0点，OS时间其实就是一个计数器，记录RTC时间-时间基准的节拍数，系统实际时间Xtime是通过读取RTC来初始化的，jiffies记录从系统启动至今的节拍数&lt;/p&gt;

&lt;p&gt;时间中断处理程序&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;给节拍数jiffies加1&lt;/li&gt;
  &lt;li&gt;更新资源消耗的时间，如当前进程所消耗的系统时间和用户时间&lt;/li&gt;
  &lt;li&gt;执行到期定时器&lt;/li&gt;
  &lt;li&gt;执行调度函数&lt;/li&gt;
  &lt;li&gt;根据xtime时间更新墙上时间&lt;/li&gt;
  &lt;li&gt;计算平均负载值&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;第六章-系统调用&quot;&gt;第六章 系统调用&lt;/h2&gt;

&lt;p&gt;系统调用是用户进程进入内核的接口层，它本身并非内核函数，但它是由内核函数实现的，进入内核后，不同的系统调用会找到各自对应的内核函数，这些内核函数被称为系统调用的“服务例程”。&lt;/p&gt;

&lt;p&gt;用户在调用系统调用的时候回向内核传递一个系统调用号&lt;code class=&quot;highlighter-rouge&quot;&gt;__NR_XXX N&lt;/code&gt;，然后系统调用处理程序通过这个号从系统调用表中找到相应的内核函数执行。系统调用号是linux系统分配的，分配完成后不能有任何改变。&lt;/p&gt;

&lt;p&gt;内核建立一个系统调用表，这个表保存在&lt;code class=&quot;highlighter-rouge&quot;&gt;sys_call_table&lt;/code&gt;数组中，其是一个函数指针数组，每一个函数指针都指向其系统调用的封装例程，有&lt;code class=&quot;highlighter-rouge&quot;&gt;NR_syscalls&lt;/code&gt;个表现，第n个表项包含系统调用号为n的服务例程的地址，但&lt;code class=&quot;highlighter-rouge&quot;&gt;NR_syscalls&lt;/code&gt;只是对可实现的系统调用最大个数进行了限定，并不表示实际已实现的系统调用数。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;ENRTY&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sys_call_table&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys_restart_syscall&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys_exit&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys_fork&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys_read&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys_write&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys_open&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;应用程序是通过软中断的方式来通知系统的，引发一个异常来促使系统切换到内核态去执行异常处理程序，此时的异常处理程序就是系统调用处理程序。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;System_call()&lt;/code&gt;函数&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先把系统调用号和异常处理程序可以用到的CPU寄存器都保存到相应的栈中，通过获得内核栈指针的值并把它取整到8KB的倍数而获得当前进程的PCB地址&lt;/li&gt;
  &lt;li&gt;对传进来的系统调用号进行检查，如果不小于&lt;code class=&quot;highlighter-rouge&quot;&gt;NR_syscalls&lt;/code&gt;则系统调用处理程序终止&lt;/li&gt;
  &lt;li&gt;如果系统调用号无效，则返回用户态，并在EAX中存放一个负的返回值&lt;/li&gt;
  &lt;li&gt;最终，根据EAX中包含的系统调用号找到对应的服务例程，因为系统调用表中每一项占4字节，故EAX中的系统调用号左移两位再加上&lt;code class=&quot;highlighter-rouge&quot;&gt;sys_call_table&lt;/code&gt;的基址就可以获取到相对应的服务例程&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;与普通函数的参数通过活动的程序栈传递不同，&lt;strong&gt;系统调用的参数通常是通过寄存器传递给系统调用处理程序的，然后再拷贝到内核堆栈中&lt;/strong&gt;，所以参数个数不能超过6个且长度不长于32位，但通常也确实存在超过6个参数的调用，这种情况下，需要用一个单独的寄存器指向进程地址空间中这些参数所在的一个内存区即可&lt;/p&gt;

&lt;p&gt;存放系统调用参数所用的6个寄存器分别为&lt;code class=&quot;highlighter-rouge&quot;&gt;EAX、EBX、ECX、EDX、ESI和EDI&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;system_call()&lt;/code&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;SAVE_ALL&lt;/code&gt;宏将其保存到内核态堆栈中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;封装服务例程&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Linux定义了&lt;code class=&quot;highlighter-rouge&quot;&gt;__syscall0&lt;/code&gt;到&lt;code class=&quot;highlighter-rouge&quot;&gt;__syscall5&lt;/code&gt;这六个宏，0~5分别对应参数的个数，严格来说每个宏需要2+2xN个参数，n是系统调用所需的参数（类型和名字）2是系统调用的名字和返回值类型&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__NR_write&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sys_write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;__syscall3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;pre&gt;&lt;code class=&quot;language-assembly&quot;&gt;write(write的__syscall3宏展开):
	pushl	%ebx						;	传参
	movl	8(%esp)	,	%ebx
	movl	12(%esp),	%ecx
	movl	16(%esp),	%edx
	movl	$4,	%eax				;	系统调用号
	int		$0x80						;	系统调用中断
	cmpl	$-126,	%eax
	jbe		.L1
	negl	%eax
	movl	%eax,	errno
	movl	$-1,	%eax
.L1:	popl %ebx
	ret
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;第七章-内核中的同步&quot;&gt;第七章 内核中的同步&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;​	内核中很多数据都是共享资源，对这些共享资源的访问必须遵循一定的访问规则&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;内核中造成并发并发执行的原因简单来说有以下几种：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;中断，中断几乎在任何时刻都可异步发生，也就随时打断当前正在执行的代码&lt;/li&gt;
  &lt;li&gt;内核抢占&lt;/li&gt;
  &lt;li&gt;睡眠&lt;/li&gt;
  &lt;li&gt;对称多处理——两个及以上的处理器可以同时执行代码&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果在一段内核代码访问某资源的时候产生了一个中断，且该中断也要访问同一资源，这就存在一个“潜在的错误”；如果在一段内核代码访问一个共享资源时可以被抢占，也一样存在一个“潜在的错误”，&lt;strong&gt;辨认出真正需要共享的数据和相应的临界区（操作共享资源的代码段）才很有挑战性。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;内核同步措施&quot;&gt;内核同步措施&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;原子操作：&lt;/strong&gt;保证指令以原子的方式执行，如加法指令把读取和增加放在一个执行指令完成，这样并发任务就不会同时访问同一个变量，绝不会引发竞争。&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cm&quot;&gt;/*linux内核提供的atomic_t类型*/&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;counter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;相关的专门函数和宏:
| 函数            | 说明                            |
| ————— | ——————————- |
| ATOMIC_INIT(i)  | 声明一个atomic_t变量并初始化为i |
| atomic_read(v)  | 返回 &lt;em&gt;v                         |
| atomic_set(v,i) | 把&lt;/em&gt;v置成i                       |
| atomic_add(i,v) | 从&lt;em&gt;v加i                         |
| atomic_sub(i,v) | 从&lt;/em&gt;v减i                         |
| ………..     |                                 |&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;自旋锁：&lt;/strong&gt;单处理器可以简单的关中断实现，自旋锁只能被一个内核任务持有，如果一个任务请求已被持有的锁则会一直忙循环，等待锁重新可用，可以有效避免多处理器并发执行的内核任务竞争共享资源，但自旋锁不应被持有过长，要长时间持有最好使用信号量&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;信号量：&lt;/strong&gt;即等待队列和睡眠机制，Linux中有&lt;code class=&quot;highlighter-rouge&quot;&gt;down()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;up()&lt;/code&gt;操作，如果信号量不小于0则获得信号锁，任务就进入临界区了，如果信号量小于0则任务挂入等待队列，信号量会睡眠所以不能再中断上下文中使用，且信号量的数据结构中也用有自旋锁，用于避免多处理器并行的错误&lt;/p&gt;

&lt;h2 id=&quot;第八章-文件系统&quot;&gt;第八章 文件系统&lt;/h2&gt;

&lt;p&gt;Linux主要的目录结构(树状结构)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;/bin		二进制可执行命令&lt;/li&gt;
  &lt;li&gt;/dev     设备特殊文件&lt;/li&gt;
  &lt;li&gt;/etc      系统管理和配置文件&lt;/li&gt;
  &lt;li&gt;/home  用户主目录基点&lt;/li&gt;
  &lt;li&gt;/lib      动态链接共享库&lt;/li&gt;
  &lt;li&gt;/sbin   系统管理命令&lt;/li&gt;
  &lt;li&gt;/tmp   公用的临时文件&lt;/li&gt;
  &lt;li&gt;/root   系统管理员的主目录&lt;/li&gt;
  &lt;li&gt;/mnt   临时安装其他文件系统的目录&lt;/li&gt;
  &lt;li&gt;/proc  &lt;strong&gt;虚拟目录，是系统内存的映射，可以直接获取系统信息&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;/var     某些大文件的溢出区&lt;/li&gt;
  &lt;li&gt;/usr     应用程序和文件&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;linux文件系统&quot;&gt;linux文件系统&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;索引结点：记录文件信息，描述某文件的大小、权限、位置等关键信息，每个文件或者目录都对应一个索引结点，文件系统把所有索引结点形成一个数组，每一个结点的分配的号码就是数组中的索引号&lt;/li&gt;
  &lt;li&gt;软连接和硬链接
    &lt;ul&gt;
      &lt;li&gt;硬链接是一个物理位置，多个文件名，&lt;strong&gt;不能是目录，必须同一个文件系统&lt;/strong&gt;；&lt;/li&gt;
      &lt;li&gt;软连接，即符号链接，存放的内容的指向另一个文件的地址，系统自动把对符号链接的操作变成对源文件的操作&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;文件系统：Linux 的标准文件系统是Ext2和Ext3，因此==Linux把Ext2文件系统的磁盘分区作为系统的根文件系统==，其他的文件系统都是安装在根文件系统之下&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;虚拟文件系统&quot;&gt;虚拟文件系统&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;虚拟文件系统即VFS（virtual filesystem switch），一种统一的框架用于虚拟文件系统转换&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;VFS提供一组标准的、抽象的操作以系统调用的方式给用户使用，如用户使用&lt;code class=&quot;highlighter-rouge&quot;&gt;read()&lt;/code&gt;读取文件时，会调用&lt;code class=&quot;highlighter-rouge&quot;&gt;sys_read()&lt;/code&gt;接着又调用&lt;code class=&quot;highlighter-rouge&quot;&gt;vfs_read()&lt;/code&gt;，文件在内核是由一个&lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt;结构表示的，里面有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;file_opration&lt;/code&gt;结构包含指向各种函数的指针，其是由具体的文件系统自己实现的，从而实现封装操作。&lt;/p&gt;

&lt;p&gt;VFS的四个主要对象为:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;超级块对象&lt;/strong&gt;，是一块包含文件系统信息的数据结构，描述已安装的文件系统&lt;/li&gt;
  &lt;li&gt;索引结点对象，文件系统对文件属性的描述，索引号可以唯一的标识文件&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;目录项对象&lt;/strong&gt;，目录可以层层嵌套形成文件路径，路径中的每一部分都被称为目录项，如有一个路径为&lt;code class=&quot;highlighter-rouge&quot;&gt;/home/xj/myfile&lt;/code&gt;，其中/为根目录，home,xj,myfile都是目录项，是路径的组成部分&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;文件对象&lt;/strong&gt;，目录属于普通文件，对目录和文件可以实施同样的操作&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一个超级块对应一个文件系统，系统中可能一类文件系统有多个超级块，所有的超级块对象都以双向循环链表的形式链接在一起，其一起开始是存放于磁盘上，&lt;strong&gt;内核对文件系统进行初始化和注册时会在内存中分配超级块，&lt;/strong&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;s_fs_info&lt;/code&gt;就指向具体文件系统的超级块，因为经常被操作会放入内存中。&lt;/p&gt;

&lt;p&gt;文件名是可以随意修改的，但索引结点对文件是唯一的，随着文件的存在而存在，具体文件系统的索引结点是静态地存放于磁盘上的，要使用前必须先调入内存，填写VFS的索引结点，索引结点中存有指向&lt;code class=&quot;highlighter-rouge&quot;&gt;file_opration&lt;/code&gt;的指针。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;目录项对象代表的是逻辑意义上的文件&lt;/strong&gt;，在磁盘上没有对应的映像，一个索引结点可能对应多个目录项对象，一个文件系统中所有目录项结构会被组成哈希表或者一棵树、一个链表，从&lt;strong&gt;为文件访问和文件路径搜索提供可能&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;与进程相关的文件结构&quot;&gt;与进程相关的文件结构&lt;/h3&gt;

&lt;p&gt;系统通过文件描述符（即==用户打开文件表中构建的文件对象指针的数组索引==）来抽象被进程打开的文件，一个进程可以打开多个文件，一个文件可以被多个进程共享，因此&lt;strong&gt;进程通过用户打开文件表来描述所有打开的文件&lt;/strong&gt;，而进程和文件系统的关系通过&lt;code class=&quot;highlighter-rouge&quot;&gt;fs_struct&lt;/code&gt;来描述&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;文件对象，&lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt;结构主要保存了文件位置，通过其&lt;code class=&quot;highlighter-rouge&quot;&gt;dentry&lt;/code&gt;指针间接地&lt;strong&gt;找到该文件的索引结点&lt;/strong&gt;，其会形成一个双向链表，称为系统打开文件表，因此每个文件对象会存放在下列的一个双向链表中：&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;“未使用”文件对象链表，可以用做文件对面的内存缓冲区&lt;/li&gt;
      &lt;li&gt;“正在使用”文件对象链表&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用户打开文件表&lt;code class=&quot;highlighter-rouge&quot;&gt;files_struct&lt;/code&gt;：是进程的私有数据，其表项指向的是file结构即文件对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fs_struct&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;atomic_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;rwlock_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;umask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dentry&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pwd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;alroot&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vfsmount&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rootmnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pwdmnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;alrootmnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;打开文件要在进程和文件之间建立一种连接，&lt;strong&gt;“文件描述符”就唯一标识着这种连接&lt;/strong&gt;，而文件描述符就指向一个文件的上下文即&lt;code class=&quot;highlighter-rouge&quot;&gt;file&lt;/code&gt;结构，通过目录项找到索引结点，同时要把&lt;strong&gt;索引结点从磁盘中读入到内存&lt;/strong&gt;。对文件操作时，就必须&lt;strong&gt;通过索引结点去调用具体文件系统提供的函数&lt;/strong&gt;，而基于磁盘的文件系统只需要调用Linux提供的通用函数&lt;code class=&quot;highlighter-rouge&quot;&gt;generic_file_read()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;generic_file_write()&lt;/code&gt;就可以实现相关操作&lt;/p&gt;

&lt;h2 id=&quot;第九章-设备驱动&quot;&gt;第九章 设备驱动&lt;/h2&gt;</content><author><name>true</name></author><category term="linux" /><category term="C" /><category term="学习" /><summary type="html">Linux操作系统原理与应用笔记</summary></entry><entry><title type="html">操作系统原理</title><link href="http://localhost:4000/2020/07/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html" rel="alternate" type="text/html" title="操作系统原理" /><published>2020-07-21T21:47:00+08:00</published><updated>2020-07-21T21:47:00+08:00</updated><id>http://localhost:4000/2020/07/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86</id><content type="html" xml:base="http://localhost:4000/2020/07/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.html">&lt;h1 id=&quot;操作系统原理&quot;&gt;操作系统原理&lt;/h1&gt;

&lt;h2 id=&quot;第一章-操作系统概述-p9&quot;&gt;第一章 操作系统概述 P9&lt;/h2&gt;

&lt;h3 id=&quot;11--操作系统概念&quot;&gt;1.1  操作系统概念&lt;/h3&gt;

&lt;p&gt;操作系统是系统软件，是用户与计算机之间的接口，基本职能是&lt;strong&gt;控制和管理系统内部的各种资源&lt;/strong&gt;，有效地组织多道程序的运行，&lt;strong&gt;扩充硬件功能&lt;/strong&gt;。从&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;作为扩展机器的操作系统&lt;/strong&gt;把硬件细节与程序员隔离开，实际客户是应用程序&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作为资源管理的操作系统&lt;/strong&gt;的功能是管理系统中的硬件资源和数据、程序等软件资源，控制协调各个程序对这些资源的利用，涉及资源共享的问题。操作系统是计算机系统的资源管理器这种观点占主导地位&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;用户观点：操作系统处于用户和硬件之间，有助于用户使用计算机系统的接口和各种资源&lt;/li&gt;
  &lt;li&gt;系统观点：操作系统是硬件上第一层软件，管理&lt;em&gt;硬件资源和软件资源&lt;/em&gt;的分配问题，是资源分配者
（&lt;em&gt;操作系统要对 IO 设备和用户程序加以控制，防止非法操作，这样看操作系统就是控制程序&lt;/em&gt;）&lt;/li&gt;
  &lt;li&gt;进程管理观点：进程是程序在并发环境中的执行过程&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;与操作系统相关的几种主要寄存器: &lt;strong&gt;用户可编程寄存器以及控制与状态寄存器&lt;/strong&gt;。
&lt;strong&gt;用户可编程寄存器&lt;/strong&gt;是机器语言或者汇编语言可以进行操作的寄存器，如数据、地址、条件码寄存器
&lt;strong&gt;控制与状态寄存器&lt;/strong&gt;可以被处理器用来控制自身操作，或者被有特权的操作系统例程用来控制相关程序的执行。如PC（程序计数器）、IR（指令）、PSW（程序状态字）寄存器等&lt;/p&gt;

&lt;p&gt;CPU能执行的全部指令集合称作&lt;strong&gt;指令系统或指令集&lt;/strong&gt;，&lt;strong&gt;特权指令&lt;/strong&gt;用于操作系统或者其他系统软件，主要用于系统资源的分配和管理；用户使用的是&lt;strong&gt;非特权指令&lt;/strong&gt;，如算术运算和访管指令。&lt;/p&gt;

&lt;p&gt;CPU运行模式：&lt;strong&gt;内核态和用户态&lt;/strong&gt;（与PSW有关）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;中断和异常&lt;/strong&gt;是实施并发的基础，由硬件和软件结合而成，中断来自CPU外，异常来自CPU内&lt;/p&gt;

&lt;p&gt;系统初启的一般过程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;硬件检测&lt;/strong&gt;：BIOS加电进行硬件自检，然后读入系统引导区的程序，并将系统控制权交给引导装入程序&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;加载引导程序&lt;/strong&gt;：其不直接引导操作系统，但能根据盘区划分的信息找到活动分区，然后从其中将引导程序读入内存；&lt;strong&gt;运行引导程序&lt;/strong&gt;，从硬盘中读入其他几个软件，由后者&lt;strong&gt;加载内核&lt;/strong&gt;；内核加载完毕后系统跳到setup程序，在实模式下运行，设置系统参数和显示器；&lt;strong&gt;最后进入保护模式&lt;/strong&gt;跳到内核映像开头，&lt;strong&gt;执行内核初始化&lt;/strong&gt;。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;初始化内核&lt;/strong&gt;：
    &lt;ul&gt;
      &lt;li&gt;第一个阶段是&lt;strong&gt;CPU本身初始化&lt;/strong&gt;：设置内核页表、启动页面映射机制、建立系统第一个进程、初始化内核的全局变量和静态变量、设置中断向量表等；&lt;/li&gt;
      &lt;li&gt;第二个阶段是&lt;strong&gt;系统一些基础设施的初始化&lt;/strong&gt;：设置内存边界、初始化内存页面、设置各种处理程序入口地址、定义系统中最大进程数目、创建init内核线程等&lt;/li&gt;
      &lt;li&gt;第三个阶段是&lt;strong&gt;对上层的初始化&lt;/strong&gt;：初始化外部设备、加载驱动、创建核心线程、初始化文件系统并加载&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;实现用户登录&lt;/strong&gt;：init程序在tty每个端口上都创建一个进程login，用于登录&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;操作系统的构建目标&lt;/strong&gt;：&lt;strong&gt;高效性&lt;/strong&gt;（对软硬件资源合理的调度和分派）、&lt;strong&gt;方便性&lt;/strong&gt;（操作系统对外提供接口，方便用户使用）、&lt;strong&gt;安全性&lt;/strong&gt;（保护信息不被未授权人员使用）、&lt;strong&gt;鲁棒性&lt;/strong&gt;（稳定性、强健性）、&lt;strong&gt;移植性&lt;/strong&gt;（从一个硬件平台到另一个平台时的改动不能过多且要容易实施）&lt;/p&gt;

&lt;p&gt;软件分类：&lt;strong&gt;系统软件&lt;/strong&gt;（操作系统、编译、汇编、链接、数据库、网络程序）、&lt;strong&gt;应用软件&lt;/strong&gt;、&lt;strong&gt;支撑软件&lt;/strong&gt;（辅助软件技术人员从事软件开发的工具）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;操作系统是整个计算机系统的控制管理中心&lt;/strong&gt;，经过软件扩充功能后的机器称为“虚拟机”&lt;/p&gt;

&lt;p&gt;操作系统提供的服务：用户接口、程序执行、IO操作、文件系统管理、出错检测、通信、资源分配、统计、保护。
操作系统的服务方式是&lt;strong&gt;系统调用和系统程序&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;系统调用：一般处于操作系统核心的最高层，CPU执行用户程序中的系统调用时，处理机的状态会从用户态变成核心态，进入操作系统内部；而过程调用只能在用户态下运行，不能进入核心态，系统调用完成了用户态到核心态的转变。系数调用可以大致分为五类：进程控制、文件管理、设备管理、信息维护和通信&lt;/li&gt;
  &lt;li&gt;系统程序：系统程序主要指系统程序包（库函数）中提供的大量系统程序。大概分为六大类：文件管理、状态信息、文件修改、程序设计语言的支持、程序装入和执行、通信。最重要的系统程序是命令解释程序，系统程序是对系统调用功能的集成和应用简化&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;12-操作系统的功能&quot;&gt;1.2 操作系统的功能&lt;/h3&gt;

&lt;p&gt;OS应当具有的五大基本功能：存储管理、进程和处理机管理、文件管理、设备管理、用户接口&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;存储管理&lt;/strong&gt;：用户程序在运行之前要装入内存，&lt;strong&gt;内存是所有运行程序的共享资源&lt;/strong&gt;，存储管理的主要功能为：内存分配、地址映射、内存保护和内存扩充&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;内存分配&lt;/strong&gt;：主要任务是为每道程序按某种策略来分配一定的内存空间，并且接收释放的空间&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;地址映射&lt;/strong&gt;：编写程序时不需要考虑程序和数据要存放在内存的什么位置，CPU在执行用户程序的时候要从内存中取出指令或数据，就必须把逻辑地址转换成内存的物理地址，这叫地址映射需要有硬件支持&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;内存保护&lt;/strong&gt;：不同用户的程序都在内存中，必须保证它们在各自的内存空间中活动，不能相互干扰，不能侵犯其他空间，必须建立内存保护机制。可以设置两个界限寄存器（上界地址和下界地址）&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;&lt;strong&gt;内存扩充&lt;/strong&gt;：逻辑扩充使用虚拟存储技术，一个程序不是全部放在内存中，其余部分放在磁盘上，以后根据程序执行时的要求和内存情况，随机将所需部分调入内存或回收已分配的内存&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;进程和处理机管理&lt;/strong&gt;：&lt;strong&gt;所有用户程序和系统程序都必须在CPU上运行&lt;/strong&gt;，对它的管理直接影响整个系统的性能，主要包括：&lt;strong&gt;作业和进程调度、进程控制、进程同步和进程通信&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;作业和进程调度：用户的计算任务称为&lt;strong&gt;作业&lt;/strong&gt;，程序的执行过程称作&lt;strong&gt;进程&lt;/strong&gt;，&lt;strong&gt;进程是分配和运行处理机的基本单位。&lt;/strong&gt;首先作业经过&lt;strong&gt;作业调度&lt;/strong&gt;，把一批选中的&lt;strong&gt;作业放入内存并为其分配资源&lt;/strong&gt;，&lt;strong&gt;建立相应的进程&lt;/strong&gt;，然后&lt;strong&gt;进程调度&lt;/strong&gt;按一定的算法从就绪进程中&lt;strong&gt;找出一个合适进程在CPU上运行&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;进程控制：进程是系统活动的主体，进程控制包括创建进程、撤销进程、封锁进程、唤醒进程&lt;/li&gt;
      &lt;li&gt;进程同步：多个进程在活动过程中彼此彼此会发生相互依赖或制约等关系，为了保证所有进程都能正常活动就必须设置进程同步机制：分为同步和互斥&lt;/li&gt;
      &lt;li&gt;进程通信：相互合作的进程之间往往需要交换信息，为此系统要提供通信机制&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;文件管理&lt;/strong&gt;：在计算机工作经常要建立文件、打开文件、对文件读写等，所以文件管理功能应该包括：文件存储空间的管理、文件操作的一般管理、目录管理、文件读写管理和存储控制
    &lt;ul&gt;
      &lt;li&gt;文件存储空间管理：系统文件和用户文件存放在磁盘上，需要由文件系统对所有文件以及文件的存储空间进行统一管理：为新文件分配必要的外存空间，回收释放的文件空间&lt;/li&gt;
      &lt;li&gt;文件操作：对文件的创建删除打开关闭等&lt;/li&gt;
      &lt;li&gt;目录管理：目录文件的组织、实现“按名存储”，目录快速查找和文件共享&lt;/li&gt;
      &lt;li&gt;文件读写管理和存取控制：按请求从外存读或者写入外存，防止未授权用户破坏&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;设备管理&lt;/strong&gt;：设备的分配和驱动由OS负责，设备管理的主要功能包括缓冲区管理、设备分配、设备驱动和设备无关性
    &lt;ul&gt;
      &lt;li&gt;缓冲区管理：解决CPU和外设速度不同的问题&lt;/li&gt;
      &lt;li&gt;设备分配：根据请求为用户分配设备&lt;/li&gt;
      &lt;li&gt;设备驱动：实现CPU与通道和外设之间的通信，屏蔽硬件细节&lt;/li&gt;
      &lt;li&gt;设备无关性：用户写的程序（逻辑设备）和实际使用的物理设备无关，由OS映射到物理设备&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;用户接口&lt;/strong&gt;：OS对外提供的多种服务，使用户方便有效地使用计算机硬件和用户程序
    &lt;ul&gt;
      &lt;li&gt;程序接口：也称系统调用，是OS内核和用户程序应用程序的接口，只能在核心态下运行&lt;/li&gt;
      &lt;li&gt;命令行接口：OS与用户的交互界面，输入命令后程序解释这些命令，交给OS内部程序处理&lt;/li&gt;
      &lt;li&gt;图形用户接口：用户利用图形界面工具操作计算机&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;13-操作系统的特征&quot;&gt;1.3 操作系统的特征&lt;/h3&gt;

&lt;p&gt;OS特征为:并发、共享、异步性和抽象性&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;并发：微观上单个进程在CPU上执行，进程交替运行，宏观看是并行&lt;/li&gt;
  &lt;li&gt;共享：资源被多个任务共用，被共享的程序必须是纯码（在执行过程中本身不作任何变化）&lt;/li&gt;
  &lt;li&gt;异步性：进程执行过程中“走走停停”，但在相同初始数据下总能得到同样结果&lt;/li&gt;
  &lt;li&gt;抽象性：把复杂的事情简单化&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;14操作系统的形成和基本类型&quot;&gt;1.4操作系统的形成和基本类型&lt;/h3&gt;

&lt;p&gt;OS的形成和发展：手工操作阶段、早期批处理阶段（联机批处理，脱机批处理）、多道批处理系统、分时系统、实时系统（后三种是传统意义上OS的基本类型）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多道程序设计&lt;/strong&gt;的基本思想是，在内存中同时存放多道程序，在管理程序的控制下交替地执行&lt;/p&gt;

&lt;p&gt;分时系统的特征和优点：同时性、交互性、独立性、及时性&lt;/p&gt;

&lt;p&gt;实时系统的类型：过程控制、信息查询、事务处理系统，其实现可分为软式硬式两种方式&lt;/p&gt;

&lt;h3 id=&quot;15-操作系统的主要结构&quot;&gt;1.5 操作系统的主要结构&lt;/h3&gt;

&lt;p&gt;OS主要有单体结构、层次结构、虚拟机结构、微内核结构和客户-服务器结构&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;单体结构：OS中有大量模块，模块就是完成一定功能的子程序，是构成软件的基本单位&lt;/li&gt;
  &lt;li&gt;层次结构：把模块分为若干层，底层不能调用高层&lt;/li&gt;
  &lt;li&gt;虚拟机结构：最底层是虚拟机监控程序，向上层提供多台虚拟机，虚拟机是裸机硬件的复制品。是通过共享物理机器资源实现的，每台虚拟机可以使用不同的操作系统，在系统调用时陷入自身的操作系统里面，最后的 IO操作由虚拟机监控程序完成&lt;/li&gt;
  &lt;li&gt;微内核结构：把扩展机器功能向上移，操作系统被分为文件服务、进程服务、终端服务或者内存服务，各个服务器在用户态下运行并不直接访问硬件，客户进程通过微内核访问服务，因此微内核在核心态下实现所有操作系统的基本功能：中断处理、进程管理等&lt;/li&gt;
  &lt;li&gt;客户-服务器结构：多用于分布式系统，进程如微内核结构分为两类：服务器和客户进程&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;16-unix--linux-系统的核心结构&quot;&gt;1.6 UNIX | LINUX 系统的核心结构&lt;/h3&gt;

&lt;p&gt;UNIX是多用户、多进程、多任务的分时系统，其分为三层：靠近硬件的底层是内核即UNIX常驻内存部分，核外中间层是shell层，最高层是应用层&lt;/p&gt;

&lt;p&gt;LINUX和UNIX一样多用户和多任务，从结构上看是采用单体结构的操作系统，所有的内核系统功能都包含在一个大型的内核软件之中
&lt;img src=&quot;/assets/image-20200701145205951.png&quot; alt=&quot;image-20200701145205951&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;第二章-进程管理--p42&quot;&gt;第二章 进程管理  P42&lt;/h2&gt;

&lt;h3 id=&quot;21-进程概念&quot;&gt;2.1 进程概念&lt;/h3&gt;

&lt;p&gt;进程和程序的区别：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;动态性：程序是静态的，进程是动态的，程序作为一种软件资源长期保留，而进程是程序的一次执行过程，动态的产生和销毁&lt;/li&gt;
  &lt;li&gt;并发性：进程作为资源申请和调度单位存在，而程序不能作为独立运行的单位并发执行，因为进程不仅包括相应的程序和数据，还有一系列描述其活动的数据结构，能用于CPU调度&lt;/li&gt;
  &lt;li&gt;非对应性：一个程序可以被多个进程共用，一个进程可以在活动中执行若干程序&lt;/li&gt;
  &lt;li&gt;异步性：各个进程在并发执行时会产生互相制约关系，导致前进速度不可预测&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;进程的特征：动态性、并发性、调度性、异步性、结构性&lt;/p&gt;

&lt;h3 id=&quot;22-进程状态描述及组织方式&quot;&gt;2.2 进程状态描述及组织方式&lt;/h3&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;进程映像：程序、数据集合、栈和&lt;strong&gt;PCB&lt;/strong&gt;（进程控制块）&lt;/td&gt;
      &lt;td&gt;栈用来保存过程调用和相互传参的踪迹&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;进程控制块PCB：&lt;strong&gt;进程名PID&lt;/strong&gt;、&lt;strong&gt;状态信息&lt;/strong&gt;、特征信息、&lt;strong&gt;优先级&lt;/strong&gt;、通信信息、&lt;strong&gt;现场保护区&lt;/strong&gt;（中断时保存现场环境）、&lt;strong&gt;资源需求&lt;/strong&gt;、实体信息、族系关系、其他。&lt;/li&gt;
  &lt;li&gt;LINUX中进程控制块为task_struct数据结构，系统维护一个进程向量组task，元素是指向task_struct结构的指针，进程的栈和task_struct数据结构紧密联系
&lt;img src=&quot;/assets/image-20200701200713657.png&quot; alt=&quot;image-20200701200713657&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;LINUX进程状态：运行态、可中断等待态（可被中断唤醒）、不可中断等待态（只能等待资源满足唤醒）、停止态、僵死态（进程被种子但是进程控制块依然保留着）&lt;/p&gt;

&lt;h3 id=&quot;24-线程概念&quot;&gt;2.4 线程概念&lt;/h3&gt;

&lt;p&gt;在现代操作系统中，进程只作为资源拥有者，负责申请和占有所需的全部资源；而参与调度和运行的是线程，线程是进程执行运算的最小单位，即执行处理机调度的基本单位&lt;/p&gt;

&lt;p&gt;线程的组成：每一个线程用于一个Thread结构（线程控制块）
&lt;img src=&quot;/assets/image-20200701224653011.png&quot; alt=&quot;image-20200701224653011&quot; /&gt;&lt;/p&gt;

&lt;p&gt;线程的实现方式 ：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;在用户空间实现，管理线程的工作完全由应用程序完成，每个进程有一个私有的线程表，核心只对进程实施管理；&lt;/li&gt;
  &lt;li&gt;在核心空间实现，核心知道线程的存在并实施管理，线程表和进程表都在核心空间中，线程在创建或者删除一个线程的时候需要使用系统调用，核心可以同时调度同一进程的多个线程&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;25-进程间的同步和互斥&quot;&gt;2.5 进程间的同步和互斥&lt;/h3&gt;

&lt;p&gt;进程间的相互关系主要分为：互斥、同步和通信&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;互斥关系中，并发进程对共享资源的竞争，这些资源称为&lt;strong&gt;临界资源&lt;/strong&gt;，访问临界资源的那段程序称为&lt;strong&gt;临界区&lt;/strong&gt;，简称CS区。进程互斥进入临界区前需要申请，执行后需要退出才能执行其他代码，禁止两个或者两个以上的进程同时进入临界区&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;实现互斥的方法&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;硬件方法：关中断（不响应中断），另一种是设置专用机器指令（测试并上锁）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;软件方法：设置软件锁&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一种更通用的方法：信号量即PV操作原语，信号量是一种设施，在进程间发送信号&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;整形信号量：将信号量定义成一个特殊可共享的整形量，有“忙锁”问题&lt;/li&gt;
      &lt;li&gt;记录型信号量：信号量一般由整形变量和指向PCB的指针组成，信号量的值大于0时表示当前可用的资源数量，小于零则绝对值表示等待使用该资源的进程个数&lt;/li&gt;
      &lt;li&gt;一般应用还分了二值信号量（类似互斥锁 01的值）和一般信号量
具体过程：
&lt;img src=&quot;/assets/image-20200702213402218.png&quot; alt=&quot;image-20200702213402218&quot; /&gt;&lt;/li&gt;
      &lt;li&gt;生产者消费者问题中，应先执行同步信号量P再执行互斥信号量，不能调换顺序不然可能产生死锁&lt;/li&gt;
      &lt;li&gt;读者写者问题，仅在第一个访问数据库的读者才对信号量w执行P操作，最后一个访问的读者才对信号量W进行V操作，隐含读者优先级高于写者&lt;/li&gt;
      &lt;li&gt;哲学家进餐问题，解决死锁有三种方法：最多4人拿、均可用才拿、奇拿左偶拿右&lt;/li&gt;
      &lt;li&gt;理发店问题 P85&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;使用信号量的提示：先确定有几个或者几类进程，确定进程制约关系确定信号量种类，定义信号量含义和初值，编写代码，PV操作要成对出现&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;27-进程通信&quot;&gt;2.7 进程通信&lt;/h3&gt;

&lt;p&gt;互斥和同步机构因交换的信息量少，归结为低级通信，高级进程通信分为三类：共享存储器、管道文件和消息传递&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;共享存储器：在内存中分配一片空间作为共享存储区&lt;/li&gt;
  &lt;li&gt;管道文件：也称管道线，连接两个命令的一个打开文件，一个命令写，一个命令读&lt;/li&gt;
  &lt;li&gt;消息传递：以消息为单位在进程间进行数据交换，有直接通信和间接通信两种方式
    &lt;ul&gt;
      &lt;li&gt;消息缓冲通信（直接通信）：进程发送信息前先向系统申请缓冲区，缓冲区中写入消息，然后将缓冲区连到接收进程的消息队列中，并通知接收者，接受者在自己占用的内存中指定一个接收消息区，接收消息。&lt;/li&gt;
      &lt;li&gt;信箱通信：信箱可以存放一定数量的消息，发送进程将消息送入信箱，接收进程从信箱中取出发给自己的消息，有公有信箱（操作系统创建）、共享信箱（某个进程创建，创建者和共享这可以从中取走发给自己的消息）、私有信箱（用户进程创建，创建者可读，其他进程只能发）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;28-linux系统的进程通信&quot;&gt;2.8 linux系统的进程通信&lt;/h3&gt;

&lt;p&gt;信号亦称为软中断，只有父子进程和进程自身可以应用信号机制通信，也并不是专为进程间通信设置，可以用于内核与进程间通信，内核只能发送不能接收
处理信号的方式：忽略信号、阻塞信号、由进程处理信号、默认由系统处理信号
检测信号的时间：从系统空间返回用户空间之前，进程刚被唤醒的时候&lt;/p&gt;

&lt;h3 id=&quot;210-死锁&quot;&gt;2.10 死锁&lt;/h3&gt;

&lt;p&gt;产生死锁的根本原因是资源有限且操作不当，
产生死锁的四个必要条件：互斥条件、不可抢占条件、占有且申请条件、环路等待条件，
&lt;img src=&quot;/assets/image-20200703212926102.png&quot; alt=&quot;image-20200703212926102&quot; /&gt;
当死锁发送时四个条件一定是同时满足的，任何一个条件不成立，死锁就不会发生&lt;/p&gt;

&lt;p&gt;对待死锁的策略：忽略死锁、死锁预防、死锁避免、死锁检测与恢复
&lt;img src=&quot;/assets/image-20200703214200102.png&quot; alt=&quot;image-20200703214200102&quot; /&gt;&lt;/p&gt;

&lt;p&gt;死锁预防：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;破坏互斥条件：一般不使用，因为某些资源固有属性就是独占性&lt;/li&gt;
  &lt;li&gt;破坏占用且等待条件：预分配，所有进程开始之前就分配所需全部资源；空手申请，只有进程不占有资源时才可以申请资源&lt;/li&gt;
  &lt;li&gt;破坏非抢占条件：一个进程在申请资源时会隐性释放申请前已占有的资源，只有当该进程获得所有申请的资源和被剥夺的资源后才能重新启动。&lt;/li&gt;
  &lt;li&gt;破坏环路等待条件：为资源有序分配序列，确保占用资源时不会形成环路&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;死锁避免：是排除死锁的动态策略，它不限制有关申请资源的命令，而是在实施资源分配前检查，若预测有死锁发生的可能则加以避免。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;银行家算法是死锁避免，允许互斥、占有且申请和不可抢占条件&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;死锁检测：
对单体资源（所有类型的资源只有一个实体），可以将资源分配图中的资源去掉形成只有边的等待图，系统定期搜索等待图中的环路
对多体资源，系统检查未完成的进程是否能满足资源请求，不满足则说明有死锁&lt;/p&gt;

&lt;p&gt;死锁恢复：通过抢占资源、回退执行和杀死进程自动从死锁中恢复，或者直接通知系统管理人员&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;抢占式：临时从资源从占用它的进程中剥夺过来&lt;/li&gt;
  &lt;li&gt;回退执行：系统定期检查进程，出现死锁就让某个占有必要资源的进程回退到前一个检查点，释放占有资源&lt;/li&gt;
  &lt;li&gt;杀死进程：一次终止一个，终止后要进行死锁检测&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;活锁和饥饿：活锁是忙式等待，饥饿是调度问题&lt;/p&gt;

&lt;h2 id=&quot;第三章-处理机调度-p114&quot;&gt;第三章 处理机调度 P114&lt;/h2&gt;

&lt;p&gt;处理机分配由调度和分派两个功能组成，调度是指组织和维护就绪进程，分派是当CPU空闲就从就绪队列中取出PCB将其运行&lt;/p&gt;

&lt;p&gt;调度级别：高级调度（作业调度）从作业中选出若干个作业分配必要的资源；中级调度，内存紧张时将某些进程从内存中移到外存上；低级调度（进程调度）按一定算法将CPU分派给就绪队列中的某一个进程&lt;/p&gt;

&lt;h3 id=&quot;32-作业调度&quot;&gt;3.2 作业调度&lt;/h3&gt;

&lt;p&gt;作业通常分为：提交、后备、执行和完成四种状态，&lt;/p&gt;

&lt;p&gt;作业调度功能&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;记录系统中各个作业的情况，记录在作业的JCB中&lt;/li&gt;
  &lt;li&gt;按照某种调度算法从后备作业队列中挑选，决定接纳多少个作业进入内存&lt;/li&gt;
  &lt;li&gt;为选中的作业分配内存的外设（存储管理和设备管理）&lt;/li&gt;
  &lt;li&gt;为选中的作业创建进程，放入就绪队列中&lt;/li&gt;
  &lt;li&gt;作业结束后善后处理，释放JCB&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;进程调度：使就绪进程获得CPU的控制权&lt;/p&gt;

&lt;p&gt;调度算法的性能评价：1、CPU利用率 	2、吞吐量 	3、带权周转时间	4、就绪等待时间	5、响应时间&lt;/p&gt;

&lt;h3 id=&quot;37-实时调度&quot;&gt;3.7 实时调度&lt;/h3&gt;

&lt;p&gt;静态调度：在系统开始之前作出调度决定，必须在知道有关需要完成的工作和截止时间的情况下才能起作用；（优先级谁速率单调的调度算法，优先级和速率呈线性关系，总是运行优先级最高的进程）![image-20200705201308138]/assets理/image-20200705201308138.png)
动态调度：在运行时做调度决定，不受限制。（最早截止时间优先调度算法，每个进程申请CPU时，表明自己的存放和截止时间等信息，调度程序把所有可运行的进程按截止时间排序，选最紧迫的进程运行）&lt;/p&gt;

&lt;h3 id=&quot;38-linux系统中的进程调度&quot;&gt;3.8 LINUX系统中的进程调度&lt;/h3&gt;

&lt;p&gt;LINUX调度机制主要涉及调度方式、调度策略、调度时机和调度算法&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;调度方式基本采用抢占式优先级的方法&lt;/li&gt;
  &lt;li&gt;调度策略有FIFO RR OTHER（由进程剩余时间配额设置优先级，由nice命令设置优先级）&lt;/li&gt;
  &lt;li&gt;调度时机&lt;img src=&quot;/assets/image-20200705153139397.png&quot; alt=&quot;image-20200705153139397&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;调度算法：抢占式优先级算法&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;39-中断处理&quot;&gt;3.9 中断处理&lt;/h3&gt;

&lt;p&gt;保存现场时有两种方法：集中式保存，在内存的系统区设置一个中断现场保存栈；分散式保存，在每个进程的PCB中设置一个核心栈&lt;/p&gt;

&lt;p&gt;中断优先级：可能某个时刻有多个中断同时出现，在&lt;strong&gt;硬件设计中断响应&lt;/strong&gt;时，必须按各种中断事件的轻重缓急对线路进程排队，&lt;strong&gt;安排中断响应次序&lt;/strong&gt;；而在软&lt;strong&gt;件中处理中断也要排序&lt;/strong&gt;，可以和响应顺序不同，&lt;strong&gt;高级别中断有打断低级别中断处理程序的权利&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;中断屏蔽：中断请求提出后CPU不响应，常常用来防止同级中断的打扰
中断禁止：系统不接受中断信号，不会提出中断请求&lt;/p&gt;

&lt;p&gt;系统调用：陷入和捕俘，所有陷入事件有一个总的服务程序：陷入总控程序，在处理系统调用处理的过程中并不自动关闭中断
&lt;img src=&quot;/assets/image-20200705194459175.png&quot; alt=&quot;image-20200705194459175&quot; /&gt;
具体过程为：陷入总控程序将参数压入系统栈，调用陷入处理程序trap，程序根据陷入事件的不同类型进行不同的处理，对于非法指令、指令故障、转换无效等事件，转入信号机构处理；对于系统调用使用系统调用函数处理&lt;/p&gt;

&lt;h2 id=&quot;第四章-存储管理---p149&quot;&gt;第四章 存储管理   P149&lt;/h2&gt;

&lt;h3 id=&quot;41-地址空间与重定位&quot;&gt;4.1 地址空间与重定位&lt;/h3&gt;

&lt;p&gt;程序装入内存有三种方式&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;绝对装入：程序中使用的所有地址都是内存绝对地址，程序装入到内存的指定位置&lt;/li&gt;
  &lt;li&gt;可重定位装入：程序中根据内存当时的使用情况，决定存放到内存的位置，程序使用相对地址&lt;/li&gt;
  &lt;li&gt;动态运行时装入：装入内存的程序可以换到磁盘，需要时再换入内存中，需要硬件支持&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;静态重定位：由装入程序对目标程序中的指令和数据的地址进行修改，执行过程中不再改动
动态重定位：在程序执行期间，每次访问内存之前都要进行重定位，靠硬件地址转换机构实现，通常采用一对重定位寄存器，一个存放程序在内存的初始地址（基址寄存器）另一个表示程序的逻辑地址最大范围（限长寄存器），都为特权寄存器&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;UNIX&lt;/td&gt;
      &lt;td&gt;LINUX 中对内存管理还利用了多道程序对换技术（中级调度），内存中保留多个进程，当内存空间紧张则把某些进程换出到外存中。&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;42-分区技术&quot;&gt;4.2 分区技术&lt;/h3&gt;

&lt;p&gt;内存一开始为一大块，各个分区在相应进程进入内存时才建立，大小和进程大小相同，在进程完成后就释放所占分区，系统尝试将其与邻接的空闲分区合并起来，成为一个大分区&lt;/p&gt;

&lt;p&gt;动态分区法常用于记录内存使用情况的数据结构有：空闲分区表和分区链	P159
分配算法有：最先适应算法、最佳适应算法、循环适应算法和最坏使用算法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;最先适应：分区表按位置排列，先找到满足的空闲区就直接分配，释放内存时就根据分区表合并上下空闲区，如果无相连空闲区，则新建并插入分区表&lt;/li&gt;
  &lt;li&gt;最佳适应：以空闲区大小为序，从小到大，同样想找到先分配，划分后有剩余则修改分区大小和重新确定空闲区在表中位置&lt;/li&gt;
  &lt;li&gt;循环适应：和最先使用一样，但每次找到合适的空闲区后就记录，下次查找空闲区从记录位置的下一个空闲分区开始找&lt;/li&gt;
  &lt;li&gt;最坏适应：从大到小排，利用划分后剩余的分区来减少碎片&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;采用分区技术需要有硬件保护，通常由一对寄存器分别表示用户进程在内存空间中的上下界&lt;/p&gt;

&lt;h3 id=&quot;43-分页技术&quot;&gt;4.3 分页技术&lt;/h3&gt;

&lt;p&gt;分区和对换技术都要求把一个进程放置在一片连续的内存区域，而分页允许程序存储空间不连续，从而解决外部碎片的问题，提高内存利用率&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;逻辑空间分页、内存空间分块&lt;/strong&gt;，块大小和页面大小相同。分页情况下，系统以块作为单位把内存分给各个进程，&lt;strong&gt;进程的每个页面对应一个内存块&lt;/strong&gt;，为了找到每个页面在内存中对应的物理块，系统为&lt;strong&gt;每一个进程设立了一张页面映射表&lt;/strong&gt;，操作系统通过&lt;strong&gt;建立内存块表&lt;/strong&gt;管理整个内存&lt;/p&gt;

&lt;p&gt;为了解决放置页表带来的存取速度下降的问题，可以设置一个高速联想存储器快表，快表包含键（页号）和值（块号）&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;页的共享&lt;/strong&gt;：只有只读的页可以共享，而且通常因为系统分页情况是用户不可见的，会把私有数据和可共享数据混杂到同一个页，不容易实现共享&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;页的保护&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;利用页表本身进行保护：页表基址信息放在进程的PCB中，访问内存要利用页表进行地址转换，各进程在自己的存储空间内活动&lt;/li&gt;
  &lt;li&gt;设置存储控制位：在页表表现设置存取控制字段，指明块的内容允许何种操作&lt;/li&gt;
  &lt;li&gt;设置合法标志：非法时表示该页不在该进程的逻辑地址空间中&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;页表构造&lt;/strong&gt;（为了节省内存空间，需要动态调入页表）&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;多级页表&lt;/strong&gt;：用来防止一级页表过大，进程只保留部分页表，剩下的页表动态调入到内存中&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;散列页表&lt;/strong&gt;，处理&lt;strong&gt;大于32位地址空间的通用方式&lt;/strong&gt;，表中每一项有一个链表，由页号、对应的内存块号和指向下一个元素的指针组成&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;倒置页表&lt;/strong&gt;，用于64位虚拟地址空间在处理器上的应用，系统中只有一个页表，每个内存块对应唯一的表项，表项由进程标识符和虚拟页号组成，&lt;strong&gt;访问地址时用PID和页号查询块号&lt;/strong&gt;，如果找不到，则此页未调入内存，产生请求调页中断，如果还没有，则地址错误&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;44-分段技术&quot;&gt;4.4 分段技术&lt;/h3&gt;

&lt;p&gt;将用户程序分成若干相对独立的部分，每段从0开始编址，并采用一段连续的地址空间
程序地址结构：整个进程的地址空间分成多个段，&lt;strong&gt;逻辑地址分成段号S和段内地址d&lt;/strong&gt; ，段的信息的逻辑单位，用于可以知道自己的程序分成几段以及相应的功能&lt;/p&gt;

&lt;p&gt;段表和段表地址寄存器，一个进程的全部段都在该进程的段表中登记，系统还有一个段表地址寄存器，一部分指出段表在内存中的起始地址；另一部分指出段表的长度，主要用于段寻址和越界检测&lt;/p&gt;

&lt;p&gt;段的保护&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;存取控制：在段表中记录本段允许的操作，可读、可写、可读写&lt;/li&gt;
  &lt;li&gt;段表本身的保护：利用段表地址寄存器判断访问空间&lt;/li&gt;
  &lt;li&gt;保护环：&lt;img src=&quot;/assets/image-20200706121144806.png&quot; alt=&quot;image-20200706121144806&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;45-段页式结合系统&quot;&gt;4.5 段页式结合系统&lt;/h3&gt;

&lt;p&gt;分页存储管理能提高内存利用率，分段存储可以满足用户需求，两者结合可以“各取所长”&lt;/p&gt;

&lt;p&gt;段页式存储管理的基本原理：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;等分内存：把内存分成大小相等的内存块&lt;/li&gt;
  &lt;li&gt;进程地址空间采用分段：吧进程的程序和数据分成若干段，每段一个段名&lt;/li&gt;
  &lt;li&gt;段内分页：把每段分成若干页，页面大小和内存块相同&lt;/li&gt;
  &lt;li&gt;逻辑地址结构：由段号、段页页号和页内地址组成&lt;/li&gt;
  &lt;li&gt;内存分配：内存分配单位为块&lt;/li&gt;
  &lt;li&gt;段表、页表和段表地址寄存器：系统为每个进程建立一个段表，为每一个段建立一个页表。因此段表中不再是段长和内存地址，而是页表长和页表地址&lt;/li&gt;
&lt;/ol&gt;

&lt;blockquote&gt;
  &lt;p&gt;实现的具体过程为：&lt;img src=&quot;/assets/image-20200706122333059.png&quot; alt=&quot;image-20200706122333059&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;46-虚拟存储器&quot;&gt;4.6 虚拟存储器&lt;/h3&gt;

&lt;p&gt;虚存特征
虚拟扩充：不是扩大物理空间，而是扩充逻辑内存容量
部分装入：进程不是一次性全部装入内存，而是将当前运行需要用到的那部分程序和数据装入内存中
离散分配：一个进程在内存的部分可能散布在内存的不同地方，避免浪费也为动态调入提供了方便
多次对换：一个进程运行期间，它所需的全部程序和数据分成多次调入内存&lt;/p&gt;

&lt;h3 id=&quot;47-请求分页&quot;&gt;4.7 请求分页&lt;/h3&gt;

&lt;p&gt;页表结构
&lt;img src=&quot;/assets/image-20200706143040143.png&quot; alt=&quot;image-20200706143040143&quot; /&gt;&lt;/p&gt;

&lt;p&gt;抖动是指，如果置换算法不合适，可能出现刚换出的页面又很快被访问，系统大部分时间用在页面调度和传输上，实际效率太低&lt;/p&gt;

&lt;p&gt;页面置换算法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;先进先出、最佳置换、最近最久未使用&lt;/li&gt;
  &lt;li&gt;第二次机会置换法：查看引用位，被引用过为1则视为刚装入，并把引用位清零，继续寻找引用位为0的页&lt;/li&gt;
  &lt;li&gt;时钟置换法：是对第二次机会置换法的改进，使用循环链表![image-20200706153036986]/assets理/image-20200706153036986.png)&lt;/li&gt;
  &lt;li&gt;最近未使用：启动进程时所有页的引用位和修改位都置成0，引用位会定期清0![image-20200706153222897]/assets理/image-20200706153222897.png)
过程为，从当前指针指向的位置开始查找循环队列（结构和时钟算法一样），先找第一类，不满足则再找第二类，第二类也不满足则把引用位都清0&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;48-内存块分配和抖动问题&quot;&gt;4.8 内存块分配和抖动问题&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;内存最少块数：每个进程需要有最少的内存块数，分配的总块数不能超过可用块的总量&lt;/li&gt;
  &lt;li&gt;内存块分配策略：固定分配，给进程分配的内存块数是固定的，缺页时只能从分给该进程的内存块中进行页面置换；可变分配，如果进程运行持续缺页率较高，则多分内存块&lt;/li&gt;
  &lt;li&gt;页面置换范围：全局置换，运行一个进程从全部内存中选取淘汰的内存块；局部置换，只能置换分给进程的那一组，全局置换只能和可变分配策略相结合&lt;/li&gt;
  &lt;li&gt;分配内存块的算法：等分法、比例法（依照进程的地址空间）和优先权法（依照进程的优先级）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;防止抖动的方法：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;采用局部置换：当进程出现抖动时，其不能从另外的进程那里获得内存块，使抖动局限在一个小范围，但未解决抖动&lt;/li&gt;
  &lt;li&gt;挂起某些进程：腾出内存空间给抖动进程使用&lt;/li&gt;
  &lt;li&gt;采用缺页频度发：如果缺页率太高则给进程更多内存块，控制缺页率&lt;/li&gt;
  &lt;li&gt;利用工作集：程序往往具有局部性，&lt;strong&gt;时间局部性&lt;/strong&gt;，某条指令刚被执行后，往往很快又被执行（循环顺序）；&lt;strong&gt;空间局部性&lt;/strong&gt;，某个位置被访问，它附近的位置也要被访问（数组结构）
工作集就是一个进程在某一小段时间内访问页面的集合，工作集大小WSSi 与时间间隔d有关，如果d过小则不能反映工作集缓慢变化，如果d太大则不体现局部的效果
有公式 $D=\sum^n_{i=1}WSS_i$ ，其中D是系统中全部进程的总请求量，D大于可以的内存块总量m表示将出现抖动&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;49-请求分段&quot;&gt;4.9 请求分段&lt;/h3&gt;

&lt;p&gt;段式虚存可以实现动态链接技术，使用&lt;em&gt;间接编址&lt;/em&gt;和&lt;em&gt;链接故障指示&lt;/em&gt;两个硬件设施,间接地址是指存放直接地址的地址,链接故障指示检查时，如果段未链接上，硬件会产生链接中断&lt;img src=&quot;/assets/image-20200706170646674.png&quot; alt=&quot;image-20200706170646674&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;410-linux系统的存储管理技术&quot;&gt;4.10 linux系统的存储管理技术&lt;/h3&gt;

&lt;p&gt;采用了和UNIX一样的&lt;strong&gt;请求分页存储管理&lt;/strong&gt;技术和&lt;strong&gt;对换技术&lt;/strong&gt;。页面置换使用LRU，管理用位图和链表结构&lt;/p&gt;

&lt;h2 id=&quot;第五章-文件系统-p207&quot;&gt;第五章 文件系统 P207&lt;/h2&gt;

&lt;h3 id=&quot;51-文件及其分类&quot;&gt;5.1 文件及其分类&lt;/h3&gt;

&lt;p&gt;文件是从存储设备抽象出来的被命名的相关信息的集合体，通常存放在外存中。&lt;/p&gt;

&lt;p&gt;文件类型按用途分类&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;系统文件：操作系统和其他系统程序信息组成的文件，只能通过系统调用为用户服务&lt;/li&gt;
  &lt;li&gt;库文件：由标准子程序和常用的应用程序组成的文件，允许用户使用但不能修改&lt;/li&gt;
  &lt;li&gt;用户文件：由用户保存管理的文件，可以被创建者或者被授权者进行操作&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;按数据形式分类：源文件、目标文件（编译后未链接）、可执行文件（编译链接）
按存储权限分类：只读文件、读写文件和可执行文件
按保存时间分类：临时文件和永久文件&lt;/p&gt;

&lt;p&gt;在UNIX和Linux中按文件的内部构造和处理方式分类：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;普通文件：内部没有固定结构，由程序、数据活文本的字符串构成&lt;/li&gt;
  &lt;li&gt;目录文件：由下属文件的目录项构成的文件，可进行读写等操作&lt;/li&gt;
  &lt;li&gt;特殊文件：特指各种外部设备，系统把IO设备作为文件对待，进行统一管理![image-20200707103847223]/assets理/image-20200707103847223.png)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;普通文件分为&lt;strong&gt;文本文件&lt;/strong&gt;（ASCII文件）和&lt;strong&gt;二进制文件&lt;/strong&gt;，二进制文件有内部结构，在UNIX和Linux中有五个区，&lt;strong&gt;文件头、正文段、数据段、重定位区和符号表区&lt;/strong&gt;，&lt;strong&gt;文件头结构&lt;/strong&gt;由标志可执行文件特征的&lt;strong&gt;幻数、正文段长度、数据段长度、BSS段长度、符号表的长度和入口单元及各种标志&lt;/strong&gt;组成，重定位时利用重定位区，而符号表用于调试程序&lt;/p&gt;

&lt;p&gt;文件抽象最重要的特性是“按名”管理对象，&lt;strong&gt;用户对文件也是“按名存取”&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;文件系统是OS负责操纵和管理文件的一套系统&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;文件管理：创建删除、打开关闭、读写执行一个文件&lt;/li&gt;
  &lt;li&gt;目录管理：为每个文件建立一个文件目录项，若干文件的目录项构成一个目录文件，根据用户要求创建或者删除目录文件、对用户指定文件进行检索和权限验证、更改工作目录等&lt;/li&gt;
  &lt;li&gt;文件存储空间管理：对文件的存储空间分配与回收，并为文件逻辑结构与物理地址建立映射&lt;/li&gt;
  &lt;li&gt;文件的共享和保护：在系统控制下使用户能共享其他用户的文件，防止对文件的未授权访问或破坏&lt;/li&gt;
  &lt;li&gt;提供方便的接口：为用户提供统一的文件存取方式，实现“按名存取”，OS为用户提供有关文件操作的系统调用，给用户编程使用&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;52-文件的逻辑组织和物理组织&quot;&gt;5.2 文件的逻辑组织和物理组织&lt;/h3&gt;

&lt;p&gt;逻辑组织有无结构文件和有结构文件两种&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;无结构文件&lt;/strong&gt;是有一组相关信息组成的有序字符流，OS并不关心文件中存放的内容是什么，其看到的都是一个一个的字节，具体内容由用户级程序解释；&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;有结构文件&lt;/strong&gt;，又称记录型文件，文件是由若干相关记录组成的，每个记录是一组相关的数据集合（具体类似于JSON文件），用于描述一个对象某个方面的属性，如年龄、姓名等。分为&lt;strong&gt;定长和变长记录文件&lt;/strong&gt;两种&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;存取方式分为顺序存取和随机存取，顺序存取严格按照字符流或记录的排序依次存取，随机存取这允许用户随意存取文件中的一个记录
随机存取基于磁盘的文件存取模式，对于定长记录文件，随机存取把文件视为一系列编号上的块或记录，通常每块的大小是一样的，被操作系统作为最小的定位单位&lt;img src=&quot;/assets/image-20200707112455757.png&quot; alt=&quot;image-20200707112455757&quot; /&gt;&lt;/p&gt;

&lt;p&gt;文件的物理组织&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;连续文件：把逻辑上连续的文件信息存放在连续编号的物理块中，如定长文件大小为2000，假设一个物理块大小为512，文件需要占用4块&lt;/li&gt;
  &lt;li&gt;链接文件：逻辑连续的文件分散存放在不同物理块中，为各个物理块设置链接字，指示该文件的下一个物理块，系统维护一个文件分配表，每个文件都在表中独占一项，其中包括了文件名、起始块号和最后块号&lt;/li&gt;
  &lt;li&gt;索引文件：系统为每一个文件建立索引表，表项指出存放该文件的各个物理块号，索引表也存放在一个盘块中，由文件目录项指出索引盘块地址&lt;/li&gt;
  &lt;li&gt;多重索引
&lt;img src=&quot;/assets/image-20200707120150760.png&quot; alt=&quot;image-20200707120150760&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;53-文件控制块和文件目录&quot;&gt;5.3 文件控制块和文件目录&lt;/h3&gt;

&lt;p&gt;文件系统内部给每个文件唯一地设置一个文件控制块，核心利用该结构进行管理时，首先会验证权限&lt;img src=&quot;/assets/image-20200707120759771.png&quot; alt=&quot;image-20200707120759771&quot; /&gt;&lt;/p&gt;

&lt;p&gt;UNIX和Linux中该结构称为 &lt;strong&gt;i 节点&lt;/strong&gt;，i 节点分为&lt;strong&gt;静态和动态&lt;/strong&gt;两种，&lt;strong&gt;静态在磁盘上&lt;/strong&gt;，&lt;strong&gt;动态在内存中&lt;/strong&gt;，每个文件对应一个唯一的静态 i 节点，而&lt;strong&gt;每个打开的文件都有一个对应的动态 i 节点&lt;/strong&gt;，只有动态 i 节点才有节点号，&lt;strong&gt;节点号是唯一的，指向静态 i 节点&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;文件目录是文件控制块的有序集合，完全由目录项组成的文件称为目录文件
目录结构有：单级目录、二级目录（多了用户目录）、树形目录（多级目录）、非循环图目录（带链接的树形结构）&lt;/p&gt;

&lt;h3 id=&quot;54-文件存储空间管理&quot;&gt;5.4 文件存储空间管理&lt;/h3&gt;

&lt;p&gt;空闲空间管理技术有：空闲空间表法、空闲块链接法、位示图法和空闲块成组链表法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;空闲块成组链表法：把所有空闲盘块按固定数量分组，如50个空闲块为一组，组中第一块为组长块，第一组的50个空闲块块号放在第二组的组长块中……最后一个块（可能不到50块）放在文件系统超级块中的空闲块号栈里
&lt;img src=&quot;/assets/image-20200707150841716.png&quot; alt=&quot;image-20200707150841716&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/image-20200707150951550.png&quot; alt=&quot;image-20200707150951550&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;第一个块中的警戒位&lt;img src=&quot;/assets/image-20200707151034622.png&quot; alt=&quot;image-20200707151034622&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;57-linux文件系统&quot;&gt;5.7 linux文件系统&lt;/h3&gt;

&lt;p&gt;每个进程有两个数据结构来描述进程与文件的相关信息，一个是fs_struct 指向两个VFS索引节点，分别是根目录节点和当前目录节点；另一个是files_struct（进程文件描述符表） 保存该进程打开文件的有关信息，其中的指针指向对应的 file 结构（打开文件描述表表）&lt;img src=&quot;/assets/image-20200707174255641.png&quot; alt=&quot;image-20200707174255641&quot; /&gt;
进程文件描述符表让各个进程掌握它当前使用文件的情况，不要同时打开太多文件，并加速对文件的查找速度
核心设置打开文件表的原因是，一个文件可以被多个进程打开&lt;/p&gt;

&lt;h2 id=&quot;第六章设备管理-p254&quot;&gt;第六章设备管理 P254&lt;/h2&gt;

&lt;h3 id=&quot;61-设备管理概述&quot;&gt;6.1 设备管理概述&lt;/h3&gt;

&lt;p&gt;设备分类
按工作特性分为存储设备和输入输出设备两大类，有个别不符合这两类的，如时钟&lt;/p&gt;

&lt;p&gt;按设备使用性质分为独占设备（只能一个进程独占）、共享设备（多个进程同时共用）和虚拟设备（利用某种技术吧独占设备改造成多个进程共用的设备）&lt;/p&gt;

&lt;p&gt;按数据传输方式分为串行设备（二进制位一位一位顺序传送）和并行设备（8位数据同时通过并行线进行传送的设备）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image-20200707230032772.png&quot; alt=&quot;image-20200707230032772&quot; /&gt;&lt;/p&gt;

&lt;p&gt;设备标识：OS为每台设备分配一个唯一&lt;strong&gt;设备绝对号用于区分和识别设备&lt;/strong&gt;，UNIX和Linux中每个块设备的名字由两部分组成：&lt;strong&gt;主设备号和次设备号&lt;/strong&gt;。
多道程序环境中，写程序时使用的是主设备号（&lt;strong&gt;设备的类型号&lt;/strong&gt;），而次设备号表示同类设备的&lt;strong&gt;相对序号&lt;/strong&gt;，用户程序只知道使用设备的类型，具体使用哪一台由系统分配，&lt;strong&gt;OS负责进行“地址转换”，将类型号变成设备绝对号&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;io-系统结构主机io系统和微型机io系统&quot;&gt;IO 系统结构：主机IO系统和微型机IO系统&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;主机IO系统&lt;/strong&gt;
&lt;img src=&quot;/assets/image-20200707230936399.png&quot; alt=&quot;image-20200707230936399&quot; /&gt;
通道相当于小型处理机，独立执行通道程序，对外部设备的IO操作进行控制，实现内存和外设之间的数据传输，主机委托的IO处理完成后，通道发出中断信号，请求CPU处理使CPU和外设并行效率提升&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;主机IO系统的通道&lt;/strong&gt;三种类型&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;字节多路通道：以字节为信息传输单位，服务于多台低速IO设备，当通道为一台设备传输一个字节后立刻转向为下一台设备传送字符，交叉控制下属各个设备的工作&lt;/li&gt;
  &lt;li&gt;选择通道：同一时间只能为一台设备服务，连续地传输一批数据，主要用于连接高速外部设备&lt;/li&gt;
  &lt;li&gt;成组多路通道：广泛用于连接高速和中速设备，结合了字节多路通道分时操作和选择通道高速传送的优点，允许多个通道程序在同一IO通道中并行，每执行完一条通道指令就转向另一通道程序，任意时刻只能为一个设备服务但又能立刻切换到下一个通道&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;微型机IO系统&lt;/strong&gt;
大多使用总线IO系统结构，实现CPU和控制器之间的通信
&lt;img src=&quot;/assets/image-20200707232242950.png&quot; alt=&quot;image-20200707232242950&quot; /&gt;
IO设备一般有机械和电子两部分组成，&lt;strong&gt;电子部分称为设备控制器或适配器&lt;/strong&gt;，可以&lt;strong&gt;管理端口、总线或设备，实现设备主体和主机间的连接与通信&lt;/strong&gt;，一台设备控制器可以控制多台同一类型的设备，&lt;strong&gt;控制器是可编址的设备，OS常常通过控制器实施对设备的控制和操作&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;io系统的控制方法&quot;&gt;IO系统的控制方法&lt;/h4&gt;

&lt;p&gt;程序控制直接传递方式，程序查询方式，中断控制方式，直接存储器访问方式，独立通道方式，IO处理器方式&lt;/p&gt;

&lt;h5 id=&quot;直接存储器访问方式dma&quot;&gt;直接存储器访问方式DMA&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;/assets/image-20200707234317228.png&quot; alt=&quot;image-20200707234317228&quot; /&gt;
	DMA传送操作：DMA包括内存地址寄存器、字节计数寄存器、一个或多个控制寄存器，控制寄存器指明所用的端口、传送方向（读还是写）、传送的单位（一个字节或者字），本次传送的字节数，CPU可以读写这些寄存器&lt;/p&gt;

&lt;p&gt;​	DMA工作过程：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CPU把一个DMA命令块写入内存&lt;/strong&gt;，命令包含传送数据的源地址、目的地址和传送字节数，然后&lt;strong&gt;把该块地址写入到DMA控制寄存器中&lt;/strong&gt;，CPU&lt;strong&gt;向磁盘控制器发送读盘命令&lt;/strong&gt;，然后CPU处理其他任务，当&lt;strong&gt;有效数据存入到磁盘控制器的缓冲区中后开始DMA存取&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DMA控制器启动数据传送，通过总线向磁盘控制器发送读盘请求，读数据到指定内存单元中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;img src=&quot;/assets/image-20200707235201907.png&quot; alt=&quot;image-20200707235201907&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;某些DMA可以每次一字或者整块传送
&lt;img src=&quot;/assets/image-20200707235721294.png&quot; alt=&quot;image-20200707235721294&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;缓冲技术&quot;&gt;缓冲技术&lt;/h4&gt;

&lt;p&gt;为了解决CPU和IO设备速度不匹配的矛盾，提高CPU和IO设备的并行性
可设置为硬缓冲和软缓冲（从内存中开辟区域做缓冲区，缓冲区大小一般与盘块大小一样）
可设置单缓冲、双缓冲或多缓冲
&lt;img src=&quot;/assets/image-20200708001716335.png&quot; alt=&quot;image-20200708001716335&quot; /&gt;
&lt;img src=&quot;/assets/image-20200708001800311.png&quot; alt=&quot;image-20200708001800311&quot; /&gt;
在多缓冲基础上可以构造循环缓冲或缓冲池，有两个指针：一个指向缓冲区中数据第一个字，一个指向首个空闲区位置。为了提高缓冲区利用率，往往采用公用缓冲池的方式，池中的缓冲区可以供多个进程使用&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;设备管理的功能&quot;&gt;设备管理的功能&lt;/h4&gt;

&lt;p&gt;设备管理的目标：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;使用方便：屏蔽物理特性，按统一规则使用设备，OS负责输入输出工作&lt;/li&gt;
  &lt;li&gt;设备独立性：OS分配实际设备，程序只关心设备类型&lt;/li&gt;
  &lt;li&gt;效率高：利用通道和缓冲提高CPU和IO设备的并行性&lt;/li&gt;
  &lt;li&gt;管理统一：对各种外设采用统一的管理方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为实现目标所需的功能：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;监视设备状态：记住所有设备、控制器和通道的状态，以便有效管理和调度使用&lt;/li&gt;
  &lt;li&gt;进行设备分配：按类型和分配算法实施设备分配&lt;/li&gt;
  &lt;li&gt;完成IO操作：OS按用户的要求调用具体设备驱动程序，进行IO操作并处理中断&lt;/li&gt;
  &lt;li&gt;缓冲管理和地址转换&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;62-分配技术和spooling系统&quot;&gt;6.2 分配技术和SPOOLing系统&lt;/h3&gt;

&lt;p&gt;设备分配的相关因素有：IO设备的固有属性、os采用的分配算法、分配应防止死锁发生、用户程序使用的逻辑设备和物理设备无关&lt;/p&gt;

&lt;p&gt;设备分配技术：独占分配、共享分配和虚拟分配（SPOOLing系统）&lt;/p&gt;

&lt;p&gt;分配算法：先来先服务，优先级高的优先服务&lt;/p&gt;

&lt;p&gt;SPOOLing系统一般分为存输入、取输入、存输出、取输出
&lt;img src=&quot;/assets/image-20200708103344372.png&quot; alt=&quot;image-20200708103344372&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;63-io-软件构造&quot;&gt;6.3 IO 软件构造&lt;/h3&gt;

&lt;p&gt;IO软件系统的层次：
为了实现设备独立性、统一命名、出错控制和同步（阻塞）异步（中断驱动）处理
&lt;img src=&quot;/assets/image-20200708113352464.png&quot; alt=&quot;image-20200708113352464&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总体过程
&lt;img src=&quot;/assets/image-20200708120656311.png&quot; alt=&quot;image-20200708120656311&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&quot;设备驱动程序&quot;&gt;设备驱动程序&lt;/h4&gt;

&lt;p&gt;功能：接收上层与设备无关的读写请求，IO请求排在请求队列队尾；取出请求队列队首请求，并将设备分配给它；想设备控制器发送命令，完成IO操作；处理来自设备的中断&lt;/p&gt;

&lt;p&gt;设备驱动程序在系统中的逻辑位置
&lt;img src=&quot;/assets/image-20200708111122729.png&quot; alt=&quot;image-20200708111122729&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;与设备无关的操作系统io软件&quot;&gt;与设备无关的操作系统IO软件&lt;/h4&gt;
&lt;p&gt;基本功能是执行所有驱动器共同的IO功能和为用户级软件提供统一接口，所有驱动程序都有相同的接口，新驱动程序遵守接口规则，这样很容易加入操作系统
&lt;img src=&quot;/assets/image-20200708113208607.png&quot; alt=&quot;image-20200708113208607&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;设备驱动程序的统一接口：
与接口相关的问题是IO设备如何命名，设备无关软件负责把符号设备名映像到相应的设备，每个设备指定唯一的一个特殊文件 i 节点，包含主设备号和次设备号，主设备号用来确定相应的驱动程序，次设备号作为传递给驱动程序的参数。还有保护问题，系统管理员可为每台设备规定权限&lt;/li&gt;
  &lt;li&gt;出错报告：很多错误与设备相关，需要由相应的驱动程序处理，但出错处理的架构与设备无关
错误产生的原因：&lt;strong&gt;一类是程序错误&lt;/strong&gt;，如把信息写到输入设备上（键盘）、提供的参数错误、指定设备不合法等，处理方法是&lt;strong&gt;直接向调用者报告&lt;/strong&gt;；一类是&lt;strong&gt;实际IO错误&lt;/strong&gt;，如把信息写到坏块中、从关机的设备中读信息，此时&lt;strong&gt;驱动程序可以向设备无关软件报告&lt;/strong&gt;，
&lt;img src=&quot;/assets/image-20200708115618746.png&quot; alt=&quot;image-20200708115618746&quot; /&gt;&lt;/li&gt;
  &lt;li&gt;分配和释放独占设备：处理的简单方法是让进程打开设备特殊文件，如果设备不可用则打开失败，以后通过关闭独占设备释放它；另一种方法是设立专门机制，&lt;strong&gt;负责独占设备的申请和释放&lt;/strong&gt;，设备不可用则阻塞调用者，&lt;strong&gt;进程放入阻塞队列，当申请设备可用时，阻塞队列第一个进程使用它&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;提供与设备无关的块大小&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;用户空间的io软件&quot;&gt;用户空间的IO软件&lt;/h4&gt;

&lt;p&gt;以库函数的形式出现，如printf、scanf等函数，编译链接后放入内存，运行时利用系统调用进入到操作系统，由OS接收用户的IO请求，提供相应服务。由于把设备当成特殊文件处理，对设备的访问变成了对文件的访问，输入输出管理就是打开关闭、读写和查找文件&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image-20200708122001236.png&quot; alt=&quot;image-20200708122001236&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;64-磁盘调度和管理&quot;&gt;6.4 磁盘调度和管理&lt;/h3&gt;

&lt;p&gt;磁盘硬件：磁头，柱面，扇区；
现代磁盘驱动器提供给操作系统的是虚拟的几何参数，到操作系统提出寻道请求时，再由磁盘控制器把请求的参数重新映射成实际磁道地址，也就是磁盘的逻辑地址是由逻辑块组成的一维数组，文件系统读写某个文件时，由逻辑块号映射成物理块号，再由磁盘驱动程序转换成磁盘地址，再由磁盘控制器把磁盘地址定位到具体的磁盘物理地址。&lt;/p&gt;

&lt;h3 id=&quot;65-linux系统设备管理&quot;&gt;6.5 Linux系统设备管理&lt;/h3&gt;

&lt;p&gt;Linux系统中硬件设备分为：块设备、字符设备和网络设备&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/image-20200708125118694.png&quot; alt=&quot;image-20200708125118694&quot; /&gt;
&lt;strong&gt;设备转接表是文件系统和设备驱动程序之间的接口&lt;/strong&gt;，每类设备在转接表中都占有一项，&lt;strong&gt;转接表中记录了对该类设备执行操作的各个子程序的入口地址&lt;/strong&gt;，连接表在系统初启时根据硬件配置情况建立，&lt;strong&gt;系统只有这两个设备转接表&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;硬件和驱动程序之间的接口是通过相关控制寄存器或操纵设备的IO指令及中断向量组成的&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Linux系统的缓冲技术&lt;/strong&gt;：使用多重缓冲技术来平滑和加快文件信息从内存到磁盘的传输
&lt;img src=&quot;/assets/image-20200708130519127.png&quot; alt=&quot;image-20200708130519127&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;块设备管理&lt;/strong&gt;
磁盘块的读写方式，读有立即读和预读两种，写有立即写、异步写和延迟写&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;上述读写的实现机制&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;系统中有一个描述一系列在系统中登记的块设备的结构，使用主设备号作为索引，还包括了指向有关操作的函数指针，其是连接抽象的块设备操作与具体块设备类型操作之间的枢纽（实现块设备转接表功能）&lt;/p&gt;</content><author><name>true</name></author><category term="操作系统" /><category term="linux" /><category term="学习" /><summary type="html">操作系统原理 第一章 操作系统概述 P9 1.1 操作系统概念 操作系统是系统软件，是用户与计算机之间的接口，基本职能是控制和管理系统内部的各种资源，有效地组织多道程序的运行，扩充硬件功能。从 作为扩展机器的操作系统把硬件细节与程序员隔离开，实际客户是应用程序 作为资源管理的操作系统的功能是管理系统中的硬件资源和数据、程序等软件资源，控制协调各个程序对这些资源的利用，涉及资源共享的问题。操作系统是计算机系统的资源管理器这种观点占主导地位 用户观点：操作系统处于用户和硬件之间，有助于用户使用计算机系统的接口和各种资源 系统观点：操作系统是硬件上第一层软件，管理硬件资源和软件资源的分配问题，是资源分配者 （操作系统要对 IO 设备和用户程序加以控制，防止非法操作，这样看操作系统就是控制程序） 进程管理观点：进程是程序在并发环境中的执行过程 与操作系统相关的几种主要寄存器: 用户可编程寄存器以及控制与状态寄存器。 用户可编程寄存器是机器语言或者汇编语言可以进行操作的寄存器，如数据、地址、条件码寄存器 控制与状态寄存器可以被处理器用来控制自身操作，或者被有特权的操作系统例程用来控制相关程序的执行。如PC（程序计数器）、IR（指令）、PSW（程序状态字）寄存器等 CPU能执行的全部指令集合称作指令系统或指令集，特权指令用于操作系统或者其他系统软件，主要用于系统资源的分配和管理；用户使用的是非特权指令，如算术运算和访管指令。 CPU运行模式：内核态和用户态（与PSW有关） 中断和异常是实施并发的基础，由硬件和软件结合而成，中断来自CPU外，异常来自CPU内 系统初启的一般过程： 硬件检测：BIOS加电进行硬件自检，然后读入系统引导区的程序，并将系统控制权交给引导装入程序 加载引导程序：其不直接引导操作系统，但能根据盘区划分的信息找到活动分区，然后从其中将引导程序读入内存；运行引导程序，从硬盘中读入其他几个软件，由后者加载内核；内核加载完毕后系统跳到setup程序，在实模式下运行，设置系统参数和显示器；最后进入保护模式跳到内核映像开头，执行内核初始化。 初始化内核： 第一个阶段是CPU本身初始化：设置内核页表、启动页面映射机制、建立系统第一个进程、初始化内核的全局变量和静态变量、设置中断向量表等； 第二个阶段是系统一些基础设施的初始化：设置内存边界、初始化内存页面、设置各种处理程序入口地址、定义系统中最大进程数目、创建init内核线程等 第三个阶段是对上层的初始化：初始化外部设备、加载驱动、创建核心线程、初始化文件系统并加载 实现用户登录：init程序在tty每个端口上都创建一个进程login，用于登录 操作系统的构建目标：高效性（对软硬件资源合理的调度和分派）、方便性（操作系统对外提供接口，方便用户使用）、安全性（保护信息不被未授权人员使用）、鲁棒性（稳定性、强健性）、移植性（从一个硬件平台到另一个平台时的改动不能过多且要容易实施） 软件分类：系统软件（操作系统、编译、汇编、链接、数据库、网络程序）、应用软件、支撑软件（辅助软件技术人员从事软件开发的工具） 操作系统是整个计算机系统的控制管理中心，经过软件扩充功能后的机器称为“虚拟机” 操作系统提供的服务：用户接口、程序执行、IO操作、文件系统管理、出错检测、通信、资源分配、统计、保护。 操作系统的服务方式是系统调用和系统程序 系统调用：一般处于操作系统核心的最高层，CPU执行用户程序中的系统调用时，处理机的状态会从用户态变成核心态，进入操作系统内部；而过程调用只能在用户态下运行，不能进入核心态，系统调用完成了用户态到核心态的转变。系数调用可以大致分为五类：进程控制、文件管理、设备管理、信息维护和通信 系统程序：系统程序主要指系统程序包（库函数）中提供的大量系统程序。大概分为六大类：文件管理、状态信息、文件修改、程序设计语言的支持、程序装入和执行、通信。最重要的系统程序是命令解释程序，系统程序是对系统调用功能的集成和应用简化 1.2 操作系统的功能 OS应当具有的五大基本功能：存储管理、进程和处理机管理、文件管理、设备管理、用户接口 存储管理：用户程序在运行之前要装入内存，内存是所有运行程序的共享资源，存储管理的主要功能为：内存分配、地址映射、内存保护和内存扩充 内存分配：主要任务是为每道程序按某种策略来分配一定的内存空间，并且接收释放的空间 地址映射：编写程序时不需要考虑程序和数据要存放在内存的什么位置，CPU在执行用户程序的时候要从内存中取出指令或数据，就必须把逻辑地址转换成内存的物理地址，这叫地址映射需要有硬件支持 内存保护：不同用户的程序都在内存中，必须保证它们在各自的内存空间中活动，不能相互干扰，不能侵犯其他空间，必须建立内存保护机制。可以设置两个界限寄存器（上界地址和下界地址） 内存扩充：逻辑扩充使用虚拟存储技术，一个程序不是全部放在内存中，其余部分放在磁盘上，以后根据程序执行时的要求和内存情况，随机将所需部分调入内存或回收已分配的内存 进程和处理机管理：所有用户程序和系统程序都必须在CPU上运行，对它的管理直接影响整个系统的性能，主要包括：作业和进程调度、进程控制、进程同步和进程通信 作业和进程调度：用户的计算任务称为作业，程序的执行过程称作进程，进程是分配和运行处理机的基本单位。首先作业经过作业调度，把一批选中的作业放入内存并为其分配资源，建立相应的进程，然后进程调度按一定的算法从就绪进程中找出一个合适进程在CPU上运行 进程控制：进程是系统活动的主体，进程控制包括创建进程、撤销进程、封锁进程、唤醒进程 进程同步：多个进程在活动过程中彼此彼此会发生相互依赖或制约等关系，为了保证所有进程都能正常活动就必须设置进程同步机制：分为同步和互斥 进程通信：相互合作的进程之间往往需要交换信息，为此系统要提供通信机制 文件管理：在计算机工作经常要建立文件、打开文件、对文件读写等，所以文件管理功能应该包括：文件存储空间的管理、文件操作的一般管理、目录管理、文件读写管理和存储控制 文件存储空间管理：系统文件和用户文件存放在磁盘上，需要由文件系统对所有文件以及文件的存储空间进行统一管理：为新文件分配必要的外存空间，回收释放的文件空间 文件操作：对文件的创建删除打开关闭等 目录管理：目录文件的组织、实现“按名存储”，目录快速查找和文件共享 文件读写管理和存取控制：按请求从外存读或者写入外存，防止未授权用户破坏 设备管理：设备的分配和驱动由OS负责，设备管理的主要功能包括缓冲区管理、设备分配、设备驱动和设备无关性 缓冲区管理：解决CPU和外设速度不同的问题 设备分配：根据请求为用户分配设备 设备驱动：实现CPU与通道和外设之间的通信，屏蔽硬件细节 设备无关性：用户写的程序（逻辑设备）和实际使用的物理设备无关，由OS映射到物理设备 用户接口：OS对外提供的多种服务，使用户方便有效地使用计算机硬件和用户程序 程序接口：也称系统调用，是OS内核和用户程序应用程序的接口，只能在核心态下运行 命令行接口：OS与用户的交互界面，输入命令后程序解释这些命令，交给OS内部程序处理 图形用户接口：用户利用图形界面工具操作计算机 1.3 操作系统的特征 OS特征为:并发、共享、异步性和抽象性 并发：微观上单个进程在CPU上执行，进程交替运行，宏观看是并行 共享：资源被多个任务共用，被共享的程序必须是纯码（在执行过程中本身不作任何变化） 异步性：进程执行过程中“走走停停”，但在相同初始数据下总能得到同样结果 抽象性：把复杂的事情简单化 1.4操作系统的形成和基本类型 OS的形成和发展：手工操作阶段、早期批处理阶段（联机批处理，脱机批处理）、多道批处理系统、分时系统、实时系统（后三种是传统意义上OS的基本类型） 多道程序设计的基本思想是，在内存中同时存放多道程序，在管理程序的控制下交替地执行 分时系统的特征和优点：同时性、交互性、独立性、及时性 实时系统的类型：过程控制、信息查询、事务处理系统，其实现可分为软式硬式两种方式 1.5 操作系统的主要结构 OS主要有单体结构、层次结构、虚拟机结构、微内核结构和客户-服务器结构 单体结构：OS中有大量模块，模块就是完成一定功能的子程序，是构成软件的基本单位 层次结构：把模块分为若干层，底层不能调用高层 虚拟机结构：最底层是虚拟机监控程序，向上层提供多台虚拟机，虚拟机是裸机硬件的复制品。是通过共享物理机器资源实现的，每台虚拟机可以使用不同的操作系统，在系统调用时陷入自身的操作系统里面，最后的 IO操作由虚拟机监控程序完成 微内核结构：把扩展机器功能向上移，操作系统被分为文件服务、进程服务、终端服务或者内存服务，各个服务器在用户态下运行并不直接访问硬件，客户进程通过微内核访问服务，因此微内核在核心态下实现所有操作系统的基本功能：中断处理、进程管理等 客户-服务器结构：多用于分布式系统，进程如微内核结构分为两类：服务器和客户进程 1.6 UNIX | LINUX 系统的核心结构 UNIX是多用户、多进程、多任务的分时系统，其分为三层：靠近硬件的底层是内核即UNIX常驻内存部分，核外中间层是shell层，最高层是应用层 LINUX和UNIX一样多用户和多任务，从结构上看是采用单体结构的操作系统，所有的内核系统功能都包含在一个大型的内核软件之中 第二章 进程管理 P42 2.1 进程概念 进程和程序的区别： 动态性：程序是静态的，进程是动态的，程序作为一种软件资源长期保留，而进程是程序的一次执行过程，动态的产生和销毁 并发性：进程作为资源申请和调度单位存在，而程序不能作为独立运行的单位并发执行，因为进程不仅包括相应的程序和数据，还有一系列描述其活动的数据结构，能用于CPU调度 非对应性：一个程序可以被多个进程共用，一个进程可以在活动中执行若干程序 异步性：各个进程在并发执行时会产生互相制约关系，导致前进速度不可预测 进程的特征：动态性、并发性、调度性、异步性、结构性 2.2 进程状态描述及组织方式 进程映像：程序、数据集合、栈和PCB（进程控制块） 栈用来保存过程调用和相互传参的踪迹 进程控制块PCB：进程名PID、状态信息、特征信息、优先级、通信信息、现场保护区（中断时保存现场环境）、资源需求、实体信息、族系关系、其他。 LINUX中进程控制块为task_struct数据结构，系统维护一个进程向量组task，元素是指向task_struct结构的指针，进程的栈和task_struct数据结构紧密联系 LINUX进程状态：运行态、可中断等待态（可被中断唤醒）、不可中断等待态（只能等待资源满足唤醒）、停止态、僵死态（进程被种子但是进程控制块依然保留着） 2.4 线程概念 在现代操作系统中，进程只作为资源拥有者，负责申请和占有所需的全部资源；而参与调度和运行的是线程，线程是进程执行运算的最小单位，即执行处理机调度的基本单位 线程的组成：每一个线程用于一个Thread结构（线程控制块） 线程的实现方式 ： 在用户空间实现，管理线程的工作完全由应用程序完成，每个进程有一个私有的线程表，核心只对进程实施管理； 在核心空间实现，核心知道线程的存在并实施管理，线程表和进程表都在核心空间中，线程在创建或者删除一个线程的时候需要使用系统调用，核心可以同时调度同一进程的多个线程 2.5 进程间的同步和互斥 进程间的相互关系主要分为：互斥、同步和通信 互斥关系中，并发进程对共享资源的竞争，这些资源称为临界资源，访问临界资源的那段程序称为临界区，简称CS区。进程互斥进入临界区前需要申请，执行后需要退出才能执行其他代码，禁止两个或者两个以上的进程同时进入临界区 实现互斥的方法 硬件方法：关中断（不响应中断），另一种是设置专用机器指令（测试并上锁） 软件方法：设置软件锁 一种更通用的方法：信号量即PV操作原语，信号量是一种设施，在进程间发送信号 整形信号量：将信号量定义成一个特殊可共享的整形量，有“忙锁”问题 记录型信号量：信号量一般由整形变量和指向PCB的指针组成，信号量的值大于0时表示当前可用的资源数量，小于零则绝对值表示等待使用该资源的进程个数 一般应用还分了二值信号量（类似互斥锁 01的值）和一般信号量 具体过程： 生产者消费者问题中，应先执行同步信号量P再执行互斥信号量，不能调换顺序不然可能产生死锁 读者写者问题，仅在第一个访问数据库的读者才对信号量w执行P操作，最后一个访问的读者才对信号量W进行V操作，隐含读者优先级高于写者 哲学家进餐问题，解决死锁有三种方法：最多4人拿、均可用才拿、奇拿左偶拿右 理发店问题 P85 使用信号量的提示：先确定有几个或者几类进程，确定进程制约关系确定信号量种类，定义信号量含义和初值，编写代码，PV操作要成对出现 2.7 进程通信 互斥和同步机构因交换的信息量少，归结为低级通信，高级进程通信分为三类：共享存储器、管道文件和消息传递 共享存储器：在内存中分配一片空间作为共享存储区 管道文件：也称管道线，连接两个命令的一个打开文件，一个命令写，一个命令读 消息传递：以消息为单位在进程间进行数据交换，有直接通信和间接通信两种方式 消息缓冲通信（直接通信）：进程发送信息前先向系统申请缓冲区，缓冲区中写入消息，然后将缓冲区连到接收进程的消息队列中，并通知接收者，接受者在自己占用的内存中指定一个接收消息区，接收消息。 信箱通信：信箱可以存放一定数量的消息，发送进程将消息送入信箱，接收进程从信箱中取出发给自己的消息，有公有信箱（操作系统创建）、共享信箱（某个进程创建，创建者和共享这可以从中取走发给自己的消息）、私有信箱（用户进程创建，创建者可读，其他进程只能发） 2.8 linux系统的进程通信 信号亦称为软中断，只有父子进程和进程自身可以应用信号机制通信，也并不是专为进程间通信设置，可以用于内核与进程间通信，内核只能发送不能接收 处理信号的方式：忽略信号、阻塞信号、由进程处理信号、默认由系统处理信号 检测信号的时间：从系统空间返回用户空间之前，进程刚被唤醒的时候 2.10 死锁 产生死锁的根本原因是资源有限且操作不当， 产生死锁的四个必要条件：互斥条件、不可抢占条件、占有且申请条件、环路等待条件， 当死锁发送时四个条件一定是同时满足的，任何一个条件不成立，死锁就不会发生 对待死锁的策略：忽略死锁、死锁预防、死锁避免、死锁检测与恢复 死锁预防： 破坏互斥条件：一般不使用，因为某些资源固有属性就是独占性 破坏占用且等待条件：预分配，所有进程开始之前就分配所需全部资源；空手申请，只有进程不占有资源时才可以申请资源 破坏非抢占条件：一个进程在申请资源时会隐性释放申请前已占有的资源，只有当该进程获得所有申请的资源和被剥夺的资源后才能重新启动。 破坏环路等待条件：为资源有序分配序列，确保占用资源时不会形成环路 死锁避免：是排除死锁的动态策略，它不限制有关申请资源的命令，而是在实施资源分配前检查，若预测有死锁发生的可能则加以避免。 银行家算法是死锁避免，允许互斥、占有且申请和不可抢占条件 死锁检测： 对单体资源（所有类型的资源只有一个实体），可以将资源分配图中的资源去掉形成只有边的等待图，系统定期搜索等待图中的环路 对多体资源，系统检查未完成的进程是否能满足资源请求，不满足则说明有死锁 死锁恢复：通过抢占资源、回退执行和杀死进程自动从死锁中恢复，或者直接通知系统管理人员 抢占式：临时从资源从占用它的进程中剥夺过来 回退执行：系统定期检查进程，出现死锁就让某个占有必要资源的进程回退到前一个检查点，释放占有资源 杀死进程：一次终止一个，终止后要进行死锁检测 活锁和饥饿：活锁是忙式等待，饥饿是调度问题 第三章 处理机调度 P114 处理机分配由调度和分派两个功能组成，调度是指组织和维护就绪进程，分派是当CPU空闲就从就绪队列中取出PCB将其运行 调度级别：高级调度（作业调度）从作业中选出若干个作业分配必要的资源；中级调度，内存紧张时将某些进程从内存中移到外存上；低级调度（进程调度）按一定算法将CPU分派给就绪队列中的某一个进程 3.2 作业调度 作业通常分为：提交、后备、执行和完成四种状态， 作业调度功能 记录系统中各个作业的情况，记录在作业的JCB中 按照某种调度算法从后备作业队列中挑选，决定接纳多少个作业进入内存 为选中的作业分配内存的外设（存储管理和设备管理） 为选中的作业创建进程，放入就绪队列中 作业结束后善后处理，释放JCB 进程调度：使就绪进程获得CPU的控制权 调度算法的性能评价：1、CPU利用率 2、吞吐量 3、带权周转时间 4、就绪等待时间 5、响应时间 3.7 实时调度 静态调度：在系统开始之前作出调度决定，必须在知道有关需要完成的工作和截止时间的情况下才能起作用；（优先级谁速率单调的调度算法，优先级和速率呈线性关系，总是运行优先级最高的进程）![image-20200705201308138]/assets理/image-20200705201308138.png) 动态调度：在运行时做调度决定，不受限制。（最早截止时间优先调度算法，每个进程申请CPU时，表明自己的存放和截止时间等信息，调度程序把所有可运行的进程按截止时间排序，选最紧迫的进程运行） 3.8 LINUX系统中的进程调度 LINUX调度机制主要涉及调度方式、调度策略、调度时机和调度算法 调度方式基本采用抢占式优先级的方法 调度策略有FIFO RR OTHER（由进程剩余时间配额设置优先级，由nice命令设置优先级） 调度时机 调度算法：抢占式优先级算法 3.9 中断处理 保存现场时有两种方法：集中式保存，在内存的系统区设置一个中断现场保存栈；分散式保存，在每个进程的PCB中设置一个核心栈 中断优先级：可能某个时刻有多个中断同时出现，在硬件设计中断响应时，必须按各种中断事件的轻重缓急对线路进程排队，安排中断响应次序；而在软件中处理中断也要排序，可以和响应顺序不同，高级别中断有打断低级别中断处理程序的权利。 中断屏蔽：中断请求提出后CPU不响应，常常用来防止同级中断的打扰 中断禁止：系统不接受中断信号，不会提出中断请求 系统调用：陷入和捕俘，所有陷入事件有一个总的服务程序：陷入总控程序，在处理系统调用处理的过程中并不自动关闭中断 具体过程为：陷入总控程序将参数压入系统栈，调用陷入处理程序trap，程序根据陷入事件的不同类型进行不同的处理，对于非法指令、指令故障、转换无效等事件，转入信号机构处理；对于系统调用使用系统调用函数处理 第四章 存储管理 P149 4.1 地址空间与重定位 程序装入内存有三种方式 绝对装入：程序中使用的所有地址都是内存绝对地址，程序装入到内存的指定位置 可重定位装入：程序中根据内存当时的使用情况，决定存放到内存的位置，程序使用相对地址 动态运行时装入：装入内存的程序可以换到磁盘，需要时再换入内存中，需要硬件支持 静态重定位：由装入程序对目标程序中的指令和数据的地址进行修改，执行过程中不再改动 动态重定位：在程序执行期间，每次访问内存之前都要进行重定位，靠硬件地址转换机构实现，通常采用一对重定位寄存器，一个存放程序在内存的初始地址（基址寄存器）另一个表示程序的逻辑地址最大范围（限长寄存器），都为特权寄存器 UNIX LINUX 中对内存管理还利用了多道程序对换技术（中级调度），内存中保留多个进程，当内存空间紧张则把某些进程换出到外存中。 4.2 分区技术 内存一开始为一大块，各个分区在相应进程进入内存时才建立，大小和进程大小相同，在进程完成后就释放所占分区，系统尝试将其与邻接的空闲分区合并起来，成为一个大分区 动态分区法常用于记录内存使用情况的数据结构有：空闲分区表和分区链 P159 分配算法有：最先适应算法、最佳适应算法、循环适应算法和最坏使用算法 最先适应：分区表按位置排列，先找到满足的空闲区就直接分配，释放内存时就根据分区表合并上下空闲区，如果无相连空闲区，则新建并插入分区表 最佳适应：以空闲区大小为序，从小到大，同样想找到先分配，划分后有剩余则修改分区大小和重新确定空闲区在表中位置 循环适应：和最先使用一样，但每次找到合适的空闲区后就记录，下次查找空闲区从记录位置的下一个空闲分区开始找 最坏适应：从大到小排，利用划分后剩余的分区来减少碎片 采用分区技术需要有硬件保护，通常由一对寄存器分别表示用户进程在内存空间中的上下界 4.3 分页技术 分区和对换技术都要求把一个进程放置在一片连续的内存区域，而分页允许程序存储空间不连续，从而解决外部碎片的问题，提高内存利用率 逻辑空间分页、内存空间分块，块大小和页面大小相同。分页情况下，系统以块作为单位把内存分给各个进程，进程的每个页面对应一个内存块，为了找到每个页面在内存中对应的物理块，系统为每一个进程设立了一张页面映射表，操作系统通过建立内存块表管理整个内存 为了解决放置页表带来的存取速度下降的问题，可以设置一个高速联想存储器快表，快表包含键（页号）和值（块号） 页的共享：只有只读的页可以共享，而且通常因为系统分页情况是用户不可见的，会把私有数据和可共享数据混杂到同一个页，不容易实现共享 页的保护 利用页表本身进行保护：页表基址信息放在进程的PCB中，访问内存要利用页表进行地址转换，各进程在自己的存储空间内活动 设置存储控制位：在页表表现设置存取控制字段，指明块的内容允许何种操作 设置合法标志：非法时表示该页不在该进程的逻辑地址空间中 页表构造（为了节省内存空间，需要动态调入页表） 多级页表：用来防止一级页表过大，进程只保留部分页表，剩下的页表动态调入到内存中 散列页表，处理大于32位地址空间的通用方式，表中每一项有一个链表，由页号、对应的内存块号和指向下一个元素的指针组成 倒置页表，用于64位虚拟地址空间在处理器上的应用，系统中只有一个页表，每个内存块对应唯一的表项，表项由进程标识符和虚拟页号组成，访问地址时用PID和页号查询块号，如果找不到，则此页未调入内存，产生请求调页中断，如果还没有，则地址错误 4.4 分段技术 将用户程序分成若干相对独立的部分，每段从0开始编址，并采用一段连续的地址空间 程序地址结构：整个进程的地址空间分成多个段，逻辑地址分成段号S和段内地址d ，段的信息的逻辑单位，用于可以知道自己的程序分成几段以及相应的功能 段表和段表地址寄存器，一个进程的全部段都在该进程的段表中登记，系统还有一个段表地址寄存器，一部分指出段表在内存中的起始地址；另一部分指出段表的长度，主要用于段寻址和越界检测 段的保护 存取控制：在段表中记录本段允许的操作，可读、可写、可读写 段表本身的保护：利用段表地址寄存器判断访问空间 保护环： 4.5 段页式结合系统 分页存储管理能提高内存利用率，分段存储可以满足用户需求，两者结合可以“各取所长” 段页式存储管理的基本原理： 等分内存：把内存分成大小相等的内存块 进程地址空间采用分段：吧进程的程序和数据分成若干段，每段一个段名 段内分页：把每段分成若干页，页面大小和内存块相同 逻辑地址结构：由段号、段页页号和页内地址组成 内存分配：内存分配单位为块 段表、页表和段表地址寄存器：系统为每个进程建立一个段表，为每一个段建立一个页表。因此段表中不再是段长和内存地址，而是页表长和页表地址 实现的具体过程为： 4.6 虚拟存储器 虚存特征 虚拟扩充：不是扩大物理空间，而是扩充逻辑内存容量 部分装入：进程不是一次性全部装入内存，而是将当前运行需要用到的那部分程序和数据装入内存中 离散分配：一个进程在内存的部分可能散布在内存的不同地方，避免浪费也为动态调入提供了方便 多次对换：一个进程运行期间，它所需的全部程序和数据分成多次调入内存 4.7 请求分页 页表结构 抖动是指，如果置换算法不合适，可能出现刚换出的页面又很快被访问，系统大部分时间用在页面调度和传输上，实际效率太低 页面置换算法： 先进先出、最佳置换、最近最久未使用 第二次机会置换法：查看引用位，被引用过为1则视为刚装入，并把引用位清零，继续寻找引用位为0的页 时钟置换法：是对第二次机会置换法的改进，使用循环链表![image-20200706153036986]/assets理/image-20200706153036986.png) 最近未使用：启动进程时所有页的引用位和修改位都置成0，引用位会定期清0![image-20200706153222897]/assets理/image-20200706153222897.png) 过程为，从当前指针指向的位置开始查找循环队列（结构和时钟算法一样），先找第一类，不满足则再找第二类，第二类也不满足则把引用位都清0 4.8 内存块分配和抖动问题 内存最少块数：每个进程需要有最少的内存块数，分配的总块数不能超过可用块的总量 内存块分配策略：固定分配，给进程分配的内存块数是固定的，缺页时只能从分给该进程的内存块中进行页面置换；可变分配，如果进程运行持续缺页率较高，则多分内存块 页面置换范围：全局置换，运行一个进程从全部内存中选取淘汰的内存块；局部置换，只能置换分给进程的那一组，全局置换只能和可变分配策略相结合 分配内存块的算法：等分法、比例法（依照进程的地址空间）和优先权法（依照进程的优先级） 防止抖动的方法： 采用局部置换：当进程出现抖动时，其不能从另外的进程那里获得内存块，使抖动局限在一个小范围，但未解决抖动 挂起某些进程：腾出内存空间给抖动进程使用 采用缺页频度发：如果缺页率太高则给进程更多内存块，控制缺页率 利用工作集：程序往往具有局部性，时间局部性，某条指令刚被执行后，往往很快又被执行（循环顺序）；空间局部性，某个位置被访问，它附近的位置也要被访问（数组结构） 工作集就是一个进程在某一小段时间内访问页面的集合，工作集大小WSSi 与时间间隔d有关，如果d过小则不能反映工作集缓慢变化，如果d太大则不体现局部的效果 有公式 $D=\sum^n_{i=1}WSS_i$ ，其中D是系统中全部进程的总请求量，D大于可以的内存块总量m表示将出现抖动 4.9 请求分段 段式虚存可以实现动态链接技术，使用间接编址和链接故障指示两个硬件设施,间接地址是指存放直接地址的地址,链接故障指示检查时，如果段未链接上，硬件会产生链接中断 4.10 linux系统的存储管理技术 采用了和UNIX一样的请求分页存储管理技术和对换技术。页面置换使用LRU，管理用位图和链表结构 第五章 文件系统 P207 5.1 文件及其分类 文件是从存储设备抽象出来的被命名的相关信息的集合体，通常存放在外存中。 文件类型按用途分类 系统文件：操作系统和其他系统程序信息组成的文件，只能通过系统调用为用户服务 库文件：由标准子程序和常用的应用程序组成的文件，允许用户使用但不能修改 用户文件：由用户保存管理的文件，可以被创建者或者被授权者进行操作 按数据形式分类：源文件、目标文件（编译后未链接）、可执行文件（编译链接） 按存储权限分类：只读文件、读写文件和可执行文件 按保存时间分类：临时文件和永久文件 在UNIX和Linux中按文件的内部构造和处理方式分类： 普通文件：内部没有固定结构，由程序、数据活文本的字符串构成 目录文件：由下属文件的目录项构成的文件，可进行读写等操作 特殊文件：特指各种外部设备，系统把IO设备作为文件对待，进行统一管理![image-20200707103847223]/assets理/image-20200707103847223.png) 普通文件分为文本文件（ASCII文件）和二进制文件，二进制文件有内部结构，在UNIX和Linux中有五个区，文件头、正文段、数据段、重定位区和符号表区，文件头结构由标志可执行文件特征的幻数、正文段长度、数据段长度、BSS段长度、符号表的长度和入口单元及各种标志组成，重定位时利用重定位区，而符号表用于调试程序 文件抽象最重要的特性是“按名”管理对象，用户对文件也是“按名存取”。 文件系统是OS负责操纵和管理文件的一套系统 文件管理：创建删除、打开关闭、读写执行一个文件 目录管理：为每个文件建立一个文件目录项，若干文件的目录项构成一个目录文件，根据用户要求创建或者删除目录文件、对用户指定文件进行检索和权限验证、更改工作目录等 文件存储空间管理：对文件的存储空间分配与回收，并为文件逻辑结构与物理地址建立映射 文件的共享和保护：在系统控制下使用户能共享其他用户的文件，防止对文件的未授权访问或破坏 提供方便的接口：为用户提供统一的文件存取方式，实现“按名存取”，OS为用户提供有关文件操作的系统调用，给用户编程使用 5.2 文件的逻辑组织和物理组织 逻辑组织有无结构文件和有结构文件两种 无结构文件是有一组相关信息组成的有序字符流，OS并不关心文件中存放的内容是什么，其看到的都是一个一个的字节，具体内容由用户级程序解释； 有结构文件，又称记录型文件，文件是由若干相关记录组成的，每个记录是一组相关的数据集合（具体类似于JSON文件），用于描述一个对象某个方面的属性，如年龄、姓名等。分为定长和变长记录文件两种 存取方式分为顺序存取和随机存取，顺序存取严格按照字符流或记录的排序依次存取，随机存取这允许用户随意存取文件中的一个记录 随机存取基于磁盘的文件存取模式，对于定长记录文件，随机存取把文件视为一系列编号上的块或记录，通常每块的大小是一样的，被操作系统作为最小的定位单位 文件的物理组织 连续文件：把逻辑上连续的文件信息存放在连续编号的物理块中，如定长文件大小为2000，假设一个物理块大小为512，文件需要占用4块 链接文件：逻辑连续的文件分散存放在不同物理块中，为各个物理块设置链接字，指示该文件的下一个物理块，系统维护一个文件分配表，每个文件都在表中独占一项，其中包括了文件名、起始块号和最后块号 索引文件：系统为每一个文件建立索引表，表项指出存放该文件的各个物理块号，索引表也存放在一个盘块中，由文件目录项指出索引盘块地址 多重索引 5.3 文件控制块和文件目录 文件系统内部给每个文件唯一地设置一个文件控制块，核心利用该结构进行管理时，首先会验证权限 UNIX和Linux中该结构称为 i 节点，i 节点分为静态和动态两种，静态在磁盘上，动态在内存中，每个文件对应一个唯一的静态 i 节点，而每个打开的文件都有一个对应的动态 i 节点，只有动态 i 节点才有节点号，节点号是唯一的，指向静态 i 节点。 文件目录是文件控制块的有序集合，完全由目录项组成的文件称为目录文件 目录结构有：单级目录、二级目录（多了用户目录）、树形目录（多级目录）、非循环图目录（带链接的树形结构） 5.4 文件存储空间管理 空闲空间管理技术有：空闲空间表法、空闲块链接法、位示图法和空闲块成组链表法 空闲块成组链表法：把所有空闲盘块按固定数量分组，如50个空闲块为一组，组中第一块为组长块，第一组的50个空闲块块号放在第二组的组长块中……最后一个块（可能不到50块）放在文件系统超级块中的空闲块号栈里 第一个块中的警戒位 5.7 linux文件系统 每个进程有两个数据结构来描述进程与文件的相关信息，一个是fs_struct 指向两个VFS索引节点，分别是根目录节点和当前目录节点；另一个是files_struct（进程文件描述符表） 保存该进程打开文件的有关信息，其中的指针指向对应的 file 结构（打开文件描述表表） 进程文件描述符表让各个进程掌握它当前使用文件的情况，不要同时打开太多文件，并加速对文件的查找速度 核心设置打开文件表的原因是，一个文件可以被多个进程打开 第六章设备管理 P254 6.1 设备管理概述 设备分类 按工作特性分为存储设备和输入输出设备两大类，有个别不符合这两类的，如时钟 按设备使用性质分为独占设备（只能一个进程独占）、共享设备（多个进程同时共用）和虚拟设备（利用某种技术吧独占设备改造成多个进程共用的设备） 按数据传输方式分为串行设备（二进制位一位一位顺序传送）和并行设备（8位数据同时通过并行线进行传送的设备） 设备标识：OS为每台设备分配一个唯一设备绝对号用于区分和识别设备，UNIX和Linux中每个块设备的名字由两部分组成：主设备号和次设备号。 多道程序环境中，写程序时使用的是主设备号（设备的类型号），而次设备号表示同类设备的相对序号，用户程序只知道使用设备的类型，具体使用哪一台由系统分配，OS负责进行“地址转换”，将类型号变成设备绝对号 IO 系统结构：主机IO系统和微型机IO系统 主机IO系统 通道相当于小型处理机，独立执行通道程序，对外部设备的IO操作进行控制，实现内存和外设之间的数据传输，主机委托的IO处理完成后，通道发出中断信号，请求CPU处理使CPU和外设并行效率提升 主机IO系统的通道三种类型 字节多路通道：以字节为信息传输单位，服务于多台低速IO设备，当通道为一台设备传输一个字节后立刻转向为下一台设备传送字符，交叉控制下属各个设备的工作 选择通道：同一时间只能为一台设备服务，连续地传输一批数据，主要用于连接高速外部设备 成组多路通道：广泛用于连接高速和中速设备，结合了字节多路通道分时操作和选择通道高速传送的优点，允许多个通道程序在同一IO通道中并行，每执行完一条通道指令就转向另一通道程序，任意时刻只能为一个设备服务但又能立刻切换到下一个通道 微型机IO系统 大多使用总线IO系统结构，实现CPU和控制器之间的通信 IO设备一般有机械和电子两部分组成，电子部分称为设备控制器或适配器，可以管理端口、总线或设备，实现设备主体和主机间的连接与通信，一台设备控制器可以控制多台同一类型的设备，控制器是可编址的设备，OS常常通过控制器实施对设备的控制和操作 IO系统的控制方法 程序控制直接传递方式，程序查询方式，中断控制方式，直接存储器访问方式，独立通道方式，IO处理器方式 直接存储器访问方式DMA DMA传送操作：DMA包括内存地址寄存器、字节计数寄存器、一个或多个控制寄存器，控制寄存器指明所用的端口、传送方向（读还是写）、传送的单位（一个字节或者字），本次传送的字节数，CPU可以读写这些寄存器 ​ DMA工作过程： CPU把一个DMA命令块写入内存，命令包含传送数据的源地址、目的地址和传送字节数，然后把该块地址写入到DMA控制寄存器中，CPU向磁盘控制器发送读盘命令，然后CPU处理其他任务，当有效数据存入到磁盘控制器的缓冲区中后开始DMA存取 DMA控制器启动数据传送，通过总线向磁盘控制器发送读盘请求，读数据到指定内存单元中 某些DMA可以每次一字或者整块传送 缓冲技术 为了解决CPU和IO设备速度不匹配的矛盾，提高CPU和IO设备的并行性 可设置为硬缓冲和软缓冲（从内存中开辟区域做缓冲区，缓冲区大小一般与盘块大小一样） 可设置单缓冲、双缓冲或多缓冲 在多缓冲基础上可以构造循环缓冲或缓冲池，有两个指针：一个指向缓冲区中数据第一个字，一个指向首个空闲区位置。为了提高缓冲区利用率，往往采用公用缓冲池的方式，池中的缓冲区可以供多个进程使用 设备管理的功能 设备管理的目标： 使用方便：屏蔽物理特性，按统一规则使用设备，OS负责输入输出工作 设备独立性：OS分配实际设备，程序只关心设备类型 效率高：利用通道和缓冲提高CPU和IO设备的并行性 管理统一：对各种外设采用统一的管理方法 为实现目标所需的功能： 监视设备状态：记住所有设备、控制器和通道的状态，以便有效管理和调度使用 进行设备分配：按类型和分配算法实施设备分配 完成IO操作：OS按用户的要求调用具体设备驱动程序，进行IO操作并处理中断 缓冲管理和地址转换 6.2 分配技术和SPOOLing系统 设备分配的相关因素有：IO设备的固有属性、os采用的分配算法、分配应防止死锁发生、用户程序使用的逻辑设备和物理设备无关 设备分配技术：独占分配、共享分配和虚拟分配（SPOOLing系统） 分配算法：先来先服务，优先级高的优先服务 SPOOLing系统一般分为存输入、取输入、存输出、取输出 6.3 IO 软件构造 IO软件系统的层次： 为了实现设备独立性、统一命名、出错控制和同步（阻塞）异步（中断驱动）处理 总体过程 设备驱动程序 功能：接收上层与设备无关的读写请求，IO请求排在请求队列队尾；取出请求队列队首请求，并将设备分配给它；想设备控制器发送命令，完成IO操作；处理来自设备的中断 设备驱动程序在系统中的逻辑位置 与设备无关的操作系统IO软件 基本功能是执行所有驱动器共同的IO功能和为用户级软件提供统一接口，所有驱动程序都有相同的接口，新驱动程序遵守接口规则，这样很容易加入操作系统 设备驱动程序的统一接口： 与接口相关的问题是IO设备如何命名，设备无关软件负责把符号设备名映像到相应的设备，每个设备指定唯一的一个特殊文件 i 节点，包含主设备号和次设备号，主设备号用来确定相应的驱动程序，次设备号作为传递给驱动程序的参数。还有保护问题，系统管理员可为每台设备规定权限 出错报告：很多错误与设备相关，需要由相应的驱动程序处理，但出错处理的架构与设备无关 错误产生的原因：一类是程序错误，如把信息写到输入设备上（键盘）、提供的参数错误、指定设备不合法等，处理方法是直接向调用者报告；一类是实际IO错误，如把信息写到坏块中、从关机的设备中读信息，此时驱动程序可以向设备无关软件报告， 分配和释放独占设备：处理的简单方法是让进程打开设备特殊文件，如果设备不可用则打开失败，以后通过关闭独占设备释放它；另一种方法是设立专门机制，负责独占设备的申请和释放，设备不可用则阻塞调用者，进程放入阻塞队列，当申请设备可用时，阻塞队列第一个进程使用它 提供与设备无关的块大小 用户空间的IO软件 以库函数的形式出现，如printf、scanf等函数，编译链接后放入内存，运行时利用系统调用进入到操作系统，由OS接收用户的IO请求，提供相应服务。由于把设备当成特殊文件处理，对设备的访问变成了对文件的访问，输入输出管理就是打开关闭、读写和查找文件 6.4 磁盘调度和管理 磁盘硬件：磁头，柱面，扇区； 现代磁盘驱动器提供给操作系统的是虚拟的几何参数，到操作系统提出寻道请求时，再由磁盘控制器把请求的参数重新映射成实际磁道地址，也就是磁盘的逻辑地址是由逻辑块组成的一维数组，文件系统读写某个文件时，由逻辑块号映射成物理块号，再由磁盘驱动程序转换成磁盘地址，再由磁盘控制器把磁盘地址定位到具体的磁盘物理地址。 6.5 Linux系统设备管理 Linux系统中硬件设备分为：块设备、字符设备和网络设备 设备转接表是文件系统和设备驱动程序之间的接口，每类设备在转接表中都占有一项，转接表中记录了对该类设备执行操作的各个子程序的入口地址，连接表在系统初启时根据硬件配置情况建立，系统只有这两个设备转接表 硬件和驱动程序之间的接口是通过相关控制寄存器或操纵设备的IO指令及中断向量组成的 Linux系统的缓冲技术：使用多重缓冲技术来平滑和加快文件信息从内存到磁盘的传输 块设备管理 磁盘块的读写方式，读有立即读和预读两种，写有立即写、异步写和延迟写 上述读写的实现机制 系统中有一个描述一系列在系统中登记的块设备的结构，使用主设备号作为索引，还包括了指向有关操作的函数指针，其是连接抽象的块设备操作与具体块设备类型操作之间的枢纽（实现块设备转接表功能）</summary></entry><entry><title type="html">技术栈总结</title><link href="http://localhost:4000/2020/05/21/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93.html" rel="alternate" type="text/html" title="技术栈总结" /><published>2020-05-21T19:51:00+08:00</published><updated>2020-05-21T19:51:00+08:00</updated><id>http://localhost:4000/2020/05/21/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93</id><content type="html" xml:base="http://localhost:4000/2020/05/21/%E6%97%A5%E5%B8%B8%E6%80%BB%E7%BB%93.html">&lt;h1 id=&quot;技术栈&quot;&gt;技术栈&lt;/h1&gt;

&lt;h2 id=&quot;待完善&quot;&gt;待完善&lt;/h2&gt;

&lt;h3 id=&quot;底层&quot;&gt;底层&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;操作系统：了解内核、了进程和文件管理等重要的概念和实现方式&lt;/li&gt;
  &lt;li&gt;编译原理：粗略搞懂编译器的执行过程（汇编√-机器码×）&lt;/li&gt;
  &lt;li&gt;计算机网络：彻底搞懂连网原理和TCP/IP的具体意义，打通网络黑箱&lt;/li&gt;
  &lt;li&gt;JVM：这个底层其实还挺好奇的，目前处于黑箱状态&lt;/li&gt;
  &lt;li&gt;Tomcat：热部署怎么使用的，大概了解原理&lt;/li&gt;
  &lt;li&gt;数据库高级：索引概念、视图概念、底层逻辑都不清楚其实。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;应用类&quot;&gt;应用类&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Vue.js：其实很好奇怎么用MVVM模式来进一步优化界面层啊？！借此完善自己的第一个项目，&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SpringBoot框架：如何实现前后端数据传输啊？？？&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;现在已知的是三层架构模式:&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;界面层 JSP(EL+JSTL) + JQuery + Ajax&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;业务逻辑层Web (Servlet+Filter)&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;数据访问层（Druied链接池+ JDBCUtils）DAO模式&lt;/strong&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Javaweb注解配置（及时补充）&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;深入&quot;&gt;深入&lt;/h2&gt;

&lt;h3 id=&quot;底层---汇编王爽汇编语言第三版&quot;&gt;底层 - 汇编：（王爽《汇编语言第三版》）&lt;/h3&gt;

&lt;h5 id=&quot;37-cpu提供的栈机制&quot;&gt;3.7 CPU提供的栈机制&lt;/h5&gt;

&lt;p&gt;入栈和出栈都是以字为单位，通过 &lt;strong&gt;SS段寄存器：SP寄存器 来指向栈顶元素&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;栈是从高地址往低地址增长的，这同时解决了“&lt;strong&gt;CPU如何知道此段内存空间是栈&lt;/strong&gt;“的问题，当SP寄存器 负增长的底线是0000h，故定义起始地址后栈大小也随之确定。但CPU是不会保证我们对栈的操作不会越界的，POP和PUSH的过程中有可能会产生溢出&lt;/p&gt;

&lt;p&gt;当栈为空时 &lt;strong&gt;SS：SP 指向栈空间最高地址单元的下一个单元&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;​	我们当然希望CPU可以帮我们解决这个问题，比如说在CPU中有记录栈顶上限和栈
底的寄存器，我们可以通过填写这些寄存器来指定栈空间的范围，然后，CPU在执行
push指令的时候靠检测栈顶上限寄存器、在执行pop指令的时候靠检测栈底寄存器保证不
会超界。
​	不过，对于8086CPU,这只是我们的一个设想(我们当然可以这样设想，如果CPU是
我们设计的话，这也就不仅仅是一个设想)。实际的情况是，8086CPU 中并没有这样的寄
存器。
​	8086CPU不保证我们对栈的操作不会超界。这也就是说，8086CPU 只知道栈顶在何
处(由SS:SP指示)，而不知道我们安排的栈空间有多大。这点就好像CPU只知道当前要执
行的指令在何处(由CS:IP指示),而不知道要执行的指令有多少。从这两点上我们可以看
出8086CPU的工作机理，它只考虑当前的情况:当前的栈顶在何处、当前要执行的指令
是哪一条。
​	我们在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安
排栈的大小，防止入栈的数据太多而导致的超界;执行出栈操作的时候也要注意，以防栈
空的时候继续出栈而导致的超界。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;应用层---javaweb_filter--ajax--json&quot;&gt;应用层 - JavaWeb_Filter &amp;amp; Ajax &amp;amp; JSON&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Json 一种轻量化的通用数据传输格式，轻量化是与XML对比，JSON更小、更快、更易解析。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;有两种表示方法 JSON对象 和 JSON字符串 用parse() stringify() 互相转化&lt;/p&gt;

    &lt;p&gt;采用键值对方式存放 可以放 number、String、数组、JSON对象&lt;/p&gt;

    &lt;p&gt;语法是花括号 {} 加 key:values 用 逗号，分隔&lt;/p&gt;

    &lt;p&gt;在 Java 调用时可以选择导 GSON（谷歌） 或者 阿里（推荐阿里 没有太多依赖） 的jar包&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Ajax ：Asynchronous JavaScript and XML. （异步的js和xml）是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;同步：在提交表单后必须等待服务器返回才可以继续处理数据（造成页面卡死待响应的现象，体验差）&lt;/p&gt;

    &lt;p&gt;异步：在提交表单后无须等待，服务器处理完成后会自动返回&lt;/p&gt;

    &lt;p&gt;Ajax在JQuery中有封装完成的使用方法，JSP页面中应用较多&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Filter：JavaWeb的三大组件之一 用于过滤请求&lt;/strong&gt; 可以用于用户权限的管理&lt;/p&gt;

    &lt;p&gt;FilterChain 过滤器链（多个过滤器一起工作）如果通过XML配置，则先配置的先调用&lt;/p&gt;

    &lt;p&gt;FilterChain.doFilter() - 执行过滤操作 如果有下一个过滤器则进入 否则执行后置代码&lt;/p&gt;

    &lt;p&gt;FilterConfig类 可以获取在XML文件中的配置信息&lt;/p&gt;

    &lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;init-param&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;param-name&amp;gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;param-value&amp;gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/init-param&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;时间线&quot;&gt;时间线&lt;/h1&gt;

&lt;h2 id=&quot;五月&quot;&gt;五月&lt;/h2&gt;

&lt;h3 id=&quot;12---json--ajax---javaweb_filter&quot;&gt;12 - JSON &amp;amp; Ajax &amp;amp;  Javaweb_Filter&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Json 一种轻量化的通用数据传输格式，轻量化是与XML对比，JSON更小、更快、更易解析。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;有两种表示方法 JSON对象 和 JSON字符串 用parse() stringify() 互相转化&lt;/p&gt;

    &lt;p&gt;采用键值对方式存放 可以放 number、String、数组、JSON对象&lt;/p&gt;

    &lt;p&gt;语法是花括号 {} 加 key:values 用 逗号，分隔&lt;/p&gt;

    &lt;p&gt;在 Java 调用时可以选择导 GSON（谷歌） 或者 阿里（推荐阿里 没有太多依赖） 的jar包&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Ajax ：Asynchronous JavaScript and XML. （异步的js和xml）是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。&lt;/strong&gt;&lt;/p&gt;

    &lt;p&gt;同步：在提交表单后必须等待服务器返回才可以继续处理数据（造成页面卡死待响应的现象，体验差）&lt;/p&gt;

    &lt;p&gt;异步：在提交表单后无须等待，服务器处理完成后会自动返回&lt;/p&gt;

    &lt;p&gt;Ajax在JQuery中有封装完成的使用方法，JSP页面中应用较多&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Filter：JavaWeb的三大组件之一 用于过滤请求&lt;/strong&gt; 可以用于用户权限的管理&lt;/p&gt;

    &lt;p&gt;FilterChain 过滤器链（多个过滤器一起工作）如果通过XML配置，则先配置的先调用&lt;/p&gt;

    &lt;p&gt;FilterChain.doFilter() - 执行过滤操作 如果有下一个过滤器则进入 否则执行后置代码&lt;/p&gt;

    &lt;p&gt;FilterConfig类 可以获取在XML文件中的配置信息&lt;/p&gt;

    &lt;div class=&quot;language-xml highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;init-param&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;param-name&amp;gt;&amp;lt;/param-name&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;param-value&amp;gt;&amp;lt;/param-value&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/init-param&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;13---汇编语言--操作系统&quot;&gt;13 - 汇编语言 &amp;amp;&amp;amp; 操作系统&lt;/h3&gt;

&lt;p&gt;​	重温了汇编的寄存器部分，预计两天内看完&lt;/p&gt;

&lt;p&gt;​	操作系统看了Linux 0.11内核的系统启动过程，bochs真难用&lt;/p&gt;

&lt;p&gt;### 14 - 汇编语言&lt;/p&gt;

&lt;p&gt;loop指令：两步操作 1.（cx）=（cx）-1   2.判断 cx 是否为零。在debug中用 g + [偏移地址]可以一次性执行所有loop&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Debug 将它解释为“[idata]” 是-一个内存单元，idata是内存单元的偏移地址;
而编译器将“[idata]” 解释为 idata 。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在汇编源程序中，数据不能以字母开头，所以要在前面加 0
直接写内存的话应当&lt;strong&gt;使用0:200~0:2ff 这段空间&lt;/strong&gt; dos和其他合法程序通常不会使用这段空间。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;程序中的指令就要对这8个数据进行累加，这8个数据在代码段中，程序在运行的时候CS中存放代码段的段地址，所以可以从CS中得到它们的段地址。它们的偏移地址是多少呢?因为用dw定义的数据处于代码段的最开始，所以偏移地址为0，&lt;strong&gt;这8个数据就在代码段的偏移0、2、4、6、8、A、C、E处。&lt;/strong&gt;程序运行时，它&lt;strong&gt;们的地址就是CS:0、CS:2、 CS:4、CS:6、CS:8、CS:A、 CS:C、 CS:E。&lt;/strong&gt;
…………
dw段的数据的值是多少，对于程序来说没有意义。我们定义这些数据的最终目的是，通过它们获取一定容量的内存空间，所以我们在描述dw的作用时，可以说用它定义数据，也可以说用它开辟内存空间。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;一般在需要暂存数据的时候，我们都应该使用栈&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在8086CPU中只有bx si di bp 这4个寄存器可以用于内存单元寻址，这4个寄存器可以单个出现，或者以4种组合出现： bx+si , bx+di , bp+si , bp+di (ds:bx  ss:bp)
CPU提供的如[bx+si+idata]的寻址方式为结构化处理提供了方便，用 bx 定位整个结构体，idata定位结构体中的某一个数据项，si 定位数组项中的每个元素。可以写成bx.idata[si]。&lt;/p&gt;

&lt;h3 id=&quot;15---汇编语言&quot;&gt;15 - 汇编语言&lt;/h3&gt;

&lt;p&gt;jmp指令经典例题：
&lt;img src=&quot;https://s1.ax1x.com/2020/05/15/Yrs7Y6.png&quot; alt=&quot;Yrs7Y6.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;flag 寄存器：
&lt;img src=&quot;https://s1.ax1x.com/2020/05/15/YsSYSP.png&quot; alt=&quot;YsSYSP.png&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;CPU提供了cmp 指令，也提供了je等条件转移指令，如果将它们配合使用，可以实
现根据比较结果进行转移的功能。但这只是“如果”，只是一种合理的建议，和事实上常
用的方法。但究竟是否配合使用它们，完全是你自己的事情。这就好像call 和ret 指令的
关系一样。
&lt;img src=&quot;https://s1.ax1x.com/2020/05/15/YsAvWQ.png&quot; alt=&quot;YsAvWQ.png&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;8086在内存 0000:0000 到 0000:03FF 的1024个单元中存放着中断向量表&lt;/p&gt;

&lt;h3 id=&quot;18---操作系统----系统调用&quot;&gt;18 - 操作系统  - 系统调用&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;内核态和用户态：&lt;/strong&gt;一种处理器 “硬件设计”， DPL目标段的特权级、CPL当前段的特权级
当前程序执行在什么态用CS的最低两位来表示：0是内核态，3是用户态 数字越小级别越高
计算机对CPU是一段一段地使用，故我们可以用段寄存器来判断特权级 
而GDT表中的表项用来描述一段内存，&lt;strong&gt;在操作系统段中所有的DPL在GDT中都对应内核态&lt;/strong&gt;
当前用户使用时，根据PC（内存段）中的CS段我们可以知道当前用户的CPL，故可以判断权限&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;GDT/LDT表中的描述符，描述的是一段内存。其中的DPL代表着GDT/LDT中的描述符描述的内存段的特权级别。比如，当前正在执行的代码，它的特权级别就是当前的CS段选择子指向的段描述符中的DPL所决定的。即DPL是描述&lt;strong&gt;一段内存&lt;/strong&gt;的特权级别。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;系统调用的核心：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;用户程序中包含一段有中断指令（必须是 &lt;code class=&quot;highlighter-rouge&quot;&gt;INT 0x80&lt;/code&gt;）和系统调用号（&lt;code class=&quot;highlighter-rouge&quot;&gt;INT system_call&lt;/code&gt;）的代码&lt;/li&gt;
  &lt;li&gt;操作系统写中断处理，获取调取程序的编号&lt;/li&gt;
  &lt;li&gt;操作系统根据编号执行相应的代码&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;中断处理-用户态转化成内核态最终调用内核方法&lt;/strong&gt;
硬件提供了 INT 0x80 中断能让我们主动进入内核，最重要的就是 set_system_gate 设置中断陷阱门
set_system_gate 的参数为 &lt;code class=&quot;highlighter-rouge&quot;&gt;INT 0x80&lt;/code&gt;80中断和&lt;code class=&quot;highlighter-rouge&quot;&gt;INT system_call&lt;/code&gt;表示要调用是方法，此时的DPL为3；
通过转化后进入到内核态，设置PC，其中CS为8（100）故可得CPL为0内核态，而IP为 &lt;code class=&quot;highlighter-rouge&quot;&gt;system_call&lt;/code&gt;
通过查system_call_table 得到 _NR_XXX 最终调用 sys_XXX&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;调用的具体过程：&lt;/strong&gt;
用户调用XXX方法 :point_right: 通过库函数展开成宏，调用中断 :point_right: 中断处理system_call  :point_right: 查sys_call_table  	  						:point_right: 得到&lt;/p&gt;

&lt;h3 id=&quot;19---操作系统---进程管理cpu部分&quot;&gt;19 - 操作系统 - 进程管理（CPU部分）&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;CPU使用的关键是：取值执行&lt;/strong&gt; 设置完PC后便自动开始工作，但这样顺序执行有很多缺点：但程序需要调用IO设备或者磁盘时，会等待很久从而造成时间上的浪费，于是我们需要让CPU交替执行多个程序&lt;/p&gt;

&lt;p&gt;一个CPU上交替执行多个程序称为：&lt;strong&gt;并发&lt;/strong&gt;，在交替执行的时候为了完成切换需要保存寄存器等程序信息，从而引入&lt;strong&gt;进程&lt;/strong&gt;（进行中的程序）的概念，CPU在运行多个程序时跑多个进程，因此CPU运行的效率得到大大提升&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多进程图像：&lt;/strong&gt;
CPU用 PCB（Process Control Block 记录进程信息的数据结构）
进程带动内存的使用需要用映射表（MMU）进行内存封存 - 同一地址指向不同物理地址 - 为了共存；&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多线程：&lt;/strong&gt;- TCB 线程控制表
&lt;strong&gt;线程有自己的TCB，thread control block, 只负责这条流程的信息&lt;/strong&gt;，包括PC程序计数器，SP堆栈，State状态，和寄存器。有不同的控制流，需要不同的寄存器来表示控制流的执行状态，每个线程有独立的这些信息，但共享一个资源。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;多核：线程-用户栈和内核栈-进程切换&lt;/strong&gt;
每个线程对应一套栈，用户栈和内核栈
用户栈进入内核栈：系统调用（fork()）会引起中断并且创建一个进程，有两个重点：
&lt;strong&gt;1.一个线程是怎么通过进程切换的 2.创建一个进程需要做哪些准备&lt;/strong&gt;
线程切换五段论：中断入口，建立用户栈和内核栈的联系:point_right: 进入内核态执行，执行完毕过程中或者执行完毕后，系统会判断事件有可能引发切换（中间三段）:point_right: 中断返回 ret_from_sys_call&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;在A处&lt;/strong&gt;调用 fork() 时会产生 INT 0x80中断和 _NR_fork 同时CPU立刻把用户态的相关信息压入内核栈&lt;/li&gt;
  &lt;li&gt;call sys_fork 根据PCB中的state判断进程状态是&lt;strong&gt;就绪&lt;/strong&gt;还是&lt;strong&gt;阻塞&lt;/strong&gt;，&lt;strong&gt;非0则阻塞&lt;/strong&gt;，阻塞需要调度切换  &lt;code class=&quot;highlighter-rouge&quot;&gt;reschedule{ jmp _schedule } &lt;/code&gt;；然后需要判断进程时间片再一次&lt;code class=&quot;highlighter-rouge&quot;&gt;reschedule&lt;/code&gt;；最后返回中断。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;_schedule{ switch_to(next) } &lt;/code&gt;中具体实现调度和切换 ：next=XXX 下一个进程XXX（用调度算法找到下一个已经就绪的进程），switch_to（切换将PC跳到下一个进程XXX中执行）&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;switch_to&lt;/code&gt;&lt;/strong&gt;通过TSS（task state segment 任务段）进行段跳转切换，首先用&lt;strong&gt;TR寄存器&lt;/strong&gt;作为选择子在GDT表中找到TSS描述符，从而找到TSS的段地址，把CPU中的EAX、EBX等寄存器的相关信息保存在原TSS段中（相当于存档）；同理找到下一个进程的TSS段地址赋给TR，将该TSS中的信息拷贝到CPU中（相当于读档），完成跳转。此时下一个进程是我们创建的子进程&lt;/li&gt;
  &lt;li&gt;中断返回 &lt;code class=&quot;highlighter-rouge&quot;&gt;ret_from_sys_call&lt;/code&gt;：先popl 用户态中的信息 最后 iret&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;创建进程的任务就开始了 ThreadCreate：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;要创建下一个进程中的TSS需要用到 &lt;code class=&quot;highlighter-rouge&quot;&gt;sys_fork { call _copy_process }&lt;/code&gt; 此时内核栈中的信息全部作为 _copy_process 的参数从而创建出差不多完全一样的子进程&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;copy_process 细节：创建栈&lt;/p&gt;

    &lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task_struct&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_free_page&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//申请内存空间&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//创建内核栈&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;esp0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PAGE_SIZE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ss0&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;//创建用户栈(和父进程共用的栈 ss和esp 是由父进程中用户栈中传入的)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ss&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xffff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tss&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;esp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;具体过程是：switch_to(next=子进程) 创建子进程同时设置好TSS并且和TCB相连，上面是创建子进程的具体过程&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;执行我们想要的代码：&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;我们创建的子进程随着中断返回到A处，而此时不会和父进程一样的执行fork() 而是 call sys_execve 从而执行我们所要执行的操作&lt;/li&gt;
  &lt;li&gt;要找到真正的PC，我们需要在中断返回前将当前得到的IP 压入到 用户栈中的 EIP 从而真正的赋值给IP寄存器，得到PC从而执行&lt;/li&gt;
  &lt;li&gt;获取当前 IP 要根据 &lt;code class=&quot;highlighter-rouge&quot;&gt;ls -&amp;gt; entry (call do_entry ) &lt;/code&gt;获得&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;do_entry { eip[0] = ex. a_entry }; &lt;/code&gt;a_entry 代表的就是编译器在编译链接产生ls.exe时编译器提供的入口： unsigned a_entry，而 ls文件实际存在于磁盘之中&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;20---操作系统---调度算法---进程合作&quot;&gt;20 - 操作系统 - 调度算法 - 进程合作&lt;/h3&gt;

&lt;h4 id=&quot;调度算法----io约束型和cpu约束型&quot;&gt;&lt;strong&gt;调度算法&lt;/strong&gt; -  IO约束型和CPU约束型&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;IO约束型：&lt;/strong&gt;通常优先级会比较高，提前调用IO可以让设备先处理，CPU可以并发执行，等待设备处理完后CPU读数据就行 此时是 read 中断，对应的通常是前台进程（用户进程）
&lt;strong&gt;CPU约束型：&lt;/strong&gt;用的 TimeOut 中断，对应的通常是后台进程&lt;/p&gt;

&lt;p&gt;一个好的调度算法（&lt;code class=&quot;highlighter-rouge&quot;&gt;Schedule（）&lt;/code&gt;）应该折中、会自适应、能自动分辨前后台进程、以RR（轮转调度算法）为核心、有优先级。具体实现方式是：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;首先找到就绪队列中&lt;strong&gt;优先级最大&lt;/strong&gt;的一个进程（用COUNT时间片表示，越大优先级越高）&lt;/li&gt;
  &lt;li&gt;然后当该进程的时间片为0时，&lt;strong&gt;重新设置所有进程的COUNT&lt;/strong&gt;（右移一位+初始时间片长度），让处于拥塞状态的进程的优先级比当前进程优先级高，等待就绪后可以被CPU调用&lt;/li&gt;
  &lt;li&gt;动态调整COUNT同时也意味着此时调度会从CPU约束转成IO约束，而IO约束对应的是前台进程的特征，于是分辨出前后台进程。原理是拥塞状态下的进程大部分都是前台进程（需要调用IO）在调整后优先级高，阻塞越久优先级越高，但&lt;strong&gt;COUNT不会无限增长破坏RR算法&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;这和COUNT的重置算法有关：$c(n)=c(n-1)/2+P$ 其中 $ c(0)= P$  于&lt;strong&gt;最终收敛于2P&lt;/strong&gt; 不会无限大符合时间片的规则&lt;/li&gt;
  &lt;li&gt;后台进程一直循环可以近似看出是SJF调度，符合CPU约束型&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;进程合作---多个进程共同完成一个任务---信号量&quot;&gt;&lt;strong&gt;进程合作&lt;/strong&gt; - 多个进程共同完成一个任务 - 信号量&lt;/h4&gt;

&lt;p&gt;COUNT信号已经无法简单处理了多个进程等待和资源生产复杂情况了，需要一个信号量来实现“走走停停”，信号量里有value（资源的个数）和PCB阻塞队列（等待在该信号量上的进程），信号量中P操作是消费资源，V操作是生产资源。&lt;/p&gt;

&lt;p&gt;信号量解生产者-消费者问题：
生产者第一步P(empty)需要判断资源是否满了，满了则不能再生产了，empty= 0 表示缓冲区满了，消费者的第一步P(full)则是判断当前已经生产的个数，为零则无法消费，full 表示已经生产的个数；第二步两者都是上锁P(mutex)，然后分别执行读入写出，最后解锁V(mutex)；生产者第三步是V(full) 代表生产了一些资源，而消费者是V(empty) 消耗了一些资源&lt;/p&gt;

&lt;p&gt;信号量需要临界区来保护，因为信号量是所以进程共享的。
临界区保护原则：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;基本原则：互斥进入，进程间的互斥关系保证了是临界区&lt;/li&gt;
  &lt;li&gt;好的保护原则：有空让进和有限等待&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;信号量的具体实现过程：面包算法、关中断方法、原子指令上锁法
在内核中为用于一个数组存放信号量，再建立队列用于存放PCB，因为是全局数据所以要写在内核中，用的时候必须使用系统调用队列中对应的信号量&lt;/p&gt;

&lt;p&gt;死锁处理：PC机通常使用死锁忽略&lt;/p&gt;

&lt;h3 id=&quot;21---操作系统---内存管理&quot;&gt;21 - 操作系统 - 内存管理&lt;/h3&gt;

&lt;h4 id=&quot;内存使用和分段&quot;&gt;内存使用和分段：&lt;/h4&gt;
&lt;p&gt;要从逻辑地址转化成物理地址用&lt;strong&gt;运行时重定位&lt;/strong&gt;最合适，利用的基址放在PCB中，执行指令时第一步就是从PCB(特殊数据结构，其中包含了&lt;strong&gt;GDT&lt;/strong&gt;和&lt;strong&gt;LDT&lt;/strong&gt;)中取出基地址&lt;/p&gt;

&lt;p&gt;由于程序是分段的code segment | data segment …. 方便管理而且在载入时节约资源，所以在存放基地址时还需要按段号分段存放到DS中，形成进程段表。
操作系统的段表就是&lt;strong&gt;GDT&lt;/strong&gt;，子进程的段表是&lt;strong&gt;LDT&lt;/strong&gt;（LDT可以看成是GDT分配的）&lt;/p&gt;

&lt;p&gt;地址翻译的具体实现过程是：首先找到本段的程序段号，然后在LDT表中的找到对应的基地址，完成重定位过程，段号存放在 ldtr 中&lt;/p&gt;

&lt;h4 id=&quot;内存分页&quot;&gt;&lt;strong&gt;内存分页&lt;/strong&gt;：&lt;/h4&gt;

&lt;p&gt;分区是为了能找到空闲的内存区并管理内存，这样在进程载入的时候才找得到空闲内存区，分段分区都是针对的虚拟内存。但分区会产生很多碎片，因此我们&lt;strong&gt;采用分页&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;一个程序有很多段，一个段又对应很多页
用页表实现分页，页表起始地址放在 cr3 通过 MMU 得到页号，页号找到页框号，最后将页框号和逻辑地址相连，页框规定了页的大小，页表存放在PCB中，每个进程都有自己的页表&lt;/p&gt;

&lt;h4 id=&quot;段页内存同时存在&quot;&gt;段页内存同时存在：&lt;/h4&gt;
&lt;p&gt;程序用段-虚拟内存-虚拟内存分页-映射到物理内存
段页同时存在时的重定位（地址翻译）：
段依旧按段表找出基地址加上段偏移得到虚拟地址-再从虚拟地址映射到页表找到页号，利用页号和偏移地址得到物理地址，两层地址翻译：段号到虚拟地址、页号到物理地址&lt;/p&gt;

&lt;h1 id=&quot;备忘录&quot;&gt;备忘录&lt;/h1&gt;

&lt;h1 id=&quot;随记&quot;&gt;随记&lt;/h1&gt;

&lt;h2 id=&quot;5142020-解题的思考&quot;&gt;5/14/2020 解题的思考&lt;/h2&gt;

&lt;p&gt;在解题之前先思考题目考察的内容，不要盲目地做题。先想一想、写一下文档理清思路。
&lt;img src=&quot;https://s1.ax1x.com/2020/05/14/YDcluQ.png&quot; alt=&quot;YDcluQ.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如这一道题目要求将指令复制到另一个地方，解题时首先就应该想到在哪个内存地址可以找到要复制的数据，在8086中CS.dreg 指向的就是程序地址，而 di 中存放着 s 标号的地址，此时 CS:DI 就可以找到 S标号对应的程序地址了，同理便可得目的地址。有了地址就可以考虑如何复制数据，很明显通过 mov指令和寄存器就轻松完成了复制。&lt;/p&gt;

&lt;p&gt;思考的关键就在于如何能快速地利用已经学过的知识来解析问题，&lt;strong&gt;用什么方法，需要找到什么数据（或者地址）&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&quot;5152020-合理计划学习任务&quot;&gt;5/15/2020 合理计划学习任务&lt;/h2&gt;

&lt;p&gt;今天学习进度没有赶得很紧，大学课程的实验让我十分的烦恼。最近只想赶快把汇编看完然后去学OS，自知学知识不能太赶，要一步一个脚印地来，但今天还是跳了很多个实验，寄希望于学完OS后再回头把实验写了，只看重理论很不好，打不下基础，我决定分批次完成实验的内容，明天把理论知识学完，然后分批完成汇编的实验和课程的实验（又把学习当任务了！！其实应该把&lt;strong&gt;学习时间拉长，每天只学一点但一定要完全领悟通透&lt;/strong&gt;，只怪我脑子太笨，如今只能争取理论尽快地领悟，实验只能后补了。）唉，如果大学的课程能不那么赶而且还不要考试就好了。&lt;/p&gt;

&lt;p&gt;有个妹妹自杀了，她的遗书写得十分平静，她所有牵挂的人和事都已经放下了，信中看不出她的绝望和痛苦，好像死亡对她来说只是一件很平常的事，她说她已经去了自己想要的很美好的地方， 突然间我开始相信我们都拥有灵魂了，相信她只是选择了另一种方式存在，愿超脱了肉体的你能永远徜徉在极乐天堂 R.I,P&lt;/p&gt;</content><author><name>true</name></author><category term="日常总结" /><category term="学习" /><summary type="html">技术栈 待完善 底层 操作系统：了解内核、了进程和文件管理等重要的概念和实现方式 编译原理：粗略搞懂编译器的执行过程（汇编√-机器码×） 计算机网络：彻底搞懂连网原理和TCP/IP的具体意义，打通网络黑箱 JVM：这个底层其实还挺好奇的，目前处于黑箱状态 Tomcat：热部署怎么使用的，大概了解原理 数据库高级：索引概念、视图概念、底层逻辑都不清楚其实。 应用类 Vue.js：其实很好奇怎么用MVVM模式来进一步优化界面层啊？！借此完善自己的第一个项目， SpringBoot框架：如何实现前后端数据传输啊？？？ 现在已知的是三层架构模式: 界面层 JSP(EL+JSTL) + JQuery + Ajax 业务逻辑层Web (Servlet+Filter) 数据访问层（Druied链接池+ JDBCUtils）DAO模式 Javaweb注解配置（及时补充） 深入 底层 - 汇编：（王爽《汇编语言第三版》） 3.7 CPU提供的栈机制 入栈和出栈都是以字为单位，通过 SS段寄存器：SP寄存器 来指向栈顶元素 栈是从高地址往低地址增长的，这同时解决了“CPU如何知道此段内存空间是栈“的问题，当SP寄存器 负增长的底线是0000h，故定义起始地址后栈大小也随之确定。但CPU是不会保证我们对栈的操作不会越界的，POP和PUSH的过程中有可能会产生溢出 当栈为空时 SS：SP 指向栈空间最高地址单元的下一个单元 ​ 我们当然希望CPU可以帮我们解决这个问题，比如说在CPU中有记录栈顶上限和栈 底的寄存器，我们可以通过填写这些寄存器来指定栈空间的范围，然后，CPU在执行 push指令的时候靠检测栈顶上限寄存器、在执行pop指令的时候靠检测栈底寄存器保证不 会超界。 ​ 不过，对于8086CPU,这只是我们的一个设想(我们当然可以这样设想，如果CPU是 我们设计的话，这也就不仅仅是一个设想)。实际的情况是，8086CPU 中并没有这样的寄 存器。 ​ 8086CPU不保证我们对栈的操作不会超界。这也就是说，8086CPU 只知道栈顶在何 处(由SS:SP指示)，而不知道我们安排的栈空间有多大。这点就好像CPU只知道当前要执 行的指令在何处(由CS:IP指示),而不知道要执行的指令有多少。从这两点上我们可以看 出8086CPU的工作机理，它只考虑当前的情况:当前的栈顶在何处、当前要执行的指令 是哪一条。 ​ 我们在编程的时候要自己操心栈顶超界的问题，要根据可能用到的最大栈空间，来安 排栈的大小，防止入栈的数据太多而导致的超界;执行出栈操作的时候也要注意，以防栈 空的时候继续出栈而导致的超界。 应用层 - JavaWeb_Filter &amp;amp; Ajax &amp;amp; JSON Json 一种轻量化的通用数据传输格式，轻量化是与XML对比，JSON更小、更快、更易解析。 有两种表示方法 JSON对象 和 JSON字符串 用parse() stringify() 互相转化 采用键值对方式存放 可以放 number、String、数组、JSON对象 语法是花括号 {} 加 key:values 用 逗号，分隔 在 Java 调用时可以选择导 GSON（谷歌） 或者 阿里（推荐阿里 没有太多依赖） 的jar包 Ajax ：Asynchronous JavaScript and XML. （异步的js和xml）是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 同步：在提交表单后必须等待服务器返回才可以继续处理数据（造成页面卡死待响应的现象，体验差） 异步：在提交表单后无须等待，服务器处理完成后会自动返回 Ajax在JQuery中有封装完成的使用方法，JSP页面中应用较多 Filter：JavaWeb的三大组件之一 用于过滤请求 可以用于用户权限的管理 FilterChain 过滤器链（多个过滤器一起工作）如果通过XML配置，则先配置的先调用 FilterChain.doFilter() - 执行过滤操作 如果有下一个过滤器则进入 否则执行后置代码 FilterConfig类 可以获取在XML文件中的配置信息 &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; 时间线 五月 12 - JSON &amp;amp; Ajax &amp;amp; Javaweb_Filter Json 一种轻量化的通用数据传输格式，轻量化是与XML对比，JSON更小、更快、更易解析。 有两种表示方法 JSON对象 和 JSON字符串 用parse() stringify() 互相转化 采用键值对方式存放 可以放 number、String、数组、JSON对象 语法是花括号 {} 加 key:values 用 逗号，分隔 在 Java 调用时可以选择导 GSON（谷歌） 或者 阿里（推荐阿里 没有太多依赖） 的jar包 Ajax ：Asynchronous JavaScript and XML. （异步的js和xml）是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。 同步：在提交表单后必须等待服务器返回才可以继续处理数据（造成页面卡死待响应的现象，体验差） 异步：在提交表单后无须等待，服务器处理完成后会自动返回 Ajax在JQuery中有封装完成的使用方法，JSP页面中应用较多 Filter：JavaWeb的三大组件之一 用于过滤请求 可以用于用户权限的管理 FilterChain 过滤器链（多个过滤器一起工作）如果通过XML配置，则先配置的先调用 FilterChain.doFilter() - 执行过滤操作 如果有下一个过滤器则进入 否则执行后置代码 FilterConfig类 可以获取在XML文件中的配置信息 &amp;lt;init-param&amp;gt; &amp;lt;param-name&amp;gt;&amp;lt;/param-name&amp;gt; &amp;lt;param-value&amp;gt;&amp;lt;/param-value&amp;gt; &amp;lt;/init-param&amp;gt; 13 - 汇编语言 &amp;amp;&amp;amp; 操作系统 ​ 重温了汇编的寄存器部分，预计两天内看完 ​ 操作系统看了Linux 0.11内核的系统启动过程，bochs真难用 ### 14 - 汇编语言 loop指令：两步操作 1.（cx）=（cx）-1 2.判断 cx 是否为零。在debug中用 g + [偏移地址]可以一次性执行所有loop Debug 将它解释为“[idata]” 是-一个内存单元，idata是内存单元的偏移地址; 而编译器将“[idata]” 解释为 idata 。 在汇编源程序中，数据不能以字母开头，所以要在前面加 0 直接写内存的话应当使用0:200~0:2ff 这段空间 dos和其他合法程序通常不会使用这段空间。 程序中的指令就要对这8个数据进行累加，这8个数据在代码段中，程序在运行的时候CS中存放代码段的段地址，所以可以从CS中得到它们的段地址。它们的偏移地址是多少呢?因为用dw定义的数据处于代码段的最开始，所以偏移地址为0，这8个数据就在代码段的偏移0、2、4、6、8、A、C、E处。程序运行时，它们的地址就是CS:0、CS:2、 CS:4、CS:6、CS:8、CS:A、 CS:C、 CS:E。 ………… dw段的数据的值是多少，对于程序来说没有意义。我们定义这些数据的最终目的是，通过它们获取一定容量的内存空间，所以我们在描述dw的作用时，可以说用它定义数据，也可以说用它开辟内存空间。 一般在需要暂存数据的时候，我们都应该使用栈 在8086CPU中只有bx si di bp 这4个寄存器可以用于内存单元寻址，这4个寄存器可以单个出现，或者以4种组合出现： bx+si , bx+di , bp+si , bp+di (ds:bx ss:bp) CPU提供的如[bx+si+idata]的寻址方式为结构化处理提供了方便，用 bx 定位整个结构体，idata定位结构体中的某一个数据项，si 定位数组项中的每个元素。可以写成bx.idata[si]。 15 - 汇编语言 jmp指令经典例题： flag 寄存器： CPU提供了cmp 指令，也提供了je等条件转移指令，如果将它们配合使用，可以实 现根据比较结果进行转移的功能。但这只是“如果”，只是一种合理的建议，和事实上常 用的方法。但究竟是否配合使用它们，完全是你自己的事情。这就好像call 和ret 指令的 关系一样。 8086在内存 0000:0000 到 0000:03FF 的1024个单元中存放着中断向量表 18 - 操作系统 - 系统调用 内核态和用户态：一种处理器 “硬件设计”， DPL目标段的特权级、CPL当前段的特权级 当前程序执行在什么态用CS的最低两位来表示：0是内核态，3是用户态 数字越小级别越高 计算机对CPU是一段一段地使用，故我们可以用段寄存器来判断特权级 而GDT表中的表项用来描述一段内存，在操作系统段中所有的DPL在GDT中都对应内核态 当前用户使用时，根据PC（内存段）中的CS段我们可以知道当前用户的CPL，故可以判断权限 GDT/LDT表中的描述符，描述的是一段内存。其中的DPL代表着GDT/LDT中的描述符描述的内存段的特权级别。比如，当前正在执行的代码，它的特权级别就是当前的CS段选择子指向的段描述符中的DPL所决定的。即DPL是描述一段内存的特权级别。 系统调用的核心： 用户程序中包含一段有中断指令（必须是 INT 0x80）和系统调用号（INT system_call）的代码 操作系统写中断处理，获取调取程序的编号 操作系统根据编号执行相应的代码 中断处理-用户态转化成内核态最终调用内核方法 硬件提供了 INT 0x80 中断能让我们主动进入内核，最重要的就是 set_system_gate 设置中断陷阱门 set_system_gate 的参数为 INT 0x8080中断和INT system_call表示要调用是方法，此时的DPL为3； 通过转化后进入到内核态，设置PC，其中CS为8（100）故可得CPL为0内核态，而IP为 system_call 通过查system_call_table 得到 _NR_XXX 最终调用 sys_XXX 调用的具体过程： 用户调用XXX方法 :point_right: 通过库函数展开成宏，调用中断 :point_right: 中断处理system_call :point_right: 查sys_call_table :point_right: 得到 19 - 操作系统 - 进程管理（CPU部分） CPU使用的关键是：取值执行 设置完PC后便自动开始工作，但这样顺序执行有很多缺点：但程序需要调用IO设备或者磁盘时，会等待很久从而造成时间上的浪费，于是我们需要让CPU交替执行多个程序 一个CPU上交替执行多个程序称为：并发，在交替执行的时候为了完成切换需要保存寄存器等程序信息，从而引入进程（进行中的程序）的概念，CPU在运行多个程序时跑多个进程，因此CPU运行的效率得到大大提升 多进程图像： CPU用 PCB（Process Control Block 记录进程信息的数据结构） 进程带动内存的使用需要用映射表（MMU）进行内存封存 - 同一地址指向不同物理地址 - 为了共存； 多线程：- TCB 线程控制表 线程有自己的TCB，thread control block, 只负责这条流程的信息，包括PC程序计数器，SP堆栈，State状态，和寄存器。有不同的控制流，需要不同的寄存器来表示控制流的执行状态，每个线程有独立的这些信息，但共享一个资源。 多核：线程-用户栈和内核栈-进程切换 每个线程对应一套栈，用户栈和内核栈 用户栈进入内核栈：系统调用（fork()）会引起中断并且创建一个进程，有两个重点： 1.一个线程是怎么通过进程切换的 2.创建一个进程需要做哪些准备 线程切换五段论：中断入口，建立用户栈和内核栈的联系:point_right: 进入内核态执行，执行完毕过程中或者执行完毕后，系统会判断事件有可能引发切换（中间三段）:point_right: 中断返回 ret_from_sys_call 在A处调用 fork() 时会产生 INT 0x80中断和 _NR_fork 同时CPU立刻把用户态的相关信息压入内核栈 call sys_fork 根据PCB中的state判断进程状态是就绪还是阻塞，非0则阻塞，阻塞需要调度切换 reschedule{ jmp _schedule } ；然后需要判断进程时间片再一次reschedule；最后返回中断。 _schedule{ switch_to(next) } 中具体实现调度和切换 ：next=XXX 下一个进程XXX（用调度算法找到下一个已经就绪的进程），switch_to（切换将PC跳到下一个进程XXX中执行） switch_to通过TSS（task state segment 任务段）进行段跳转切换，首先用TR寄存器作为选择子在GDT表中找到TSS描述符，从而找到TSS的段地址，把CPU中的EAX、EBX等寄存器的相关信息保存在原TSS段中（相当于存档）；同理找到下一个进程的TSS段地址赋给TR，将该TSS中的信息拷贝到CPU中（相当于读档），完成跳转。此时下一个进程是我们创建的子进程 中断返回 ret_from_sys_call：先popl 用户态中的信息 最后 iret 创建进程的任务就开始了 ThreadCreate： 要创建下一个进程中的TSS需要用到 sys_fork { call _copy_process } 此时内核栈中的信息全部作为 _copy_process 的参数从而创建出差不多完全一样的子进程 copy_process 细节：创建栈 p = (struct task_struct *)get_free_page();//申请内存空间 //创建内核栈 p-&amp;gt;tss.esp0 = PAGE_SIZE + (long) p ; p-&amp;gt;tss.ss0 = 0x10; //创建用户栈(和父进程共用的栈 ss和esp 是由父进程中用户栈中传入的) p-&amp;gt;tss.ss = ss &amp;amp; 0xffff; p-&amp;gt;tss.esp = esp; 具体过程是：switch_to(next=子进程) 创建子进程同时设置好TSS并且和TCB相连，上面是创建子进程的具体过程 执行我们想要的代码： 我们创建的子进程随着中断返回到A处，而此时不会和父进程一样的执行fork() 而是 call sys_execve 从而执行我们所要执行的操作 要找到真正的PC，我们需要在中断返回前将当前得到的IP 压入到 用户栈中的 EIP 从而真正的赋值给IP寄存器，得到PC从而执行 获取当前 IP 要根据 ls -&amp;gt; entry (call do_entry ) 获得 do_entry { eip[0] = ex. a_entry }; a_entry 代表的就是编译器在编译链接产生ls.exe时编译器提供的入口： unsigned a_entry，而 ls文件实际存在于磁盘之中 20 - 操作系统 - 调度算法 - 进程合作 调度算法 - IO约束型和CPU约束型 IO约束型：通常优先级会比较高，提前调用IO可以让设备先处理，CPU可以并发执行，等待设备处理完后CPU读数据就行 此时是 read 中断，对应的通常是前台进程（用户进程） CPU约束型：用的 TimeOut 中断，对应的通常是后台进程 一个好的调度算法（Schedule（））应该折中、会自适应、能自动分辨前后台进程、以RR（轮转调度算法）为核心、有优先级。具体实现方式是： 首先找到就绪队列中优先级最大的一个进程（用COUNT时间片表示，越大优先级越高） 然后当该进程的时间片为0时，重新设置所有进程的COUNT（右移一位+初始时间片长度），让处于拥塞状态的进程的优先级比当前进程优先级高，等待就绪后可以被CPU调用 动态调整COUNT同时也意味着此时调度会从CPU约束转成IO约束，而IO约束对应的是前台进程的特征，于是分辨出前后台进程。原理是拥塞状态下的进程大部分都是前台进程（需要调用IO）在调整后优先级高，阻塞越久优先级越高，但COUNT不会无限增长破坏RR算法 这和COUNT的重置算法有关：$c(n)=c(n-1)/2+P$ 其中 $ c(0)= P$ 于最终收敛于2P 不会无限大符合时间片的规则 后台进程一直循环可以近似看出是SJF调度，符合CPU约束型 进程合作 - 多个进程共同完成一个任务 - 信号量 COUNT信号已经无法简单处理了多个进程等待和资源生产复杂情况了，需要一个信号量来实现“走走停停”，信号量里有value（资源的个数）和PCB阻塞队列（等待在该信号量上的进程），信号量中P操作是消费资源，V操作是生产资源。 信号量解生产者-消费者问题： 生产者第一步P(empty)需要判断资源是否满了，满了则不能再生产了，empty= 0 表示缓冲区满了，消费者的第一步P(full)则是判断当前已经生产的个数，为零则无法消费，full 表示已经生产的个数；第二步两者都是上锁P(mutex)，然后分别执行读入写出，最后解锁V(mutex)；生产者第三步是V(full) 代表生产了一些资源，而消费者是V(empty) 消耗了一些资源 信号量需要临界区来保护，因为信号量是所以进程共享的。 临界区保护原则： 基本原则：互斥进入，进程间的互斥关系保证了是临界区 好的保护原则：有空让进和有限等待 信号量的具体实现过程：面包算法、关中断方法、原子指令上锁法 在内核中为用于一个数组存放信号量，再建立队列用于存放PCB，因为是全局数据所以要写在内核中，用的时候必须使用系统调用队列中对应的信号量 死锁处理：PC机通常使用死锁忽略 21 - 操作系统 - 内存管理 内存使用和分段： 要从逻辑地址转化成物理地址用运行时重定位最合适，利用的基址放在PCB中，执行指令时第一步就是从PCB(特殊数据结构，其中包含了GDT和LDT)中取出基地址 由于程序是分段的code segment | data segment …. 方便管理而且在载入时节约资源，所以在存放基地址时还需要按段号分段存放到DS中，形成进程段表。 操作系统的段表就是GDT，子进程的段表是LDT（LDT可以看成是GDT分配的） 地址翻译的具体实现过程是：首先找到本段的程序段号，然后在LDT表中的找到对应的基地址，完成重定位过程，段号存放在 ldtr 中 内存分页： 分区是为了能找到空闲的内存区并管理内存，这样在进程载入的时候才找得到空闲内存区，分段分区都是针对的虚拟内存。但分区会产生很多碎片，因此我们采用分页。 一个程序有很多段，一个段又对应很多页 用页表实现分页，页表起始地址放在 cr3 通过 MMU 得到页号，页号找到页框号，最后将页框号和逻辑地址相连，页框规定了页的大小，页表存放在PCB中，每个进程都有自己的页表 段页内存同时存在： 程序用段-虚拟内存-虚拟内存分页-映射到物理内存 段页同时存在时的重定位（地址翻译）： 段依旧按段表找出基地址加上段偏移得到虚拟地址-再从虚拟地址映射到页表找到页号，利用页号和偏移地址得到物理地址，两层地址翻译：段号到虚拟地址、页号到物理地址 备忘录 随记 5/14/2020 解题的思考 在解题之前先思考题目考察的内容，不要盲目地做题。先想一想、写一下文档理清思路。 如这一道题目要求将指令复制到另一个地方，解题时首先就应该想到在哪个内存地址可以找到要复制的数据，在8086中CS.dreg 指向的就是程序地址，而 di 中存放着 s 标号的地址，此时 CS:DI 就可以找到 S标号对应的程序地址了，同理便可得目的地址。有了地址就可以考虑如何复制数据，很明显通过 mov指令和寄存器就轻松完成了复制。 思考的关键就在于如何能快速地利用已经学过的知识来解析问题，用什么方法，需要找到什么数据（或者地址） 5/15/2020 合理计划学习任务 今天学习进度没有赶得很紧，大学课程的实验让我十分的烦恼。最近只想赶快把汇编看完然后去学OS，自知学知识不能太赶，要一步一个脚印地来，但今天还是跳了很多个实验，寄希望于学完OS后再回头把实验写了，只看重理论很不好，打不下基础，我决定分批次完成实验的内容，明天把理论知识学完，然后分批完成汇编的实验和课程的实验（又把学习当任务了！！其实应该把学习时间拉长，每天只学一点但一定要完全领悟通透，只怪我脑子太笨，如今只能争取理论尽快地领悟，实验只能后补了。）唉，如果大学的课程能不那么赶而且还不要考试就好了。 有个妹妹自杀了，她的遗书写得十分平静，她所有牵挂的人和事都已经放下了，信中看不出她的绝望和痛苦，好像死亡对她来说只是一件很平常的事，她说她已经去了自己想要的很美好的地方， 突然间我开始相信我们都拥有灵魂了，相信她只是选择了另一种方式存在，愿超脱了肉体的你能永远徜徉在极乐天堂 R.I,P</summary></entry></feed>