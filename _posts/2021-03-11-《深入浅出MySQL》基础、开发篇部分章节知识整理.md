---
layout: post
title:  "《深入浅出MySQL》基础、开发篇部分章节知识整理"
date:   2021-03-11 12:30:00 +0800
tags: MySQL 学习
color: rgb(255,210,32)
cover: '../assets/mysql.gif'
subtitle: '对MySQL的常用知识的理解'
---

# :book: 《深入浅出MySQL》基础、开发篇部分章节知识整理

> 对《深入浅出MySQL》中理解不深入章节的知识笔记整理:notebook_with_decorative_cover:

## :wavy_dash: 窗口函数

窗口函数的语法定义:

```mysql
SELECT * FROM (
  SELECT 窗口函数() OVER([PARTITION BY|ORDER BY]column_name |[FRAME 子句]) AS column_name,
  column_name1,column_name2.....FROM table_name
	)table_name [WHERE];
```

​		窗口函数可以借助聚合函数的概念来理解，聚合函数是把多个行聚合到同一行，而窗口函数是把多个行聚合到相同的多个行里，窗口的意思就是要在表中根据某一个条件划分出某一个区域，如果区域的大小不变则为静态窗口，大小浮动则为滑动窗口。

​		划分窗口使用的就是使用`PARTITION BY`语句把某一列进行窗口划分，窗口函数就被用来对这些窗口进行某些的操作，`ORDER BY`语句就是定义排序规则，`FRAME`语句则被用来创建滑动窗口。

* **MySQL中的窗口函数：**

  | 函数                | 功能                                   |
  | ------------------- | -------------------------------------- |
  | **ROW_NUMBER()**    | **分区中当前的行号**                   |
  | **RANK()**          | **当前行在分区中的排名，含序号间隙**   |
  | **DENSE_RANK()**    | **当前行在分区中的排名，不含序号间隙** |
  | PERCENT_RANK()      | 百分比等级值                           |
  | **CUME_DIST()**     | **累计百分比(RANK值/分组总数)**        |
  | ***FIRST_VALUE()*** | ***当前窗口中的第一行参数的值***       |
  | ***LAST_VALUE()***  | ***当前窗口中的最尾行参数的值***       |
  | LAG()               | 分区中指定好落后于当前行的参数值       |
  | LEAD()              | 分区中领先当前行的参数值               |
  | NTH_VALUE()         | 从第N行窗口框架的参数值                |
  | NTILE()             | 分区中当前行的桶号(按某种规则等分小组) |

* `PARTITION BY`**划分小组的理解**：

  ```mysql
  #	所使用的数据展示
  mysql> select * from order_tab;
  +----------+---------+--------+---------------------+
  | order_id | user_no | amount | create_date         |
  +----------+---------+--------+---------------------+
  |        1 |       1 |    100 | 2021-03-01 00:00:00 |
  |        2 |       1 |    300 | 2021-03-02 00:00:00 |
  |        3 |       1 |    500 | 2021-03-02 00:00:00 |
  |        4 |       1 |    800 | 2021-03-03 00:00:00 |
  |        5 |       1 |    900 | 2021-03-04 00:00:00 |
  |        6 |       2 |    500 | 2021-03-05 00:00:00 |
  |        7 |       2 |    600 | 2021-03-06 00:00:00 |
  |        8 |       2 |    300 | 2021-03-07 00:00:00 |
  |        9 |       2 |    800 | 2021-03-08 00:00:00 |
  |       10 |       2 |    800 | 2021-03-09 00:00:00 |
  +----------+---------+--------+---------------------+
  10 rows in set (0.01 sec)
  ```

  我们先从`FIRST_VALUE()`和`LAST_VALUE()`创建一个滑动窗口入手，先书写一个这样的语句：

  ```mysql
  #	这条语句的意思是按user_no划分窗口（这里有两个小组即user_no=1 | user_no=2）
  # 然后窗口滑动增大，并找出当前窗口中第一个值和最后一个值，窗口按order_id排序
  mysql> select *
      -> from (
      ->          select order_id,
      ->                 user_no,
      ->                 amount,
      ->                 first_value(amount) over (w) as first_amount,
      ->                 last_value(amount) over (w)  as last_amount
      ->          from order_tab WINDOW w as (partition by user_no order by order_id)
      ->      ) t;
  +----------+---------+--------+--------------+-------------+
  | order_id | user_no | amount | first_amount | last_amount |
  +----------+---------+--------+--------------+-------------+
  |        1 |       1 |    100 |          100 |         100 |
  |        2 |       1 |    300 |          100 |         300 |
  |        3 |       1 |    500 |          100 |         500 |
  |        4 |       1 |    800 |          100 |         800 |
  |        5 |       1 |    900 |          100 |         900 |
  |        6 |       2 |    500 |          500 |         500 |
  |        7 |       2 |    600 |          500 |         600 |
  |        8 |       2 |    300 |          500 |         300 |
  |        9 |       2 |    800 |          500 |         800 |
  |       10 |       2 |    800 |          500 |         800 |
  +----------+---------+--------+--------------+-------------+
  10 rows in set (0.01 sec)
  ```

  静态窗口同理，假设我们要查看排名的话可以使用`RANK()`系列的函数，如果使用了`partition by user_no`就是按用户分组查看排名，按哪一列进行排序则要看`order by `语句。此时该函数，随着记录的不同，窗口大小都是不变的（即查看排名时窗口大小都是两个用户分组的大小），不像上段代码中滑动增长，因此就被称为是静态窗口。

  *<u>（这段代码就靠自己书写啦！PS：找好相对应的函数，如果用`DENSE_RANK(amount)`就是`amount`排名）</u>*

* **FRAME子句：基于行和基于范围：**

  > 以下摘抄于《深入浅出MySQL - 5.6 窗口函数》FRAME子句部分

  1. 基于行：通常使用 `BETWEEN frame_start AND frame_end`来表示行范围，以下关键字可以支持`frame_start`和`frame_end`，这样可以用来确定不同的动态行记录：

     ```mysql
     `CURRNT ROW`					# 边界是当前行，一般和其他范围关键字一起使用
     `UNBOUNDED PRECEDING` # 边界是分区的第一行
     `UNBOUNDED FOLLOWING`	# 边界是分区的最后一行
     `expr PRECEDING`			# 边界是当前行减去expr的值
     `expr FOLLOWING`			# 边界是当前行加上expr的值
     
     # 以下为一些用法
     # 窗口范围是当前行、前一行、后一行一共3行记录
     rows BETWEEN 1 PRECEDING AND 1 FOLLOWING	
     
     #	窗口范围是当前行到分区中的最后一行
     rows UNBOUNDED FOLLOWING
     
     # 窗口范围是当前分区中所有行
     rows BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
     ```
     
  2. 基于范围：有些范围不可以直接使用行数来表示，如果窗口范围是一周前的订单开始到当前行，这需要使用范围来表示窗口:`INTERVAL 7 DAY PRECEDING`，时间就是一个可以经常被使用的应用场景
  
  ```mysql
  #  FRAME子句使用展示：把当前行与上下行的amount进行加和并输出
  mysql> select *
      -> from (
      ->          select order_id,
      ->                 user_no,
      ->                 amount,
      ->                 sum(amount) over w as summary
      ->          from order_tab
      ->              WINDOW w as (partition by user_no
      ->                  order by order_id
      ->                  rows between 1 preceding and 1 following)
      ->      ) t;
  +----------+---------+--------+---------+
  | order_id | user_no | amount | summary |
  +----------+---------+--------+---------+
  |        1 |       1 |    100 |     400 |
  |        2 |       1 |    300 |     900 |
  |        3 |       1 |    500 |    1600 |
  |        4 |       1 |    800 |    2200 |
  |        5 |       1 |    900 |    1700 |
  |        6 |       2 |    500 |    1100 |
  |        7 |       2 |    600 |    1400 |
  |        8 |       2 |    300 |    1700 |
  |        9 |       2 |    800 |    1900 |
  |       10 |       2 |    800 |    1600 |
  +----------+---------+--------+---------+
  10 rows in set (0.09 sec)
  ```
  
* **聚合函数：**由上所示，聚合函数也可以作为窗口函数来使用，如求累计、平均、最大、最小、总数都是被作为窗口函数来使用的。

#### :memo: 建表使用的MySQL语句

```mysql
create table order_tab(order_id int not null PRIMARY KEY ,user_no int not null ,amount int,create_date datetime);

INSERT INTO test1.order_tab (order_id, user_no, amount, create_date) VALUES (1, 1, 100, '2021-03-01 00:00:00')
INSERT INTO test1.order_tab (order_id, user_no, amount, create_date) VALUES (2, 1, 300, '2021-03-02 00:00:00')
INSERT INTO test1.order_tab (order_id, user_no, amount, create_date) VALUES (3, 1, 500, '2021-03-02 00:00:00')
INSERT INTO test1.order_tab (order_id, user_no, amount, create_date) VALUES (4, 1, 800, '2021-03-03 00:00:00')
INSERT INTO test1.order_tab (order_id, user_no, amount, create_date) VALUES (5, 1, 900, '2021-03-04 00:00:00')
INSERT INTO test1.order_tab (order_id, user_no, amount, create_date) VALUES (6, 2, 500, '2021-03-05 00:00:00')
INSERT INTO test1.order_tab (order_id, user_no, amount, create_date) VALUES (7, 2, 600, '2021-03-06 00:00:00')
INSERT INTO test1.order_tab (order_id, user_no, amount, create_date) VALUES (8, 2, 300, '2021-03-07 00:00:00')
INSERT INTO test1.order_tab (order_id, user_no, amount, create_date) VALUES (9, 2, 800, '2021-03-08 00:00:00')
INSERT INTO test1.order_tab (order_id, user_no, amount, create_date) VALUES (10, 2, 800, '2021-03-09 00:00:00')
```



## :zap: 【代办】索引：



## :zap: 【代办】开发常用数据库对象：



## :zap: 【代办】MySQL分区：

